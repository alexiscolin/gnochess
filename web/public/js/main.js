var Jp = Object.defineProperty;
var Qp = (r, e, t) =>
  e in r
    ? Jp(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (r[e] = t);
var tn = (r, e, t) => (Qp(r, typeof e != 'symbol' ? e + '' : e, t), t);
function em(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, 'default')
    ? r.default
    : r;
}
var Df = { exports: {} };
(function (r, e) {
  (function (t, n) {
    r.exports = n();
  })(self, function () {
    return (() => {
      var t = {
          d: (g, d) => {
            for (var m in d)
              t.o(d, m) &&
                !t.o(g, m) &&
                Object.defineProperty(g, m, { enumerable: !0, get: d[m] });
          },
          o: (g, d) => Object.prototype.hasOwnProperty.call(g, d),
          r: (g) => {
            typeof Symbol < 'u' &&
              Symbol.toStringTag &&
              Object.defineProperty(g, Symbol.toStringTag, { value: 'Module' }),
              Object.defineProperty(g, '__esModule', { value: !0 });
          }
        },
        n = {};
      function i(g) {
        return typeof g != 'string'
          ? ''
          : g.charAt(0).toUpperCase() + g.slice(1);
      }
      function s(g, d) {
        (d == null || d > g.length) && (d = g.length);
        for (var m = 0, y = new Array(d); m < d; m++) y[m] = g[m];
        return y;
      }
      function o(g, d) {
        for (var m = 0; m < d.length; m++) {
          var y = d[m];
          (y.enumerable = y.enumerable || !1),
            (y.configurable = !0),
            'value' in y && (y.writable = !0),
            Object.defineProperty(g, y.key, y);
        }
      }
      t.r(n), t.d(n, { App: () => _, Component: () => c, Module: () => h });
      var a = (function () {
        function g(y) {
          (function (v, x) {
            if (!(v instanceof x))
              throw new TypeError('Cannot call a class as a function');
          })(this, g),
            (this.DOM = { el: y }),
            (this._compEvents = []),
            (this.componentsId = 0),
            this.components,
            this.app,
            (this.binded = {});
        }
        var d, m;
        return (
          (d = g),
          (m = [
            {
              key: '_compUpdate',
              value: function (y) {
                (this.components = y),
                  (this.app = this.components.get('App').get('global'));
              }
            },
            {
              key: '_compResize',
              value: function (y) {
                this.resize(y);
              }
            },
            {
              key: '_compDestroy',
              value: function () {
                for (var y = this._compEvents.length; y > 0; )
                  (y -= 1), this.off(y, this._compEvents[y], !0);
                (this.binded = {}), this.destroy();
              }
            },
            {
              key: 'call',
              value: function (y, v, x, S) {
                if (
                  (v && !x && ((x = v), (v = !1)),
                  (x = i(x)),
                  this.components.has(x))
                ) {
                  S = S || this.components.get(x).entries().next().value[0];
                  var b = this.components.get(x).get(S);
                  if (b != null && b[y])
                    return (
                      (v = Array.isArray(v) ? v : [v]),
                      b[y].apply(
                        b,
                        (function (C) {
                          if (Array.isArray(C)) return s(C);
                        })((T = v)) ||
                          (function (C) {
                            if (
                              (typeof Symbol < 'u' &&
                                C[Symbol.iterator] != null) ||
                              C['@@iterator'] != null
                            )
                              return Array.from(C);
                          })(T) ||
                          (function (C, M) {
                            if (C) {
                              if (typeof C == 'string') return s(C, M);
                              var A = Object.prototype.toString
                                .call(C)
                                .slice(8, -1);
                              return (
                                A === 'Object' &&
                                  C.constructor &&
                                  (A = C.constructor.name),
                                A === 'Map' || A === 'Set'
                                  ? Array.from(C)
                                  : A === 'Arguments' ||
                                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                                      A
                                    )
                                  ? s(C, M)
                                  : void 0
                              );
                            }
                          })(T) ||
                          (function () {
                            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                          })()
                      )
                    );
                }
                var T;
              }
            },
            {
              key: 'on',
              value: function (y) {
                var v = y.e,
                  x = y.target,
                  S = y.cb,
                  b = y.opts,
                  T = b !== void 0 && b;
                return (
                  x.addEventListener(v, S, T),
                  this._compEvents.push(
                    Object.assign(y, { id: this.componentsId })
                  ),
                  this.componentsId++
                );
              }
            },
            {
              key: 'off',
              value: function (y, v) {
                var x,
                  S =
                    arguments.length > 2 &&
                    arguments[2] !== void 0 &&
                    arguments[2];
                if (!v) {
                  for (var b = 0; b < this._compEvents.length; b++)
                    if (this._compEvents[b].id === y) {
                      (v = this._compEvents[b]), (x = b);
                      break;
                    }
                }
                x = S ? y : x;
                var T = v,
                  C = T.e,
                  M = T.target,
                  A = T.cb,
                  X = T.opts,
                  Y = X !== void 0 && X;
                M.removeEventListener(C, A, Y), this._compEvents.splice(x, 1);
              }
            },
            { key: 'init', value: function () {} },
            { key: 'resize', value: function () {} },
            { key: 'destroy', value: function () {} }
          ]) && o(d.prototype, m),
          g
        );
      })();
      (a.prototype.emitter = {}),
        (a.prototype.trigger = function (g) {
          for (
            var d = arguments.length, m = new Array(d > 1 ? d - 1 : 0), y = 1;
            y < d;
            y++
          )
            m[y - 1] = arguments[y];
          !!a.prototype.emitter[g] != 0 &&
            a.prototype.emitter[g].slice().forEach(function (v) {
              v.apply(void 0, m);
            });
        }),
        (a.prototype.subscribe = function (g, d) {
          !!a.prototype.emitter[g] == 0 && (a.prototype.emitter[g] = []),
            a.prototype.emitter[g].push(d);
        }),
        (a.prototype.unsubscribe = function (g, d) {
          var m = a.prototype.emitter[g];
          if (!!m != 0) {
            var y = m.indexOf(d);
            m.splice(y);
          }
        });
      const c = a;
      function l(g, d) {
        for (var m = 0; m < d.length; m++) {
          var y = d[m];
          (y.enumerable = y.enumerable || !1),
            (y.configurable = !0),
            'value' in y && (y.writable = !0),
            Object.defineProperty(g, y.key, y);
        }
      }
      const h = (function () {
        function g(y) {
          (function (v, x) {
            if (!(v instanceof x))
              throw new TypeError('Cannot call a class as a function');
          })(this, g),
            (this.components = y);
        }
        var d, m;
        return (
          (d = g),
          (m = [
            {
              key: 'getComponent',
              value: function (y, v) {
                var x = this;
                try {
                  var S = (function (b) {
                    var T = x.components.get(b);
                    if (T) return T;
                    throw 'Component "'.concat(b, `" doesn't exist.`);
                  })(y);
                  return v
                    ? S == null
                      ? void 0
                      : S.get(v)
                    : S == null
                    ? void 0
                    : S.values().next().value;
                } catch (b) {
                  console.error(b);
                }
              }
            }
          ]) && l(d.prototype, m),
          g
        );
      })();
      function f(g) {
        return (
          (function (d) {
            if (Array.isArray(d)) return u(d);
          })(g) ||
          (function (d) {
            if (
              (typeof Symbol < 'u' && d[Symbol.iterator] != null) ||
              d['@@iterator'] != null
            )
              return Array.from(d);
          })(g) ||
          (function (d, m) {
            if (d) {
              if (typeof d == 'string') return u(d, m);
              var y = Object.prototype.toString.call(d).slice(8, -1);
              return (
                y === 'Object' && d.constructor && (y = d.constructor.name),
                y === 'Map' || y === 'Set'
                  ? Array.from(d)
                  : y === 'Arguments' ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y)
                  ? u(d, m)
                  : void 0
              );
            }
          })(g) ||
          (function () {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })()
        );
      }
      function u(g, d) {
        (d == null || d > g.length) && (d = g.length);
        for (var m = 0, y = new Array(d); m < d; m++) y[m] = g[m];
        return y;
      }
      function p(g, d) {
        for (var m = 0; m < d.length; m++) {
          var y = d[m];
          (y.enumerable = y.enumerable || !1),
            (y.configurable = !0),
            'value' in y && (y.writable = !0),
            Object.defineProperty(g, y.key, y);
        }
      }
      var _ = (function () {
        function g(y) {
          (function (v, x) {
            if (!(v instanceof x))
              throw new TypeError('Cannot call a class as a function');
          })(this, g),
            this.app,
            (this.components = y.components || []),
            (this.activeComponents = new Map()),
            (this.newComponents = new Map()),
            (this.componentsId = 0),
            (this._globalEventsFuncs = {}),
            this._resize();
        }
        var d, m;
        return (
          (d = g),
          (m = [
            {
              key: 'init',
              value: function (y, v) {
                var x = this;
                y && !this.app && (this.app = y),
                  this.activeComponents.set(
                    'App',
                    new Map([['global', this.app]])
                  ),
                  f(
                    (v || document).querySelectorAll('[data-component]')
                  ).forEach(function (S) {
                    var b = S.dataset.component;
                    if (
                      (b =
                        x.components[i(b)] || x.components[b] ? i(b) : '') !==
                      ''
                    ) {
                      var T = new x.components[b](S),
                        C = S.dataset.componentId;
                      C ||
                        (x.componentsId++,
                        (C = S.dataset.componentId =
                          'comp-'.concat(x.componentsId))),
                        x.newComponents.set(''.concat(b, '-').concat(C), T),
                        x.activeComponents.has(b)
                          ? x.activeComponents.get(b).set(C, T)
                          : x.activeComponents.set(b, new Map([[C, T]]));
                    }
                  }),
                  this._listAllComponents(function (S, b, T) {
                    S._compUpdate(x.activeComponents),
                      x.newComponents.has(''.concat(i(b), '-').concat(T)) &&
                        S.init({});
                  }),
                  this.newComponents.clear();
              }
            },
            {
              key: '_listAllComponents',
              value: function (y) {
                this.activeComponents.forEach(function (v, x) {
                  return v.forEach(function (S, b) {
                    i(x) !== 'App' && y(S, x, b);
                  });
                });
              }
            },
            {
              key: 'update',
              value: function (y) {
                var v = this;
                this.init(this.app, y),
                  this._listAllComponents(function (x) {
                    return x._compUpdate(v.activeComponents);
                  });
              }
            },
            {
              key: 'windowSizeInfos',
              get: function () {
                return {
                  windowSizes: {
                    width: window.innerWidth,
                    height: window.innerHeight
                  }
                };
              }
            },
            {
              key: '_resize',
              value: function () {
                var y,
                  v,
                  x,
                  S,
                  b = this;
                ((v = (y = this._globalEventsFuncs).resize) !== null &&
                  v !== void 0) ||
                  (y.resize =
                    ((x = function () {
                      b._listAllComponents(function (T) {
                        var C = b.windowSizeInfos.windowSizes;
                        T._compResize(C);
                      });
                    }),
                    function () {
                      var T = this,
                        C = arguments,
                        M = function () {
                          (S = null), x.apply(T, C);
                        };
                      clearTimeout(S), (S = setTimeout(M, 350));
                    })),
                  window.addEventListener(
                    'resize',
                    this._globalEventsFuncs.resize
                  );
              }
            },
            {
              key: 'destroy',
              value: function (y) {
                var v = this;
                y
                  ? f(y.querySelectorAll('[data-component]')).forEach(
                      function (x) {
                        var S = i(x.dataset.component),
                          b = x.dataset.componentId;
                        if (v.activeComponents.has(S)) {
                          var T = v.activeComponents.get(S);
                          T.get(b)._compDestroy(),
                            T.delete(b),
                            T.size <= 0 && v.activeComponents.delete(S);
                        }
                      }
                    )
                  : (this.activeComponents.forEach(function (x, S) {
                      i(S) !== 'App' &&
                        x.forEach(function (b) {
                          return b._compDestroy();
                        });
                    }),
                    this.activeComponents.clear(),
                    window.removeEventListener(
                      'resize',
                      this._globalEventsFuncs.resize
                    ));
              }
            }
          ]) && p(d.prototype, m),
          g
        );
      })();
      return n;
    })();
  });
})(Df);
var Wn = Df.exports;
function ii(r) {
  if (r === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return r;
}
function If(r, e) {
  (r.prototype = Object.create(e.prototype)),
    (r.prototype.constructor = r),
    (r.__proto__ = e);
}
/*!
 * GSAP 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var ln = {
    autoSleep: 120,
    force3D: 'auto',
    nullTargetWarn: 1,
    units: { lineHeight: '' }
  },
  ts = { duration: 0.5, overwrite: !1, delay: 0 },
  ul,
  kt,
  at,
  xn = 1e8,
  Ze = 1 / xn,
  wc = Math.PI * 2,
  tm = wc / 4,
  nm = 0,
  Of = Math.sqrt,
  im = Math.cos,
  rm = Math.sin,
  Tt = function (e) {
    return typeof e == 'string';
  },
  ct = function (e) {
    return typeof e == 'function';
  },
  li = function (e) {
    return typeof e == 'number';
  },
  fl = function (e) {
    return typeof e > 'u';
  },
  Gn = function (e) {
    return typeof e == 'object';
  },
  Kt = function (e) {
    return e !== !1;
  },
  dl = function () {
    return typeof window < 'u';
  },
  ao = function (e) {
    return ct(e) || Tt(e);
  },
  Uf =
    (typeof ArrayBuffer == 'function' && ArrayBuffer.isView) || function () {},
  Bt = Array.isArray,
  Rc = /(?:-?\.?\d|\.)+/gi,
  Nf = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  Wr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  Ra = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  Ff = /[+-]=-?[.\d]+/,
  kf = /[^,'"\[\]\s]+/gi,
  sm = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  it,
  mn,
  Cc,
  pl,
  hn = {},
  Qo = {},
  Bf,
  zf = function (e) {
    return (Qo = mr(e, hn)) && Qt;
  },
  ml = function (e, t) {
    return console.warn(
      'Invalid property',
      e,
      'set to',
      t,
      'Missing plugin? gsap.registerPlugin()'
    );
  },
  ea = function (e, t) {
    return !t && console.warn(e);
  },
  Hf = function (e, t) {
    return (e && (hn[e] = t) && Qo && (Qo[e] = t)) || hn;
  },
  Ws = function () {
    return 0;
  },
  om = { suppressEvents: !0, isStart: !0, kill: !1 },
  Vo = { suppressEvents: !0, kill: !1 },
  am = { suppressEvents: !0 },
  gl = {},
  Li = [],
  Lc = {},
  Gf,
  an = {},
  Ca = {},
  ah = 30,
  Wo = [],
  _l = '',
  vl = function (e) {
    var t = e[0],
      n,
      i;
    if ((Gn(t) || ct(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
      for (i = Wo.length; i-- && !Wo[i].targetTest(t); );
      n = Wo[i];
    }
    for (i = e.length; i--; )
      (e[i] && (e[i]._gsap || (e[i]._gsap = new fd(e[i], n)))) ||
        e.splice(i, 1);
    return e;
  },
  or = function (e) {
    return e._gsap || vl(Mn(e))[0]._gsap;
  },
  Vf = function (e, t, n) {
    return (n = e[t]) && ct(n)
      ? e[t]()
      : (fl(n) && e.getAttribute && e.getAttribute(t)) || n;
  },
  $t = function (e, t) {
    return (e = e.split(',')).forEach(t) || e;
  },
  ht = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  wt = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  Yr = function (e, t) {
    var n = t.charAt(0),
      i = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      n === '+' ? e + i : n === '-' ? e - i : n === '*' ? e * i : e / i
    );
  },
  cm = function (e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
    return i < n;
  },
  ta = function () {
    var e = Li.length,
      t = Li.slice(0),
      n,
      i;
    for (Lc = {}, Li.length = 0, n = 0; n < e; n++)
      (i = t[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  Wf = function (e, t, n, i) {
    Li.length && !kt && ta(),
      e.render(t, n, i || (kt && t < 0 && (e._initted || e._startAt))),
      Li.length && !kt && ta();
  },
  qf = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + '').match(kf).length < 2
      ? t
      : Tt(e)
      ? e.trim()
      : e;
  },
  Xf = function (e) {
    return e;
  },
  En = function (e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  },
  lm = function (e) {
    return function (t, n) {
      for (var i in n)
        i in t || (i === 'duration' && e) || i === 'ease' || (t[i] = n[i]);
    };
  },
  mr = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  ch = function r(e, t) {
    for (var n in t)
      n !== '__proto__' &&
        n !== 'constructor' &&
        n !== 'prototype' &&
        (e[n] = Gn(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e;
  },
  na = function (e, t) {
    var n = {},
      i;
    for (i in e) i in t || (n[i] = e[i]);
    return n;
  },
  ks = function (e) {
    var t = e.parent || it,
      n = e.keyframes ? lm(Bt(e.keyframes)) : En;
    if (Kt(e.inherit))
      for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  hm = function (e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; );
    return n < 0;
  },
  jf = function (e, t, n, i, s) {
    n === void 0 && (n = '_first'), i === void 0 && (i = '_last');
    var o = e[i],
      a;
    if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
    return (
      o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[n]), (e[n] = t)),
      t._next ? (t._next._prev = t) : (e[i] = t),
      (t._prev = o),
      (t.parent = t._dp = e),
      t
    );
  },
  da = function (e, t, n, i) {
    n === void 0 && (n = '_first'), i === void 0 && (i = '_last');
    var s = t._prev,
      o = t._next;
    s ? (s._next = o) : e[n] === t && (e[n] = o),
      o ? (o._prev = s) : e[i] === t && (e[i] = s),
      (t._next = t._prev = t.parent = null);
  },
  Ui = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  ar = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
    return e;
  },
  um = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  Pc = function (e, t, n, i) {
    return (
      e._startAt &&
      (kt
        ? e._startAt.revert(Vo)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, i))
    );
  },
  fm = function r(e) {
    return !e || (e._ts && r(e.parent));
  },
  lh = function (e) {
    return e._repeat ? ns(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  ns = function (e, t) {
    var n = Math.floor((e /= t));
    return e && n === e ? n - 1 : n;
  },
  ia = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  pa = function (e) {
    return (e._end = wt(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || Ze) || 0)
    ));
  },
  ma = function (e, t) {
    var n = e._dp;
    return (
      n &&
        n.smoothChildTiming &&
        e._ts &&
        ((e._start = wt(
          n._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        pa(e),
        n._dirty || ar(n, e)),
      e
    );
  },
  Yf = function (e, t) {
    var n;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((n = ia(e.rawTime(), t)),
        (!t._dur || no(0, t.totalDuration(), n) - t._tTime > Ze) &&
          t.render(n, !0)),
      ar(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (n = e; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
      e._zTime = -Ze;
    }
  },
  Un = function (e, t, n, i) {
    return (
      t.parent && Ui(t),
      (t._start = wt(
        (li(n) ? n : n || e !== it ? pn(e, n, t) : e._time) + t._delay
      )),
      (t._end = wt(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      jf(e, t, '_first', '_last', e._sort ? '_start' : 0),
      Dc(t) || (e._recent = t),
      i || Yf(e, t),
      e._ts < 0 && ma(e, e._tTime),
      e
    );
  },
  Kf = function (e, t) {
    return (
      (hn.ScrollTrigger || ml('scrollTrigger', t)) &&
      hn.ScrollTrigger.create(t, e)
    );
  },
  $f = function (e, t, n, i, s) {
    if ((xl(e, t, s), !e._initted)) return 1;
    if (
      !n &&
      e._pt &&
      !kt &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      Gf !== cn.frame
    )
      return Li.push(e), (e._lazy = [s, i]), 1;
  },
  dm = function r(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t));
  },
  Dc = function (e) {
    var t = e.data;
    return t === 'isFromStart' || t === 'isStart';
  },
  pm = function (e, t, n, i) {
    var s = e.ratio,
      o =
        t < 0 ||
        (!t &&
          ((!e._start && dm(e) && !(!e._initted && Dc(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !Dc(e))))
          ? 0
          : 1,
      a = e._rDelay,
      c = 0,
      l,
      h,
      f;
    if (
      (a &&
        e._repeat &&
        ((c = no(0, e._tDur, t)),
        (h = ns(c, a)),
        e._yoyo && h & 1 && (o = 1 - o),
        h !== ns(e._tTime, a) &&
          ((s = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== s || kt || i || e._zTime === Ze || (!t && e._zTime))
    ) {
      if (!e._initted && $f(e, t, i, n, c)) return;
      for (
        f = e._zTime,
          e._zTime = t || (n ? Ze : 0),
          n || (n = t && !f),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = c,
          l = e._pt;
        l;

      )
        l.r(o, l.d), (l = l._next);
      t < 0 && Pc(e, t, n, !0),
        e._onUpdate && !n && Sn(e, 'onUpdate'),
        c && e._repeat && !n && e.parent && Sn(e, 'onRepeat'),
        (t >= e._tDur || t < 0) &&
          e.ratio === o &&
          (o && Ui(e, 1),
          !n &&
            !kt &&
            (Sn(e, o ? 'onComplete' : 'onReverseComplete', !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  mm = function (e, t, n) {
    var i;
    if (n > t)
      for (i = e._first; i && i._start <= n; ) {
        if (i.data === 'isPause' && i._start > t) return i;
        i = i._next;
      }
    else
      for (i = e._last; i && i._start >= n; ) {
        if (i.data === 'isPause' && i._start < t) return i;
        i = i._prev;
      }
  },
  is = function (e, t, n, i) {
    var s = e._repeat,
      o = wt(t) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !i && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = s ? (s < 0 ? 1e10 : wt(o * (s + 1) + e._rDelay * s)) : o),
      a > 0 && !i && ma(e, (e._tTime = e._tDur * a)),
      e.parent && pa(e),
      n || ar(e.parent, e),
      e
    );
  },
  hh = function (e) {
    return e instanceof Yt ? ar(e) : is(e, e._dur);
  },
  gm = { _start: 0, endTime: Ws, totalDuration: Ws },
  pn = function r(e, t, n) {
    var i = e.labels,
      s = e._recent || gm,
      o = e.duration() >= xn ? s.endTime(!1) : e._dur,
      a,
      c,
      l;
    return Tt(t) && (isNaN(t) || t in i)
      ? ((c = t.charAt(0)),
        (l = t.substr(-1) === '%'),
        (a = t.indexOf('=')),
        c === '<' || c === '>'
          ? (a >= 0 && (t = t.replace(/=/, '')),
            (c === '<' ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (l ? (a < 0 ? s : n).totalDuration() / 100 : 1))
          : a < 0
          ? (t in i || (i[t] = o), i[t])
          : ((c = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
            l && n && (c = (c / 100) * (Bt(n) ? n[0] : n).totalDuration()),
            a > 1 ? r(e, t.substr(0, a - 1), n) + c : o + c))
      : t == null
      ? o
      : +t;
  },
  Bs = function (e, t, n) {
    var i = li(t[1]),
      s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
      o = t[s],
      a,
      c;
    if ((i && (o.duration = t[1]), (o.parent = n), e)) {
      for (a = o, c = n; c && !('immediateRender' in a); )
        (a = c.vars.defaults || {}), (c = Kt(c.vars.inherit) && c.parent);
      (o.immediateRender = Kt(a.immediateRender)),
        e < 2 ? (o.runBackwards = 1) : (o.startAt = t[s - 1]);
    }
    return new mt(t[0], o, t[s + 1]);
  },
  Fi = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  no = function (e, t, n) {
    return n < e ? e : n > t ? t : n;
  },
  Ft = function (e, t) {
    return !Tt(e) || !(t = sm.exec(e)) ? '' : t[1];
  },
  _m = function (e, t, n) {
    return Fi(n, function (i) {
      return no(e, t, i);
    });
  },
  Ic = [].slice,
  Zf = function (e, t) {
    return (
      e &&
      Gn(e) &&
      'length' in e &&
      ((!t && !e.length) || (e.length - 1 in e && Gn(e[0]))) &&
      !e.nodeType &&
      e !== mn
    );
  },
  vm = function (e, t, n) {
    return (
      n === void 0 && (n = []),
      e.forEach(function (i) {
        var s;
        return (Tt(i) && !t) || Zf(i, 1)
          ? (s = n).push.apply(s, Mn(i))
          : n.push(i);
      }) || n
    );
  },
  Mn = function (e, t, n) {
    return at && !t && at.selector
      ? at.selector(e)
      : Tt(e) && !n && (Cc || !rs())
      ? Ic.call((t || pl).querySelectorAll(e), 0)
      : Bt(e)
      ? vm(e, n)
      : Zf(e)
      ? Ic.call(e, 0)
      : e
      ? [e]
      : [];
  },
  Oc = function (e) {
    return (
      (e = Mn(e)[0] || ea('Invalid scope') || {}),
      function (t) {
        var n = e.current || e.nativeElement || e;
        return Mn(
          t,
          n.querySelectorAll
            ? n
            : n === e
            ? ea('Invalid scope') || pl.createElement('div')
            : e
        );
      }
    );
  },
  Jf = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  Qf = function (e) {
    if (ct(e)) return e;
    var t = Gn(e) ? e : { each: e },
      n = cr(t.ease),
      i = t.from || 0,
      s = parseFloat(t.base) || 0,
      o = {},
      a = i > 0 && i < 1,
      c = isNaN(i) || a,
      l = t.axis,
      h = i,
      f = i;
    return (
      Tt(i)
        ? (h = f = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !a && c && ((h = i[0]), (f = i[1])),
      function (u, p, _) {
        var g = (_ || t).length,
          d = o[g],
          m,
          y,
          v,
          x,
          S,
          b,
          T,
          C,
          M;
        if (!d) {
          if (((M = t.grid === 'auto' ? 0 : (t.grid || [1, xn])[1]), !M)) {
            for (
              T = -xn;
              T < (T = _[M++].getBoundingClientRect().left) && M < g;

            );
            M--;
          }
          for (
            d = o[g] = [],
              m = c ? Math.min(M, g) * h - 0.5 : i % M,
              y = M === xn ? 0 : c ? (g * f) / M - 0.5 : (i / M) | 0,
              T = 0,
              C = xn,
              b = 0;
            b < g;
            b++
          )
            (v = (b % M) - m),
              (x = y - ((b / M) | 0)),
              (d[b] = S = l ? Math.abs(l === 'y' ? x : v) : Of(v * v + x * x)),
              S > T && (T = S),
              S < C && (C = S);
          i === 'random' && Jf(d),
            (d.max = T - C),
            (d.min = C),
            (d.v = g =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (M > g
                    ? g - 1
                    : l
                    ? l === 'y'
                      ? g / M
                      : M
                    : Math.max(M, g / M)) ||
                0) * (i === 'edges' ? -1 : 1)),
            (d.b = g < 0 ? s - g : s),
            (d.u = Ft(t.amount || t.each) || 0),
            (n = n && g < 0 ? ld(n) : n);
        }
        return (
          (g = (d[u] - d.min) / d.max || 0),
          wt(d.b + (n ? n(g) : g) * d.v) + d.u
        );
      }
    );
  },
  Uc = function (e) {
    var t = Math.pow(10, ((e + '').split('.')[1] || '').length);
    return function (n) {
      var i = wt(Math.round(parseFloat(n) / e) * e * t);
      return (i - (i % 1)) / t + (li(n) ? 0 : Ft(n));
    };
  },
  ed = function (e, t) {
    var n = Bt(e),
      i,
      s;
    return (
      !n &&
        Gn(e) &&
        ((i = n = e.radius || xn),
        e.values
          ? ((e = Mn(e.values)), (s = !li(e[0])) && (i *= i))
          : (e = Uc(e.increment))),
      Fi(
        t,
        n
          ? ct(e)
            ? function (o) {
                return (s = e(o)), Math.abs(s - o) <= i ? s : o;
              }
            : function (o) {
                for (
                  var a = parseFloat(s ? o.x : o),
                    c = parseFloat(s ? o.y : 0),
                    l = xn,
                    h = 0,
                    f = e.length,
                    u,
                    p;
                  f--;

                )
                  s
                    ? ((u = e[f].x - a), (p = e[f].y - c), (u = u * u + p * p))
                    : (u = Math.abs(e[f] - a)),
                    u < l && ((l = u), (h = f));
                return (
                  (h = !i || l <= i ? e[h] : o),
                  s || h === o || li(o) ? h : h + Ft(o)
                );
              }
          : Uc(e)
      )
    );
  },
  td = function (e, t, n, i) {
    return Fi(Bt(e) ? !t : n === !0 ? !!(n = 0) : !i, function () {
      return Bt(e)
        ? e[~~(Math.random() * e.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + '').length - 2) : 1) &&
            Math.floor(
              Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) *
                n *
                i
            ) / i;
    });
  },
  ym = function () {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return function (i) {
      return t.reduce(function (s, o) {
        return o(s);
      }, i);
    };
  },
  xm = function (e, t) {
    return function (n) {
      return e(parseFloat(n)) + (t || Ft(n));
    };
  },
  Mm = function (e, t, n) {
    return id(e, t, 0, 1, n);
  },
  nd = function (e, t, n) {
    return Fi(n, function (i) {
      return e[~~t(i)];
    });
  },
  Sm = function r(e, t, n) {
    var i = t - e;
    return Bt(e)
      ? nd(e, r(0, e.length), t)
      : Fi(n, function (s) {
          return ((i + ((s - e) % i)) % i) + e;
        });
  },
  bm = function r(e, t, n) {
    var i = t - e,
      s = i * 2;
    return Bt(e)
      ? nd(e, r(0, e.length - 1), t)
      : Fi(n, function (o) {
          return (o = (s + ((o - e) % s)) % s || 0), e + (o > i ? s - o : o);
        });
  },
  qs = function (e) {
    for (var t = 0, n = '', i, s, o, a; ~(i = e.indexOf('random(', t)); )
      (o = e.indexOf(')', i)),
        (a = e.charAt(i + 7) === '['),
        (s = e.substr(i + 7, o - i - 7).match(a ? kf : Rc)),
        (n +=
          e.substr(t, i - t) + td(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5)),
        (t = o + 1);
    return n + e.substr(t, e.length - t);
  },
  id = function (e, t, n, i, s) {
    var o = t - e,
      a = i - n;
    return Fi(s, function (c) {
      return n + (((c - e) / o) * a || 0);
    });
  },
  Em = function r(e, t, n, i) {
    var s = isNaN(e + t)
      ? 0
      : function (p) {
          return (1 - p) * e + p * t;
        };
    if (!s) {
      var o = Tt(e),
        a = {},
        c,
        l,
        h,
        f,
        u;
      if ((n === !0 && (i = 1) && (n = null), o))
        (e = { p: e }), (t = { p: t });
      else if (Bt(e) && !Bt(t)) {
        for (h = [], f = e.length, u = f - 2, l = 1; l < f; l++)
          h.push(r(e[l - 1], e[l]));
        f--,
          (s = function (_) {
            _ *= f;
            var g = Math.min(u, ~~_);
            return h[g](_ - g);
          }),
          (n = t);
      } else i || (e = mr(Bt(e) ? [] : {}, e));
      if (!h) {
        for (c in t) yl.call(a, e, c, 'get', t[c]);
        s = function (_) {
          return bl(_, a) || (o ? e.p : e);
        };
      }
    }
    return Fi(n, s);
  },
  uh = function (e, t, n) {
    var i = e.labels,
      s = xn,
      o,
      a,
      c;
    for (o in i)
      (a = i[o] - t),
        a < 0 == !!n && a && s > (a = Math.abs(a)) && ((c = o), (s = a));
    return c;
  },
  Sn = function (e, t, n) {
    var i = e.vars,
      s = i[t],
      o = at,
      a = e._ctx,
      c,
      l,
      h;
    if (s)
      return (
        (c = i[t + 'Params']),
        (l = i.callbackScope || e),
        n && Li.length && ta(),
        a && (at = a),
        (h = c ? s.apply(l, c) : s.call(l)),
        (at = o),
        h
      );
  },
  Is = function (e) {
    return (
      Ui(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!kt),
      e.progress() < 1 && Sn(e, 'onInterrupt'),
      e
    );
  },
  qr,
  rd = [],
  sd = function (e) {
    if (dl() && e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        n = ct(e),
        i =
          t && !n && e.init
            ? function () {
                this._props = [];
              }
            : e,
        s = {
          init: Ws,
          render: bl,
          add: yl,
          kill: zm,
          modifier: Bm,
          rawVars: 0
        },
        o = { targetTest: 0, get: 0, getSetter: Sl, aliases: {}, register: 0 };
      if ((rs(), e !== i)) {
        if (an[t]) return;
        En(i, En(na(e, s), o)),
          mr(i.prototype, mr(s, na(e, o))),
          (an[(i.prop = t)] = i),
          e.targetTest && (Wo.push(i), (gl[t] = 1)),
          (t =
            (t === 'css' ? 'CSS' : t.charAt(0).toUpperCase() + t.substr(1)) +
            'Plugin');
      }
      Hf(t, i), e.register && e.register(Qt, i, Zt);
    } else e && rd.push(e);
  },
  $e = 255,
  Os = {
    aqua: [0, $e, $e],
    lime: [0, $e, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, $e],
    navy: [0, 0, 128],
    white: [$e, $e, $e],
    olive: [128, 128, 0],
    yellow: [$e, $e, 0],
    orange: [$e, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [$e, 0, 0],
    pink: [$e, 192, 203],
    cyan: [0, $e, $e],
    transparent: [$e, $e, $e, 0]
  },
  La = function (e, t, n) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (n - t) * e * 6
        : e < 0.5
        ? n
        : e * 3 < 2
        ? t + (n - t) * (2 / 3 - e) * 6
        : t) *
        $e +
        0.5) |
        0
    );
  },
  od = function (e, t, n) {
    var i = e ? (li(e) ? [e >> 16, (e >> 8) & $e, e & $e] : 0) : Os.black,
      s,
      o,
      a,
      c,
      l,
      h,
      f,
      u,
      p,
      _;
    if (!i) {
      if ((e.substr(-1) === ',' && (e = e.substr(0, e.length - 1)), Os[e]))
        i = Os[e];
      else if (e.charAt(0) === '#') {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (o = e.charAt(2)),
            (a = e.charAt(3)),
            (e =
              '#' +
              s +
              s +
              o +
              o +
              a +
              a +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ''))),
          e.length === 9)
        )
          return (
            (i = parseInt(e.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & $e, i & $e, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (i = [e >> 16, (e >> 8) & $e, e & $e]);
      } else if (e.substr(0, 3) === 'hsl') {
        if (((i = _ = e.match(Rc)), !t))
          (c = (+i[0] % 360) / 360),
            (l = +i[1] / 100),
            (h = +i[2] / 100),
            (o = h <= 0.5 ? h * (l + 1) : h + l - h * l),
            (s = h * 2 - o),
            i.length > 3 && (i[3] *= 1),
            (i[0] = La(c + 1 / 3, s, o)),
            (i[1] = La(c, s, o)),
            (i[2] = La(c - 1 / 3, s, o));
        else if (~e.indexOf('='))
          return (i = e.match(Nf)), n && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(Rc) || Os.transparent;
      i = i.map(Number);
    }
    return (
      t &&
        !_ &&
        ((s = i[0] / $e),
        (o = i[1] / $e),
        (a = i[2] / $e),
        (f = Math.max(s, o, a)),
        (u = Math.min(s, o, a)),
        (h = (f + u) / 2),
        f === u
          ? (c = l = 0)
          : ((p = f - u),
            (l = h > 0.5 ? p / (2 - f - u) : p / (f + u)),
            (c =
              f === s
                ? (o - a) / p + (o < a ? 6 : 0)
                : f === o
                ? (a - s) / p + 2
                : (s - o) / p + 4),
            (c *= 60)),
        (i[0] = ~~(c + 0.5)),
        (i[1] = ~~(l * 100 + 0.5)),
        (i[2] = ~~(h * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    );
  },
  ad = function (e) {
    var t = [],
      n = [],
      i = -1;
    return (
      e.split(Pi).forEach(function (s) {
        var o = s.match(Wr) || [];
        t.push.apply(t, o), n.push((i += o.length + 1));
      }),
      (t.c = n),
      t
    );
  },
  fh = function (e, t, n) {
    var i = '',
      s = (e + i).match(Pi),
      o = t ? 'hsla(' : 'rgba(',
      a = 0,
      c,
      l,
      h,
      f;
    if (!s) return e;
    if (
      ((s = s.map(function (u) {
        return (
          (u = od(u, t, 1)) &&
          o +
            (t ? u[0] + ',' + u[1] + '%,' + u[2] + '%,' + u[3] : u.join(',')) +
            ')'
        );
      })),
      n && ((h = ad(e)), (c = n.c), c.join(i) !== h.c.join(i)))
    )
      for (l = e.replace(Pi, '1').split(Wr), f = l.length - 1; a < f; a++)
        i +=
          l[a] +
          (~c.indexOf(a)
            ? s.shift() || o + '0,0,0,0)'
            : (h.length ? h : s.length ? s : n).shift());
    if (!l)
      for (l = e.split(Pi), f = l.length - 1; a < f; a++) i += l[a] + s[a];
    return i + l[f];
  },
  Pi = (function () {
    var r =
        '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b',
      e;
    for (e in Os) r += '|' + e + '\\b';
    return new RegExp(r + ')', 'gi');
  })(),
  Tm = /hsl[a]?\(/,
  cd = function (e) {
    var t = e.join(' '),
      n;
    if (((Pi.lastIndex = 0), Pi.test(t)))
      return (
        (n = Tm.test(t)),
        (e[1] = fh(e[1], n)),
        (e[0] = fh(e[0], n, ad(e[1]))),
        !0
      );
  },
  Xs,
  cn = (function () {
    var r = Date.now,
      e = 500,
      t = 33,
      n = r(),
      i = n,
      s = 1e3 / 240,
      o = s,
      a = [],
      c,
      l,
      h,
      f,
      u,
      p,
      _ = function g(d) {
        var m = r() - i,
          y = d === !0,
          v,
          x,
          S,
          b;
        if (
          (m > e && (n += m - t),
          (i += m),
          (S = i - n),
          (v = S - o),
          (v > 0 || y) &&
            ((b = ++f.frame),
            (u = S - f.time * 1e3),
            (f.time = S = S / 1e3),
            (o += v + (v >= s ? 4 : s - v)),
            (x = 1)),
          y || (c = l(g)),
          x)
        )
          for (p = 0; p < a.length; p++) a[p](S, u, b, d);
      };
    return (
      (f = {
        time: 0,
        frame: 0,
        tick: function () {
          _(!0);
        },
        deltaRatio: function (d) {
          return u / (1e3 / (d || 60));
        },
        wake: function () {
          Bf &&
            (!Cc &&
              dl() &&
              ((mn = Cc = window),
              (pl = mn.document || {}),
              (hn.gsap = Qt),
              (mn.gsapVersions || (mn.gsapVersions = [])).push(Qt.version),
              zf(Qo || mn.GreenSockGlobals || (!mn.gsap && mn) || {}),
              (h = mn.requestAnimationFrame),
              rd.forEach(sd)),
            c && f.sleep(),
            (l =
              h ||
              function (d) {
                return setTimeout(d, (o - f.time * 1e3 + 1) | 0);
              }),
            (Xs = 1),
            _(2));
        },
        sleep: function () {
          (h ? mn.cancelAnimationFrame : clearTimeout)(c), (Xs = 0), (l = Ws);
        },
        lagSmoothing: function (d, m) {
          (e = d || 1 / 0), (t = Math.min(m || 33, e));
        },
        fps: function (d) {
          (s = 1e3 / (d || 240)), (o = f.time * 1e3 + s);
        },
        add: function (d, m, y) {
          var v = m
            ? function (x, S, b, T) {
                d(x, S, b, T), f.remove(v);
              }
            : d;
          return f.remove(d), a[y ? 'unshift' : 'push'](v), rs(), v;
        },
        remove: function (d, m) {
          ~(m = a.indexOf(d)) && a.splice(m, 1) && p >= m && p--;
        },
        _listeners: a
      }),
      f
    );
  })(),
  rs = function () {
    return !Xs && cn.wake();
  },
  Ge = {},
  Am = /^[\d.\-M][\d.\-,\s]/,
  wm = /["']/g,
  Rm = function (e) {
    for (
      var t = {},
        n = e.substr(1, e.length - 3).split(':'),
        i = n[0],
        s = 1,
        o = n.length,
        a,
        c,
        l;
      s < o;
      s++
    )
      (c = n[s]),
        (a = s !== o - 1 ? c.lastIndexOf(',') : c.length),
        (l = c.substr(0, a)),
        (t[i] = isNaN(l) ? l.replace(wm, '').trim() : +l),
        (i = c.substr(a + 1).trim());
    return t;
  },
  Cm = function (e) {
    var t = e.indexOf('(') + 1,
      n = e.indexOf(')'),
      i = e.indexOf('(', t);
    return e.substring(t, ~i && i < n ? e.indexOf(')', n + 1) : n);
  },
  Lm = function (e) {
    var t = (e + '').split('('),
      n = Ge[t[0]];
    return n && t.length > 1 && n.config
      ? n.config.apply(
          null,
          ~e.indexOf('{') ? [Rm(t[1])] : Cm(e).split(',').map(qf)
        )
      : Ge._CE && Am.test(e)
      ? Ge._CE('', e)
      : n;
  },
  ld = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  hd = function r(e, t) {
    for (var n = e._first, i; n; )
      n instanceof Yt
        ? r(n, t)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== t &&
          (n.timeline
            ? r(n.timeline, t)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = t))),
        (n = n._next);
  },
  cr = function (e, t) {
    return (e && (ct(e) ? e : Ge[e] || Lm(e))) || t;
  },
  xr = function (e, t, n, i) {
    n === void 0 &&
      (n = function (c) {
        return 1 - t(1 - c);
      }),
      i === void 0 &&
        (i = function (c) {
          return c < 0.5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2;
        });
    var s = { easeIn: t, easeOut: n, easeInOut: i },
      o;
    return (
      $t(e, function (a) {
        (Ge[a] = hn[a] = s), (Ge[(o = a.toLowerCase())] = n);
        for (var c in s)
          Ge[
            o + (c === 'easeIn' ? '.in' : c === 'easeOut' ? '.out' : '.inOut')
          ] = Ge[a + '.' + c] = s[c];
      }),
      s
    );
  },
  ud = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  Pa = function r(e, t, n) {
    var i = t >= 1 ? t : 1,
      s = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      o = (s / wc) * (Math.asin(1 / i) || 0),
      a = function (h) {
        return h === 1 ? 1 : i * Math.pow(2, -10 * h) * rm((h - o) * s) + 1;
      },
      c =
        e === 'out'
          ? a
          : e === 'in'
          ? function (l) {
              return 1 - a(1 - l);
            }
          : ud(a);
    return (
      (s = wc / s),
      (c.config = function (l, h) {
        return r(e, l, h);
      }),
      c
    );
  },
  Da = function r(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function (o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
      },
      i =
        e === 'out'
          ? n
          : e === 'in'
          ? function (s) {
              return 1 - n(1 - s);
            }
          : ud(n);
    return (
      (i.config = function (s) {
        return r(e, s);
      }),
      i
    );
  };
$t('Linear,Quad,Cubic,Quart,Quint,Strong', function (r, e) {
  var t = e < 5 ? e + 1 : e;
  xr(
    r + ',Power' + (t - 1),
    e
      ? function (n) {
          return Math.pow(n, t);
        }
      : function (n) {
          return n;
        },
    function (n) {
      return 1 - Math.pow(1 - n, t);
    },
    function (n) {
      return n < 0.5
        ? Math.pow(n * 2, t) / 2
        : 1 - Math.pow((1 - n) * 2, t) / 2;
    }
  );
});
Ge.Linear.easeNone = Ge.none = Ge.Linear.easeIn;
xr('Elastic', Pa('in'), Pa('out'), Pa());
(function (r, e) {
  var t = 1 / e,
    n = 2 * t,
    i = 2.5 * t,
    s = function (a) {
      return a < t
        ? r * a * a
        : a < n
        ? r * Math.pow(a - 1.5 / e, 2) + 0.75
        : a < i
        ? r * (a -= 2.25 / e) * a + 0.9375
        : r * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  xr(
    'Bounce',
    function (o) {
      return 1 - s(1 - o);
    },
    s
  );
})(7.5625, 2.75);
xr('Expo', function (r) {
  return r ? Math.pow(2, 10 * (r - 1)) : 0;
});
xr('Circ', function (r) {
  return -(Of(1 - r * r) - 1);
});
xr('Sine', function (r) {
  return r === 1 ? 1 : -im(r * tm) + 1;
});
xr('Back', Da('in'), Da('out'), Da());
Ge.SteppedEase =
  Ge.steps =
  hn.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e,
          i = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          o = 1 - Ze;
        return function (a) {
          return (((i * no(0, o, a)) | 0) + s) * n;
        };
      }
    };
ts.ease = Ge['quad.out'];
$t(
  'onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt',
  function (r) {
    return (_l += r + ',' + r + 'Params,');
  }
);
var fd = function (e, t) {
    (this.id = nm++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : Vf),
      (this.set = t ? t.getSetter : Sl);
  },
  js = (function () {
    function r(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        is(this, +t.duration, 1, 1),
        (this.data = t.data),
        at && ((this._ctx = at), at.data.push(this)),
        Xs || cn.wake();
    }
    var e = r.prototype;
    return (
      (e.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay;
      }),
      (e.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            is(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (n, i) {
        if ((rs(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (ma(this, n), !s._dp || s.parent || Yf(s, this); s && s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            Un(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === Ze) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), Wf(this, n, i)),
          this
        );
      }),
      (e.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + lh(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (e.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                lh(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (n, i) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * s, i)
          : this._repeat
          ? ns(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (n) {
        if (!arguments.length) return this._rts === -Ze ? 0 : this._rts;
        if (this._rts === n) return this;
        var i =
          this.parent && this._ts ? ia(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -Ze ? 0 : this._rts),
          this.totalTime(no(-Math.abs(this._delay), this._tDur, i), !0),
          pa(this),
          um(this)
        );
      }),
      (e.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (rs(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== Ze &&
                      (this._tTime -= Ze)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (n) {
        if (arguments.length) {
          this._start = n;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && Un(i, this, n - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (n) {
        return (
          this._start +
          (Kt(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (n) {
        var i = this.parent || this._dp;
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? ia(i.rawTime(n), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (n) {
        n === void 0 && (n = am);
        var i = kt;
        return (
          (kt = n),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(n),
            this.totalTime(-0.01, n.suppressEvents)),
          this.data !== 'nested' && n.kill !== !1 && this.kill(),
          (kt = i),
          this
        );
      }),
      (e.globalTime = function (n) {
        for (var i = this, s = arguments.length ? n : i.rawTime(); i; )
          (s = i._start + s / (i._ts || 1)), (i = i._dp);
        return !this.parent && this._sat
          ? this._sat.vars.immediateRender
            ? -1 / 0
            : this._sat.globalTime(n)
          : s;
      }),
      (e.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), hh(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = n), hh(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
      }),
      (e.seek = function (n, i) {
        return this.totalTime(pn(this, n), Kt(i));
      }),
      (e.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, Kt(i));
      }),
      (e.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -Ze : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -Ze), this;
      }),
      (e.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          s;
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (s = n.rawTime(!0)) >= i &&
            s < this.endTime(!0) - Ze)
        );
      }),
      (e.eventCallback = function (n, i, s) {
        var o = this.vars;
        return arguments.length > 1
          ? (i
              ? ((o[n] = i),
                s && (o[n + 'Params'] = s),
                n === 'onUpdate' && (this._onUpdate = i))
              : delete o[n],
            this)
          : o[n];
      }),
      (e.then = function (n) {
        var i = this;
        return new Promise(function (s) {
          var o = ct(n) ? n : Xf,
            a = function () {
              var l = i.then;
              (i.then = null),
                ct(o) && (o = o(i)) && (o.then || o === i) && (i.then = l),
                s(o),
                (i.then = l);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? a()
            : (i._prom = a);
        });
      }),
      (e.kill = function () {
        Is(this);
      }),
      r
    );
  })();
En(js.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Ze,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Yt = (function (r) {
  If(e, r);
  function e(n, i) {
    var s;
    return (
      n === void 0 && (n = {}),
      (s = r.call(this, n) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!n.smoothChildTiming),
      (s.autoRemoveChildren = !!n.autoRemoveChildren),
      (s._sort = Kt(n.sortChildren)),
      it && Un(n.parent || it, ii(s), i),
      n.reversed && s.reverse(),
      n.paused && s.paused(!0),
      n.scrollTrigger && Kf(ii(s), n.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (i, s, o) {
      return Bs(0, arguments, this), this;
    }),
    (t.from = function (i, s, o) {
      return Bs(1, arguments, this), this;
    }),
    (t.fromTo = function (i, s, o, a) {
      return Bs(2, arguments, this), this;
    }),
    (t.set = function (i, s, o) {
      return (
        (s.duration = 0),
        (s.parent = this),
        ks(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new mt(i, s, pn(this, o), 1),
        this
      );
    }),
    (t.call = function (i, s, o) {
      return Un(this, mt.delayedCall(0, i, s), o);
    }),
    (t.staggerTo = function (i, s, o, a, c, l, h) {
      return (
        (o.duration = s),
        (o.stagger = o.stagger || a),
        (o.onComplete = l),
        (o.onCompleteParams = h),
        (o.parent = this),
        new mt(i, o, pn(this, c)),
        this
      );
    }),
    (t.staggerFrom = function (i, s, o, a, c, l, h) {
      return (
        (o.runBackwards = 1),
        (ks(o).immediateRender = Kt(o.immediateRender)),
        this.staggerTo(i, s, o, a, c, l, h)
      );
    }),
    (t.staggerFromTo = function (i, s, o, a, c, l, h, f) {
      return (
        (a.startAt = o),
        (ks(a).immediateRender = Kt(a.immediateRender)),
        this.staggerTo(i, s, a, c, l, h, f)
      );
    }),
    (t.render = function (i, s, o) {
      var a = this._time,
        c = this._dirty ? this.totalDuration() : this._tDur,
        l = this._dur,
        h = i <= 0 ? 0 : wt(i),
        f = this._zTime < 0 != i < 0 && (this._initted || !l),
        u,
        p,
        _,
        g,
        d,
        m,
        y,
        v,
        x,
        S,
        b,
        T;
      if (
        (this !== it && h > c && i >= 0 && (h = c), h !== this._tTime || o || f)
      ) {
        if (
          (a !== this._time &&
            l &&
            ((h += this._time - a), (i += this._time - a)),
          (u = h),
          (x = this._start),
          (v = this._ts),
          (m = !v),
          f && (l || (a = this._zTime), (i || !s) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((b = this._yoyo),
            (d = l + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(d * 100 + i, s, o);
          if (
            ((u = wt(h % d)),
            h === c
              ? ((g = this._repeat), (u = l))
              : ((g = ~~(h / d)),
                g && g === h / d && ((u = l), g--),
                u > l && (u = l)),
            (S = ns(this._tTime, d)),
            !a &&
              this._tTime &&
              S !== g &&
              this._tTime - S * d - this._dur <= 0 &&
              (S = g),
            b && g & 1 && ((u = l - u), (T = 1)),
            g !== S && !this._lock)
          ) {
            var C = b && S & 1,
              M = C === (b && g & 1);
            if (
              (g < S && (C = !C),
              (a = C ? 0 : h % l ? l : h),
              (this._lock = 1),
              (this.render(a || (T ? 0 : wt(g * d)), s, !l)._lock = 0),
              (this._tTime = h),
              !s && this.parent && Sn(this, 'onRepeat'),
              this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1),
              (a && a !== this._time) ||
                m !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((l = this._dur),
              (c = this._tDur),
              M &&
                ((this._lock = 2),
                (a = C ? l : -1e-4),
                this.render(a, !0),
                this.vars.repeatRefresh && !T && this.invalidate()),
              (this._lock = 0),
              !this._ts && !m)
            )
              return this;
            hd(this, T);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = mm(this, wt(a), wt(u))), y && (h -= u - (u = y._start))),
          (this._tTime = h),
          (this._time = u),
          (this._act = !v),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (a = 0)),
          !a && u && !s && !g && (Sn(this, 'onStart'), this._tTime !== h))
        )
          return this;
        if (u >= a && i >= 0)
          for (p = this._first; p; ) {
            if (
              ((_ = p._next), (p._act || u >= p._start) && p._ts && y !== p)
            ) {
              if (p.parent !== this) return this.render(i, s, o);
              if (
                (p.render(
                  p._ts > 0
                    ? (u - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (u - p._start) * p._ts,
                  s,
                  o
                ),
                u !== this._time || (!this._ts && !m))
              ) {
                (y = 0), _ && (h += this._zTime = -Ze);
                break;
              }
            }
            p = _;
          }
        else {
          p = this._last;
          for (var A = i < 0 ? i : u; p; ) {
            if (((_ = p._prev), (p._act || A <= p._end) && p._ts && y !== p)) {
              if (p.parent !== this) return this.render(i, s, o);
              if (
                (p.render(
                  p._ts > 0
                    ? (A - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (A - p._start) * p._ts,
                  s,
                  o || (kt && (p._initted || p._startAt))
                ),
                u !== this._time || (!this._ts && !m))
              ) {
                (y = 0), _ && (h += this._zTime = A ? -Ze : Ze);
                break;
              }
            }
            p = _;
          }
        }
        if (
          y &&
          !s &&
          (this.pause(),
          (y.render(u >= a ? 0 : -Ze)._zTime = u >= a ? 1 : -1),
          this._ts)
        )
          return (this._start = x), pa(this), this.render(i, s, o);
        this._onUpdate && !s && Sn(this, 'onUpdate', !0),
          ((h === c && this._tTime >= this.totalDuration()) || (!h && a)) &&
            (x === this._start || Math.abs(v) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !l) &&
                ((h === c && this._ts > 0) || (!h && this._ts < 0)) &&
                Ui(this, 1),
              !s &&
                !(i < 0 && !a) &&
                (h || a || !c) &&
                (Sn(
                  this,
                  h === c && i >= 0 ? 'onComplete' : 'onReverseComplete',
                  !0
                ),
                this._prom &&
                  !(h < c && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (i, s) {
      var o = this;
      if ((li(s) || (s = pn(this, s, i)), !(i instanceof js))) {
        if (Bt(i))
          return (
            i.forEach(function (a) {
              return o.add(a, s);
            }),
            this
          );
        if (Tt(i)) return this.addLabel(i, s);
        if (ct(i)) i = mt.delayedCall(0, i);
        else return this;
      }
      return this !== i ? Un(this, i, s) : this;
    }),
    (t.getChildren = function (i, s, o, a) {
      i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -xn);
      for (var c = [], l = this._first; l; )
        l._start >= a &&
          (l instanceof mt
            ? s && c.push(l)
            : (o && c.push(l), i && c.push.apply(c, l.getChildren(!0, s, o)))),
          (l = l._next);
      return c;
    }),
    (t.getById = function (i) {
      for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
        if (s[o].vars.id === i) return s[o];
    }),
    (t.remove = function (i) {
      return Tt(i)
        ? this.removeLabel(i)
        : ct(i)
        ? this.killTweensOf(i)
        : (da(this, i),
          i === this._recent && (this._recent = this._last),
          ar(this));
    }),
    (t.totalTime = function (i, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = wt(
              cn.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          r.prototype.totalTime.call(this, i, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (i, s) {
      return (this.labels[i] = pn(this, s)), this;
    }),
    (t.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (t.addPause = function (i, s, o) {
      var a = mt.delayedCall(0, s || Ws, o);
      return (
        (a.data = 'isPause'), (this._hasPause = 1), Un(this, a, pn(this, i))
      );
    }),
    (t.removePause = function (i) {
      var s = this._first;
      for (i = pn(this, i); s; )
        s._start === i && s.data === 'isPause' && Ui(s), (s = s._next);
    }),
    (t.killTweensOf = function (i, s, o) {
      for (var a = this.getTweensOf(i, o), c = a.length; c--; )
        Ai !== a[c] && a[c].kill(i, s);
      return this;
    }),
    (t.getTweensOf = function (i, s) {
      for (var o = [], a = Mn(i), c = this._first, l = li(s), h; c; )
        c instanceof mt
          ? cm(c._targets, a) &&
            (l
              ? (!Ai || (c._initted && c._ts)) &&
                c.globalTime(0) <= s &&
                c.globalTime(c.totalDuration()) > s
              : !s || c.isActive()) &&
            o.push(c)
          : (h = c.getTweensOf(a, s)).length && o.push.apply(o, h),
          (c = c._next);
      return o;
    }),
    (t.tweenTo = function (i, s) {
      s = s || {};
      var o = this,
        a = pn(o, i),
        c = s,
        l = c.startAt,
        h = c.onStart,
        f = c.onStartParams,
        u = c.immediateRender,
        p,
        _ = mt.to(
          o,
          En(
            {
              ease: s.ease || 'none',
              lazy: !1,
              immediateRender: !1,
              time: a,
              overwrite: 'auto',
              duration:
                s.duration ||
                Math.abs(
                  (a - (l && 'time' in l ? l.time : o._time)) / o.timeScale()
                ) ||
                Ze,
              onStart: function () {
                if ((o.pause(), !p)) {
                  var d =
                    s.duration ||
                    Math.abs(
                      (a - (l && 'time' in l ? l.time : o._time)) /
                        o.timeScale()
                    );
                  _._dur !== d && is(_, d, 0, 1).render(_._time, !0, !0),
                    (p = 1);
                }
                h && h.apply(_, f || []);
              }
            },
            s
          )
        );
      return u ? _.render(0) : _;
    }),
    (t.tweenFromTo = function (i, s, o) {
      return this.tweenTo(s, En({ startAt: { time: pn(this, i) } }, o));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (i) {
      return i === void 0 && (i = this._time), uh(this, pn(this, i));
    }),
    (t.previousLabel = function (i) {
      return i === void 0 && (i = this._time), uh(this, pn(this, i), 1);
    }),
    (t.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + Ze);
    }),
    (t.shiftChildren = function (i, s, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, c = this.labels, l; a; )
        a._start >= o && ((a._start += i), (a._end += i)), (a = a._next);
      if (s) for (l in c) c[l] >= o && (c[l] += i);
      return ar(this);
    }),
    (t.invalidate = function (i) {
      var s = this._first;
      for (this._lock = 0; s; ) s.invalidate(i), (s = s._next);
      return r.prototype.invalidate.call(this, i);
    }),
    (t.clear = function (i) {
      i === void 0 && (i = !0);
      for (var s = this._first, o; s; ) (o = s._next), this.remove(s), (s = o);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        ar(this)
      );
    }),
    (t.totalDuration = function (i) {
      var s = 0,
        o = this,
        a = o._last,
        c = xn,
        l,
        h,
        f;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -i : i)
        );
      if (o._dirty) {
        for (f = o.parent; a; )
          (l = a._prev),
            a._dirty && a.totalDuration(),
            (h = a._start),
            h > c && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (Un(o, a, h - a._delay, 1)._lock = 0))
              : (c = h),
            h < 0 &&
              a._ts &&
              ((s -= h),
              ((!f && !o._dp) || (f && f.smoothChildTiming)) &&
                ((o._start += h / o._ts), (o._time -= h), (o._tTime -= h)),
              o.shiftChildren(-h, !1, -1 / 0),
              (c = 0)),
            a._end > s && a._ts && (s = a._end),
            (a = l);
        is(o, o === it && o._time > s ? o._time : s, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (e.updateRoot = function (i) {
      if ((it._ts && (Wf(it, ia(i, it)), (Gf = cn.frame)), cn.frame >= ah)) {
        ah += ln.autoSleep || 120;
        var s = it._first;
        if ((!s || !s._ts) && ln.autoSleep && cn._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || cn.sleep();
        }
      }
    }),
    e
  );
})(js);
En(Yt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var Pm = function (e, t, n, i, s, o, a) {
    var c = new Zt(this._pt, e, t, 0, 1, vd, null, s),
      l = 0,
      h = 0,
      f,
      u,
      p,
      _,
      g,
      d,
      m,
      y;
    for (
      c.b = n,
        c.e = i,
        n += '',
        i += '',
        (m = ~i.indexOf('random(')) && (i = qs(i)),
        o && ((y = [n, i]), o(y, e, t), (n = y[0]), (i = y[1])),
        u = n.match(Ra) || [];
      (f = Ra.exec(i));

    )
      (_ = f[0]),
        (g = i.substring(l, f.index)),
        p ? (p = (p + 1) % 5) : g.substr(-5) === 'rgba(' && (p = 1),
        _ !== u[h++] &&
          ((d = parseFloat(u[h - 1]) || 0),
          (c._pt = {
            _next: c._pt,
            p: g || h === 1 ? g : ',',
            s: d,
            c: _.charAt(1) === '=' ? Yr(d, _) - d : parseFloat(_) - d,
            m: p && p < 4 ? Math.round : 0
          }),
          (l = Ra.lastIndex));
    return (
      (c.c = l < i.length ? i.substring(l, i.length) : ''),
      (c.fp = a),
      (Ff.test(i) || m) && (c.e = 0),
      (this._pt = c),
      c
    );
  },
  yl = function (e, t, n, i, s, o, a, c, l, h) {
    ct(i) && (i = i(s || 0, e, o));
    var f = e[t],
      u =
        n !== 'get'
          ? n
          : ct(f)
          ? l
            ? e[
                t.indexOf('set') || !ct(e['get' + t.substr(3)])
                  ? t
                  : 'get' + t.substr(3)
              ](l)
            : e[t]()
          : f,
      p = ct(f) ? (l ? Nm : gd) : Ml,
      _;
    if (
      (Tt(i) &&
        (~i.indexOf('random(') && (i = qs(i)),
        i.charAt(1) === '=' &&
          ((_ = Yr(u, i) + (Ft(u) || 0)), (_ || _ === 0) && (i = _))),
      !h || u !== i || Nc)
    )
      return !isNaN(u * i) && i !== ''
        ? ((_ = new Zt(
            this._pt,
            e,
            t,
            +u || 0,
            i - (u || 0),
            typeof f == 'boolean' ? km : _d,
            0,
            p
          )),
          l && (_.fp = l),
          a && _.modifier(a, this, e),
          (this._pt = _))
        : (!f && !(t in e) && ml(t, i),
          Pm.call(this, e, t, u, i, p, c || ln.stringFilter, l));
  },
  Dm = function (e, t, n, i, s) {
    if (
      (ct(e) && (e = zs(e, s, t, n, i)),
      !Gn(e) || (e.style && e.nodeType) || Bt(e) || Uf(e))
    )
      return Tt(e) ? zs(e, s, t, n, i) : e;
    var o = {},
      a;
    for (a in e) o[a] = zs(e[a], s, t, n, i);
    return o;
  },
  dd = function (e, t, n, i, s, o) {
    var a, c, l, h;
    if (
      an[e] &&
      (a = new an[e]()).init(
        s,
        a.rawVars ? t[e] : Dm(t[e], i, s, o, n),
        n,
        i,
        o
      ) !== !1 &&
      ((n._pt = c = new Zt(n._pt, s, e, 0, 1, a.render, a, 0, a.priority)),
      n !== qr)
    )
      for (l = n._ptLookup[n._targets.indexOf(s)], h = a._props.length; h--; )
        l[a._props[h]] = c;
    return a;
  },
  Ai,
  Nc,
  xl = function r(e, t, n) {
    var i = e.vars,
      s = i.ease,
      o = i.startAt,
      a = i.immediateRender,
      c = i.lazy,
      l = i.onUpdate,
      h = i.onUpdateParams,
      f = i.callbackScope,
      u = i.runBackwards,
      p = i.yoyoEase,
      _ = i.keyframes,
      g = i.autoRevert,
      d = e._dur,
      m = e._startAt,
      y = e._targets,
      v = e.parent,
      x = v && v.data === 'nested' ? v.vars.targets : y,
      S = e._overwrite === 'auto' && !ul,
      b = e.timeline,
      T,
      C,
      M,
      A,
      X,
      Y,
      D,
      F,
      N,
      K,
      z,
      j,
      J;
    if (
      (b && (!_ || !s) && (s = 'none'),
      (e._ease = cr(s, ts.ease)),
      (e._yEase = p ? ld(cr(p === !0 ? s : p, ts.ease)) : 0),
      p &&
        e._yoyo &&
        !e._repeat &&
        ((p = e._yEase), (e._yEase = e._ease), (e._ease = p)),
      (e._from = !b && !!i.runBackwards),
      !b || (_ && !i.stagger))
    ) {
      if (
        ((F = y[0] ? or(y[0]).harness : 0),
        (j = F && i[F.prop]),
        (T = na(i, gl)),
        m &&
          (m._zTime < 0 && m.progress(1),
          t < 0 && u && a && !g ? m.render(-1, !0) : m.revert(u && d ? Vo : om),
          (m._lazy = 0)),
        o)
      ) {
        if (
          (Ui(
            (e._startAt = mt.set(
              y,
              En(
                {
                  data: 'isStart',
                  overwrite: !1,
                  parent: v,
                  immediateRender: !0,
                  lazy: !m && Kt(c),
                  startAt: null,
                  delay: 0,
                  onUpdate: l,
                  onUpdateParams: h,
                  callbackScope: f,
                  stagger: 0
                },
                o
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (kt || (!a && !g)) && e._startAt.revert(Vo),
          a && d && t <= 0 && n <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (u && d && !m) {
        if (
          (t && (a = !1),
          (M = En(
            {
              overwrite: !1,
              data: 'isFromStart',
              lazy: a && !m && Kt(c),
              immediateRender: a,
              stagger: 0,
              parent: v
            },
            T
          )),
          j && (M[F.prop] = j),
          Ui((e._startAt = mt.set(y, M))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (kt ? e._startAt.revert(Vo) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !a)
        )
          r(e._startAt, Ze, Ze);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, c = (d && Kt(c)) || (c && !d), C = 0;
        C < y.length;
        C++
      ) {
        if (
          ((X = y[C]),
          (D = X._gsap || vl(y)[C]._gsap),
          (e._ptLookup[C] = K = {}),
          Lc[D.id] && Li.length && ta(),
          (z = x === y ? C : x.indexOf(X)),
          F &&
            (N = new F()).init(X, j || T, e, z, x) !== !1 &&
            ((e._pt = A =
              new Zt(e._pt, X, N.name, 0, 1, N.render, N, 0, N.priority)),
            N._props.forEach(function ($) {
              K[$] = A;
            }),
            N.priority && (Y = 1)),
          !F || j)
        )
          for (M in T)
            an[M] && (N = dd(M, T, e, z, X, x))
              ? N.priority && (Y = 1)
              : (K[M] = A =
                  yl.call(e, X, M, 'get', T[M], z, x, 0, i.stringFilter));
        e._op && e._op[C] && e.kill(X, e._op[C]),
          S &&
            e._pt &&
            ((Ai = e),
            it.killTweensOf(X, K, e.globalTime(t)),
            (J = !e.parent),
            (Ai = 0)),
          e._pt && c && (Lc[D.id] = 1);
      }
      Y && yd(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = l),
      (e._initted = (!e._op || e._pt) && !J),
      _ && t <= 0 && b.render(xn, !0, !0);
  },
  Im = function (e, t, n, i, s, o, a) {
    var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      l,
      h,
      f,
      u;
    if (!c)
      for (
        c = e._ptCache[t] = [], f = e._ptLookup, u = e._targets.length;
        u--;

      ) {
        if (((l = f[u][t]), l && l.d && l.d._pt))
          for (l = l.d._pt; l && l.p !== t && l.fp !== t; ) l = l._next;
        if (!l) return (Nc = 1), (e.vars[t] = '+=0'), xl(e, a), (Nc = 0), 1;
        c.push(l);
      }
    for (u = c.length; u--; )
      (h = c[u]),
        (l = h._pt || h),
        (l.s = (i || i === 0) && !s ? i : l.s + (i || 0) + o * l.c),
        (l.c = n - l.s),
        h.e && (h.e = ht(n) + Ft(h.e)),
        h.b && (h.b = l.s + Ft(h.b));
  },
  Om = function (e, t) {
    var n = e[0] ? or(e[0]).harness : 0,
      i = n && n.aliases,
      s,
      o,
      a,
      c;
    if (!i) return t;
    s = mr({}, t);
    for (o in i)
      if (o in s) for (c = i[o].split(','), a = c.length; a--; ) s[c[a]] = s[o];
    return s;
  },
  Um = function (e, t, n, i) {
    var s = t.ease || i || 'power1.inOut',
      o,
      a;
    if (Bt(t))
      (a = n[e] || (n[e] = [])),
        t.forEach(function (c, l) {
          return a.push({ t: (l / (t.length - 1)) * 100, v: c, e: s });
        });
    else
      for (o in t)
        (a = n[o] || (n[o] = [])),
          o === 'ease' || a.push({ t: parseFloat(e), v: t[o], e: s });
  },
  zs = function (e, t, n, i, s) {
    return ct(e)
      ? e.call(t, n, i, s)
      : Tt(e) && ~e.indexOf('random(')
      ? qs(e)
      : e;
  },
  pd = _l + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
  md = {};
$t(pd + ',id,stagger,delay,duration,paused,scrollTrigger', function (r) {
  return (md[r] = 1);
});
var mt = (function (r) {
  If(e, r);
  function e(n, i, s, o) {
    var a;
    typeof i == 'number' && ((s.duration = i), (i = s), (s = null)),
      (a = r.call(this, o ? i : ks(i)) || this);
    var c = a.vars,
      l = c.duration,
      h = c.delay,
      f = c.immediateRender,
      u = c.stagger,
      p = c.overwrite,
      _ = c.keyframes,
      g = c.defaults,
      d = c.scrollTrigger,
      m = c.yoyoEase,
      y = i.parent || it,
      v = (Bt(n) || Uf(n) ? li(n[0]) : 'length' in i) ? [n] : Mn(n),
      x,
      S,
      b,
      T,
      C,
      M,
      A,
      X;
    if (
      ((a._targets = v.length
        ? vl(v)
        : ea(
            'GSAP target ' + n + ' not found. https://greensock.com',
            !ln.nullTargetWarn
          ) || []),
      (a._ptLookup = []),
      (a._overwrite = p),
      _ || u || ao(l) || ao(h))
    ) {
      if (
        ((i = a.vars),
        (x = a.timeline =
          new Yt({
            data: 'nested',
            defaults: g || {},
            targets: y && y.data === 'nested' ? y.vars.targets : v
          })),
        x.kill(),
        (x.parent = x._dp = ii(a)),
        (x._start = 0),
        u || ao(l) || ao(h))
      ) {
        if (((T = v.length), (A = u && Qf(u)), Gn(u)))
          for (C in u) ~pd.indexOf(C) && (X || (X = {}), (X[C] = u[C]));
        for (S = 0; S < T; S++)
          (b = na(i, md)),
            (b.stagger = 0),
            m && (b.yoyoEase = m),
            X && mr(b, X),
            (M = v[S]),
            (b.duration = +zs(l, ii(a), S, M, v)),
            (b.delay = (+zs(h, ii(a), S, M, v) || 0) - a._delay),
            !u &&
              T === 1 &&
              b.delay &&
              ((a._delay = h = b.delay), (a._start += h), (b.delay = 0)),
            x.to(M, b, A ? A(S, M, v) : 0),
            (x._ease = Ge.none);
        x.duration() ? (l = h = 0) : (a.timeline = 0);
      } else if (_) {
        ks(En(x.vars.defaults, { ease: 'none' })),
          (x._ease = cr(_.ease || i.ease || 'none'));
        var Y = 0,
          D,
          F,
          N;
        if (Bt(_))
          _.forEach(function (K) {
            return x.to(v, K, '>');
          }),
            x.duration();
        else {
          b = {};
          for (C in _)
            C === 'ease' || C === 'easeEach' || Um(C, _[C], b, _.easeEach);
          for (C in b)
            for (
              D = b[C].sort(function (K, z) {
                return K.t - z.t;
              }),
                Y = 0,
                S = 0;
              S < D.length;
              S++
            )
              (F = D[S]),
                (N = {
                  ease: F.e,
                  duration: ((F.t - (S ? D[S - 1].t : 0)) / 100) * l
                }),
                (N[C] = F.v),
                x.to(v, N, Y),
                (Y += N.duration);
          x.duration() < l && x.to({}, { duration: l - x.duration() });
        }
      }
      l || a.duration((l = x.duration()));
    } else a.timeline = 0;
    return (
      p === !0 && !ul && ((Ai = ii(a)), it.killTweensOf(v), (Ai = 0)),
      Un(y, ii(a), s),
      i.reversed && a.reverse(),
      i.paused && a.paused(!0),
      (f ||
        (!l &&
          !_ &&
          a._start === wt(y._time) &&
          Kt(f) &&
          fm(ii(a)) &&
          y.data !== 'nested')) &&
        ((a._tTime = -Ze), a.render(Math.max(0, -h) || 0)),
      d && Kf(ii(a), d),
      a
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (i, s, o) {
      var a = this._time,
        c = this._tDur,
        l = this._dur,
        h = i < 0,
        f = i > c - Ze && !h ? c : i < Ze ? 0 : i,
        u,
        p,
        _,
        g,
        d,
        m,
        y,
        v,
        x;
      if (!l) pm(this, i, s, o);
      else if (
        f !== this._tTime ||
        !i ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== h)
      ) {
        if (((u = f), (v = this.timeline), this._repeat)) {
          if (((g = l + this._rDelay), this._repeat < -1 && h))
            return this.totalTime(g * 100 + i, s, o);
          if (
            ((u = wt(f % g)),
            f === c
              ? ((_ = this._repeat), (u = l))
              : ((_ = ~~(f / g)),
                _ && _ === f / g && ((u = l), _--),
                u > l && (u = l)),
            (m = this._yoyo && _ & 1),
            m && ((x = this._yEase), (u = l - u)),
            (d = ns(this._tTime, g)),
            u === a && !o && this._initted)
          )
            return (this._tTime = f), this;
          _ !== d &&
            (v && this._yEase && hd(v, m),
            this.vars.repeatRefresh &&
              !m &&
              !this._lock &&
              ((this._lock = o = 1),
              (this.render(wt(g * _), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if ($f(this, h ? i : u, o, s, f)) return (this._tTime = 0), this;
          if (a !== this._time) return this;
          if (l !== this._dur) return this.render(i, s, o);
        }
        if (
          ((this._tTime = f),
          (this._time = u),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = y = (x || this._ease)(u / l)),
          this._from && (this.ratio = y = 1 - y),
          u && !a && !s && !_ && (Sn(this, 'onStart'), this._tTime !== f))
        )
          return this;
        for (p = this._pt; p; ) p.r(y, p.d), (p = p._next);
        (v &&
          v.render(
            i < 0 ? i : !u && m ? -Ze : v._dur * v._ease(u / this._dur),
            s,
            o
          )) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !s &&
            (h && Pc(this, i, s, o), Sn(this, 'onUpdate')),
          this._repeat &&
            _ !== d &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            Sn(this, 'onRepeat'),
          (f === this._tDur || !f) &&
            this._tTime === f &&
            (h && !this._onUpdate && Pc(this, i, !0, !0),
            (i || !l) &&
              ((f === this._tDur && this._ts > 0) || (!f && this._ts < 0)) &&
              Ui(this, 1),
            !s &&
              !(h && !a) &&
              (f || a || m) &&
              (Sn(this, f === c ? 'onComplete' : 'onReverseComplete', !0),
              this._prom && !(f < c && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        r.prototype.invalidate.call(this, i)
      );
    }),
    (t.resetTo = function (i, s, o, a) {
      Xs || cn.wake(), this._ts || this.play();
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        l;
      return (
        this._initted || xl(this, c),
        (l = this._ease(c / this._dur)),
        Im(this, i, s, o, a, l, c)
          ? this.resetTo(i, s, o, a)
          : (ma(this, 0),
            this.parent ||
              jf(
                this._dp,
                this,
                '_first',
                '_last',
                this._dp._sort ? '_start' : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (i, s) {
      if ((s === void 0 && (s = 'all'), !i && (!s || s === 'all')))
        return (this._lazy = this._pt = 0), this.parent ? Is(this) : this;
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(i, s, Ai && Ai.vars.overwrite !== !0)
            ._first || Is(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            is(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        );
      }
      var a = this._targets,
        c = i ? Mn(i) : a,
        l = this._ptLookup,
        h = this._pt,
        f,
        u,
        p,
        _,
        g,
        d,
        m;
      if ((!s || s === 'all') && hm(a, c))
        return s === 'all' && (this._pt = 0), Is(this);
      for (
        f = this._op = this._op || [],
          s !== 'all' &&
            (Tt(s) &&
              ((g = {}),
              $t(s, function (y) {
                return (g[y] = 1);
              }),
              (s = g)),
            (s = Om(a, s))),
          m = a.length;
        m--;

      )
        if (~c.indexOf(a[m])) {
          (u = l[m]),
            s === 'all'
              ? ((f[m] = s), (_ = u), (p = {}))
              : ((p = f[m] = f[m] || {}), (_ = s));
          for (g in _)
            (d = u && u[g]),
              d &&
                ((!('kill' in d.d) || d.d.kill(g) === !0) && da(this, d, '_pt'),
                delete u[g]),
              p !== 'all' && (p[g] = 1);
        }
      return this._initted && !this._pt && h && Is(this), this;
    }),
    (e.to = function (i, s) {
      return new e(i, s, arguments[2]);
    }),
    (e.from = function (i, s) {
      return Bs(1, arguments);
    }),
    (e.delayedCall = function (i, s, o, a) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a
      });
    }),
    (e.fromTo = function (i, s, o) {
      return Bs(2, arguments);
    }),
    (e.set = function (i, s) {
      return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(i, s);
    }),
    (e.killTweensOf = function (i, s, o) {
      return it.killTweensOf(i, s, o);
    }),
    e
  );
})(js);
En(mt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
$t('staggerTo,staggerFrom,staggerFromTo', function (r) {
  mt[r] = function () {
    var e = new Yt(),
      t = Ic.call(arguments, 0);
    return t.splice(r === 'staggerFromTo' ? 5 : 4, 0, 0), e[r].apply(e, t);
  };
});
var Ml = function (e, t, n) {
    return (e[t] = n);
  },
  gd = function (e, t, n) {
    return e[t](n);
  },
  Nm = function (e, t, n, i) {
    return e[t](i.fp, n);
  },
  Fm = function (e, t, n) {
    return e.setAttribute(t, n);
  },
  Sl = function (e, t) {
    return ct(e[t]) ? gd : fl(e[t]) && e.setAttribute ? Fm : Ml;
  },
  _d = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  km = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  vd = function (e, t) {
    var n = t._pt,
      i = '';
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) +
          i),
          (n = n._next);
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  },
  bl = function (e, t) {
    for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
  },
  Bm = function (e, t, n, i) {
    for (var s = this._pt, o; s; )
      (o = s._next), s.p === i && s.modifier(e, t, n), (s = o);
  },
  zm = function (e) {
    for (var t = this._pt, n, i; t; )
      (i = t._next),
        (t.p === e && !t.op) || t.op === e
          ? da(this, t, '_pt')
          : t.dep || (n = 1),
        (t = i);
    return !n;
  },
  Hm = function (e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
  },
  yd = function (e) {
    for (var t = e._pt, n, i, s, o; t; ) {
      for (n = t._next, i = s; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : o) ? (t._prev._next = t) : (s = t),
        (t._next = i) ? (i._prev = t) : (o = t),
        (t = n);
    }
    e._pt = s;
  },
  Zt = (function () {
    function r(t, n, i, s, o, a, c, l, h) {
      (this.t = n),
        (this.s = s),
        (this.c = o),
        (this.p = i),
        (this.r = a || _d),
        (this.d = c || this),
        (this.set = l || Ml),
        (this.pr = h || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = r.prototype;
    return (
      (e.modifier = function (n, i, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = Hm),
          (this.m = n),
          (this.mt = s),
          (this.tween = i);
      }),
      r
    );
  })();
$t(
  _l +
    'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
  function (r) {
    return (gl[r] = 1);
  }
);
hn.TweenMax = hn.TweenLite = mt;
hn.TimelineLite = hn.TimelineMax = Yt;
it = new Yt({
  sortChildren: !1,
  defaults: ts,
  autoRemoveChildren: !0,
  id: 'root',
  smoothChildTiming: !0
});
ln.stringFilter = cd;
var lr = [],
  qo = {},
  Gm = [],
  dh = 0,
  Vm = 0,
  Ia = function (e) {
    return (qo[e] || Gm).map(function (t) {
      return t();
    });
  },
  Fc = function () {
    var e = Date.now(),
      t = [];
    e - dh > 2 &&
      (Ia('matchMediaInit'),
      lr.forEach(function (n) {
        var i = n.queries,
          s = n.conditions,
          o,
          a,
          c,
          l;
        for (a in i)
          (o = mn.matchMedia(i[a]).matches),
            o && (c = 1),
            o !== s[a] && ((s[a] = o), (l = 1));
        l && (n.revert(), c && t.push(n));
      }),
      Ia('matchMediaRevert'),
      t.forEach(function (n) {
        return n.onMatch(n);
      }),
      (dh = e),
      Ia('matchMedia'));
  },
  xd = (function () {
    function r(t, n) {
      (this.selector = n && Oc(n)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = Vm++),
        t && this.add(t);
    }
    var e = r.prototype;
    return (
      (e.add = function (n, i, s) {
        ct(n) && ((s = i), (i = n), (n = ct));
        var o = this,
          a = function () {
            var l = at,
              h = o.selector,
              f;
            return (
              l && l !== o && l.data.push(o),
              s && (o.selector = Oc(s)),
              (at = o),
              (f = i.apply(o, arguments)),
              ct(f) && o._r.push(f),
              (at = l),
              (o.selector = h),
              (o.isReverted = !1),
              f
            );
          };
        return (o.last = a), n === ct ? a(o) : n ? (o[n] = a) : a;
      }),
      (e.ignore = function (n) {
        var i = at;
        (at = null), n(this), (at = i);
      }),
      (e.getTweens = function () {
        var n = [];
        return (
          this.data.forEach(function (i) {
            return i instanceof r
              ? n.push.apply(n, i.getTweens())
              : i instanceof mt &&
                  !(i.parent && i.parent.data === 'nested') &&
                  n.push(i);
          }),
          n
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (n, i) {
        var s = this;
        if (n) {
          var o = this.getTweens();
          this.data.forEach(function (c) {
            c.data === 'isFlip' &&
              (c.revert(),
              c.getChildren(!0, !0, !1).forEach(function (l) {
                return o.splice(o.indexOf(l), 1);
              }));
          }),
            o
              .map(function (c) {
                return { g: c.globalTime(0), t: c };
              })
              .sort(function (c, l) {
                return l.g - c.g || -1 / 0;
              })
              .forEach(function (c) {
                return c.t.revert(n);
              }),
            this.data.forEach(function (c) {
              return !(c instanceof mt) && c.revert && c.revert(n);
            }),
            this._r.forEach(function (c) {
              return c(n, s);
            }),
            (this.isReverted = !0);
        } else
          this.data.forEach(function (c) {
            return c.kill && c.kill();
          });
        if ((this.clear(), i))
          for (var a = lr.length; a--; )
            lr[a].id === this.id && lr.splice(a, 1);
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      r
    );
  })(),
  Wm = (function () {
    function r(t) {
      (this.contexts = []), (this.scope = t);
    }
    var e = r.prototype;
    return (
      (e.add = function (n, i, s) {
        Gn(n) || (n = { matches: n });
        var o = new xd(0, s || this.scope),
          a = (o.conditions = {}),
          c,
          l,
          h;
        at && !o.selector && (o.selector = at.selector),
          this.contexts.push(o),
          (i = o.add('onMatch', i)),
          (o.queries = n);
        for (l in n)
          l === 'all'
            ? (h = 1)
            : ((c = mn.matchMedia(n[l])),
              c &&
                (lr.indexOf(o) < 0 && lr.push(o),
                (a[l] = c.matches) && (h = 1),
                c.addListener
                  ? c.addListener(Fc)
                  : c.addEventListener('change', Fc)));
        return h && i(o), this;
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      (e.kill = function (n) {
        this.contexts.forEach(function (i) {
          return i.kill(n, !0);
        });
      }),
      r
    );
  })(),
  ra = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      t.forEach(function (i) {
        return sd(i);
      });
    },
    timeline: function (e) {
      return new Yt(e);
    },
    getTweensOf: function (e, t) {
      return it.getTweensOf(e, t);
    },
    getProperty: function (e, t, n, i) {
      Tt(e) && (e = Mn(e)[0]);
      var s = or(e || {}).get,
        o = n ? Xf : qf;
      return (
        n === 'native' && (n = ''),
        e &&
          (t
            ? o(((an[t] && an[t].get) || s)(e, t, n, i))
            : function (a, c, l) {
                return o(((an[a] && an[a].get) || s)(e, a, c, l));
              })
      );
    },
    quickSetter: function (e, t, n) {
      if (((e = Mn(e)), e.length > 1)) {
        var i = e.map(function (h) {
            return Qt.quickSetter(h, t, n);
          }),
          s = i.length;
        return function (h) {
          for (var f = s; f--; ) i[f](h);
        };
      }
      e = e[0] || {};
      var o = an[t],
        a = or(e),
        c = (a.harness && (a.harness.aliases || {})[t]) || t,
        l = o
          ? function (h) {
              var f = new o();
              (qr._pt = 0),
                f.init(e, n ? h + n : h, qr, 0, [e]),
                f.render(1, f),
                qr._pt && bl(1, qr);
            }
          : a.set(e, c);
      return o
        ? l
        : function (h) {
            return l(e, c, n ? h + n : h, a, 1);
          };
    },
    quickTo: function (e, t, n) {
      var i,
        s = Qt.to(
          e,
          mr(((i = {}), (i[t] = '+=0.1'), (i.paused = !0), i), n || {})
        ),
        o = function (c, l, h) {
          return s.resetTo(t, c, l, h);
        };
      return (o.tween = s), o;
    },
    isTweening: function (e) {
      return it.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = cr(e.ease, ts.ease)), ch(ts, e || {});
    },
    config: function (e) {
      return ch(ln, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        n = e.effect,
        i = e.plugins,
        s = e.defaults,
        o = e.extendTimeline;
      (i || '').split(',').forEach(function (a) {
        return (
          a && !an[a] && !hn[a] && ea(t + ' effect requires ' + a + ' plugin.')
        );
      }),
        (Ca[t] = function (a, c, l) {
          return n(Mn(a), En(c || {}, s), l);
        }),
        o &&
          (Yt.prototype[t] = function (a, c, l) {
            return this.add(Ca[t](a, Gn(c) ? c : (l = c) && {}, this), l);
          });
    },
    registerEase: function (e, t) {
      Ge[e] = cr(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? cr(e, t) : Ge;
    },
    getById: function (e) {
      return it.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var n = new Yt(e),
        i,
        s;
      for (
        n.smoothChildTiming = Kt(e.smoothChildTiming),
          it.remove(n),
          n._dp = 0,
          n._time = n._tTime = it._time,
          i = it._first;
        i;

      )
        (s = i._next),
          (t ||
            !(
              !i._dur &&
              i instanceof mt &&
              i.vars.onComplete === i._targets[0]
            )) &&
            Un(n, i, i._start - i._delay),
          (i = s);
      return Un(it, n, 0), n;
    },
    context: function (e, t) {
      return e ? new xd(e, t) : at;
    },
    matchMedia: function (e) {
      return new Wm(e);
    },
    matchMediaRefresh: function () {
      return (
        lr.forEach(function (e) {
          var t = e.conditions,
            n,
            i;
          for (i in t) t[i] && ((t[i] = !1), (n = 1));
          n && e.revert();
        }) || Fc()
      );
    },
    addEventListener: function (e, t) {
      var n = qo[e] || (qo[e] = []);
      ~n.indexOf(t) || n.push(t);
    },
    removeEventListener: function (e, t) {
      var n = qo[e],
        i = n && n.indexOf(t);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: Sm,
      wrapYoyo: bm,
      distribute: Qf,
      random: td,
      snap: ed,
      normalize: Mm,
      getUnit: Ft,
      clamp: _m,
      splitColor: od,
      toArray: Mn,
      selector: Oc,
      mapRange: id,
      pipe: ym,
      unitize: xm,
      interpolate: Em,
      shuffle: Jf
    },
    install: zf,
    effects: Ca,
    ticker: cn,
    updateRoot: Yt.updateRoot,
    plugins: an,
    globalTimeline: it,
    core: {
      PropTween: Zt,
      globals: Hf,
      Tween: mt,
      Timeline: Yt,
      Animation: js,
      getCache: or,
      _removeLinkedListItem: da,
      reverting: function () {
        return kt;
      },
      context: function (e) {
        return e && at && (at.data.push(e), (e._ctx = at)), at;
      },
      suppressOverwrites: function (e) {
        return (ul = e);
      }
    }
  };
$t('to,from,fromTo,delayedCall,set,killTweensOf', function (r) {
  return (ra[r] = mt[r]);
});
cn.add(Yt.updateRoot);
qr = ra.to({}, { duration: 0 });
var qm = function (e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
      n = n._next;
    return n;
  },
  Xm = function (e, t) {
    var n = e._targets,
      i,
      s,
      o;
    for (i in t)
      for (s = n.length; s--; )
        (o = e._ptLookup[s][i]),
          o &&
            (o = o.d) &&
            (o._pt && (o = qm(o, i)),
            o && o.modifier && o.modifier(t[i], e, n[s], i));
  },
  Oa = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (i, s, o) {
        o._onInit = function (a) {
          var c, l;
          if (
            (Tt(s) &&
              ((c = {}),
              $t(s, function (h) {
                return (c[h] = 1);
              }),
              (s = c)),
            t)
          ) {
            c = {};
            for (l in s) c[l] = t(s[l]);
            s = c;
          }
          Xm(a, s);
        };
      }
    };
  },
  Qt =
    ra.registerPlugin(
      {
        name: 'attr',
        init: function (e, t, n, i, s) {
          var o, a, c;
          this.tween = n;
          for (o in t)
            (c = e.getAttribute(o) || ''),
              (a = this.add(
                e,
                'setAttribute',
                (c || 0) + '',
                t[o],
                i,
                s,
                0,
                0,
                o
              )),
              (a.op = o),
              (a.b = c),
              this._props.push(o);
        },
        render: function (e, t) {
          for (var n = t._pt; n; )
            kt ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
        }
      },
      {
        name: 'endArray',
        init: function (e, t) {
          for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
        }
      },
      Oa('roundProps', Uc),
      Oa('modifiers'),
      Oa('snap', ed)
    ) || ra;
mt.version = Yt.version = Qt.version = '3.12.2';
Bf = 1;
dl() && rs();
Ge.Power0;
Ge.Power1;
Ge.Power2;
Ge.Power3;
Ge.Power4;
Ge.Linear;
Ge.Quad;
Ge.Cubic;
Ge.Quart;
Ge.Quint;
Ge.Strong;
Ge.Elastic;
Ge.Back;
Ge.SteppedEase;
Ge.Bounce;
Ge.Sine;
Ge.Expo;
Ge.Circ;
/*!
 * CSSPlugin 3.12.2
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var ph,
  wi,
  Kr,
  El,
  er,
  mh,
  Tl,
  jm = function () {
    return typeof window < 'u';
  },
  hi = {},
  Ki = 180 / Math.PI,
  $r = Math.PI / 180,
  Sr = Math.atan2,
  gh = 1e8,
  Al = /([A-Z])/g,
  Ym = /(left|right|width|margin|padding|x)/i,
  Km = /[\s,\(]\S/,
  kn = {
    autoAlpha: 'opacity,visibility',
    scale: 'scaleX,scaleY',
    alpha: 'opacity'
  },
  kc = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  $m = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  Zm = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  Jm = function (e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  Md = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  Sd = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  Qm = function (e, t, n) {
    return (e.style[t] = n);
  },
  eg = function (e, t, n) {
    return e.style.setProperty(t, n);
  },
  tg = function (e, t, n) {
    return (e._gsap[t] = n);
  },
  ng = function (e, t, n) {
    return (e._gsap.scaleX = e._gsap.scaleY = n);
  },
  ig = function (e, t, n, i, s) {
    var o = e._gsap;
    (o.scaleX = o.scaleY = n), o.renderTransform(s, o);
  },
  rg = function (e, t, n, i, s) {
    var o = e._gsap;
    (o[t] = n), o.renderTransform(s, o);
  },
  rt = 'transform',
  Ln = rt + 'Origin',
  sg = function r(e, t) {
    var n = this,
      i = this.target,
      s = i.style;
    if (e in hi && s) {
      if (((this.tfm = this.tfm || {}), e !== 'transform'))
        (e = kn[e] || e),
          ~e.indexOf(',')
            ? e.split(',').forEach(function (o) {
                return (n.tfm[o] = ri(i, o));
              })
            : (this.tfm[e] = i._gsap.x ? i._gsap[e] : ri(i, e));
      else
        return kn.transform.split(',').forEach(function (o) {
          return r.call(n, o, t);
        });
      if (this.props.indexOf(rt) >= 0) return;
      i._gsap.svg &&
        ((this.svgo = i.getAttribute('data-svg-origin')),
        this.props.push(Ln, t, '')),
        (e = rt);
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  bd = function (e) {
    e.translate &&
      (e.removeProperty('translate'),
      e.removeProperty('scale'),
      e.removeProperty('rotate'));
  },
  og = function () {
    var e = this.props,
      t = this.target,
      n = t.style,
      i = t._gsap,
      s,
      o;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? (t[e[s]] = e[s + 2])
        : e[s + 2]
        ? (n[e[s]] = e[s + 2])
        : n.removeProperty(
            e[s].substr(0, 2) === '--'
              ? e[s]
              : e[s].replace(Al, '-$1').toLowerCase()
          );
    if (this.tfm) {
      for (o in this.tfm) i[o] = this.tfm[o];
      i.svg &&
        (i.renderTransform(),
        t.setAttribute('data-svg-origin', this.svgo || '')),
        (s = Tl()),
        (!s || !s.isStart) && !n[rt] && (bd(n), (i.uncache = 1));
    }
  },
  Ed = function (e, t) {
    var n = { target: e, props: [], revert: og, save: sg };
    return (
      e._gsap || Qt.core.getCache(e),
      t &&
        t.split(',').forEach(function (i) {
          return n.save(i);
        }),
      n
    );
  },
  Td,
  Bc = function (e, t) {
    var n = wi.createElementNS
      ? wi.createElementNS(
          (t || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'),
          e
        )
      : wi.createElement(e);
    return n.style ? n : wi.createElement(e);
  },
  Bn = function r(e, t, n) {
    var i = getComputedStyle(e);
    return (
      i[t] ||
      i.getPropertyValue(t.replace(Al, '-$1').toLowerCase()) ||
      i.getPropertyValue(t) ||
      (!n && r(e, ss(t) || t, 1)) ||
      ''
    );
  },
  _h = 'O,Moz,ms,Ms,Webkit'.split(','),
  ss = function (e, t, n) {
    var i = t || er,
      s = i.style,
      o = 5;
    if (e in s && !n) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(_h[o] + e in s);

    );
    return o < 0 ? null : (o === 3 ? 'ms' : o >= 0 ? _h[o] : '') + e;
  },
  zc = function () {
    jm() &&
      window.document &&
      ((ph = window),
      (wi = ph.document),
      (Kr = wi.documentElement),
      (er = Bc('div') || { style: {} }),
      Bc('div'),
      (rt = ss(rt)),
      (Ln = rt + 'Origin'),
      (er.style.cssText =
        'border-width:0;line-height:0;position:absolute;padding:0'),
      (Td = !!ss('perspective')),
      (Tl = Qt.core.reverting),
      (El = 1));
  },
  Ua = function r(e) {
    var t = Bc(
        'svg',
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute('xmlns')) ||
          'http://www.w3.org/2000/svg'
      ),
      n = this.parentNode,
      i = this.nextSibling,
      s = this.style.cssText,
      o;
    if (
      (Kr.appendChild(t),
      t.appendChild(this),
      (this.style.display = 'block'),
      e)
    )
      try {
        (o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = r);
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox());
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Kr.removeChild(t),
      (this.style.cssText = s),
      o
    );
  },
  vh = function (e, t) {
    for (var n = t.length; n--; )
      if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
  },
  Ad = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = Ua.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === Ua || (t = Ua.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +vh(e, ['x', 'cx', 'x1']) || 0,
            y: +vh(e, ['y', 'cy', 'y1']) || 0,
            width: 0,
            height: 0
          }
        : t
    );
  },
  wd = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Ad(e));
  },
  Ys = function (e, t) {
    if (t) {
      var n = e.style;
      t in hi && t !== Ln && (t = rt),
        n.removeProperty
          ? ((t.substr(0, 2) === 'ms' || t.substr(0, 6) === 'webkit') &&
              (t = '-' + t),
            n.removeProperty(t.replace(Al, '-$1').toLowerCase()))
          : n.removeAttribute(t);
    }
  },
  Ri = function (e, t, n, i, s, o) {
    var a = new Zt(e._pt, t, n, 0, 1, o ? Sd : Md);
    return (e._pt = a), (a.b = i), (a.e = s), e._props.push(n), a;
  },
  yh = { deg: 1, rad: 1, turn: 1 },
  ag = { grid: 1, flex: 1 },
  Ni = function r(e, t, n, i) {
    var s = parseFloat(n) || 0,
      o = (n + '').trim().substr((s + '').length) || 'px',
      a = er.style,
      c = Ym.test(t),
      l = e.tagName.toLowerCase() === 'svg',
      h = (l ? 'client' : 'offset') + (c ? 'Width' : 'Height'),
      f = 100,
      u = i === 'px',
      p = i === '%',
      _,
      g,
      d,
      m;
    return i === o || !s || yh[i] || yh[o]
      ? s
      : (o !== 'px' && !u && (s = r(e, t, n, 'px')),
        (m = e.getCTM && wd(e)),
        (p || o === '%') && (hi[t] || ~t.indexOf('adius'))
          ? ((_ = m ? e.getBBox()[c ? 'width' : 'height'] : e[h]),
            ht(p ? (s / _) * f : (s / 100) * _))
          : ((a[c ? 'width' : 'height'] = f + (u ? o : i)),
            (g =
              ~t.indexOf('adius') || (i === 'em' && e.appendChild && !l)
                ? e
                : e.parentNode),
            m && (g = (e.ownerSVGElement || {}).parentNode),
            (!g || g === wi || !g.appendChild) && (g = wi.body),
            (d = g._gsap),
            d && p && d.width && c && d.time === cn.time && !d.uncache
              ? ht((s / d.width) * f)
              : ((p || o === '%') &&
                  !ag[Bn(g, 'display')] &&
                  (a.position = Bn(e, 'position')),
                g === e && (a.position = 'static'),
                g.appendChild(er),
                (_ = er[h]),
                g.removeChild(er),
                (a.position = 'absolute'),
                c && p && ((d = or(g)), (d.time = cn.time), (d.width = g[h])),
                ht(u ? (_ * s) / f : _ && s ? (f / _) * s : 0))));
  },
  ri = function (e, t, n, i) {
    var s;
    return (
      El || zc(),
      t in kn &&
        t !== 'transform' &&
        ((t = kn[t]), ~t.indexOf(',') && (t = t.split(',')[0])),
      hi[t] && t !== 'transform'
        ? ((s = $s(e, i)),
          (s =
            t !== 'transformOrigin'
              ? s[t]
              : s.svg
              ? s.origin
              : oa(Bn(e, Ln)) + ' ' + s.zOrigin + 'px'))
        : ((s = e.style[t]),
          (!s || s === 'auto' || i || ~(s + '').indexOf('calc(')) &&
            (s =
              (sa[t] && sa[t](e, t, n)) ||
              Bn(e, t) ||
              Vf(e, t) ||
              (t === 'opacity' ? 1 : 0))),
      n && !~(s + '').trim().indexOf(' ') ? Ni(e, t, s, n) + n : s
    );
  },
  cg = function (e, t, n, i) {
    if (!n || n === 'none') {
      var s = ss(t, e, 1),
        o = s && Bn(e, s, 1);
      o && o !== n
        ? ((t = s), (n = o))
        : t === 'borderColor' && (n = Bn(e, 'borderTopColor'));
    }
    var a = new Zt(this._pt, e.style, t, 0, 1, vd),
      c = 0,
      l = 0,
      h,
      f,
      u,
      p,
      _,
      g,
      d,
      m,
      y,
      v,
      x,
      S;
    if (
      ((a.b = n),
      (a.e = i),
      (n += ''),
      (i += ''),
      i === 'auto' && ((e.style[t] = i), (i = Bn(e, t) || i), (e.style[t] = n)),
      (h = [n, i]),
      cd(h),
      (n = h[0]),
      (i = h[1]),
      (u = n.match(Wr) || []),
      (S = i.match(Wr) || []),
      S.length)
    ) {
      for (; (f = Wr.exec(i)); )
        (d = f[0]),
          (y = i.substring(c, f.index)),
          _
            ? (_ = (_ + 1) % 5)
            : (y.substr(-5) === 'rgba(' || y.substr(-5) === 'hsla(') && (_ = 1),
          d !== (g = u[l++] || '') &&
            ((p = parseFloat(g) || 0),
            (x = g.substr((p + '').length)),
            d.charAt(1) === '=' && (d = Yr(p, d) + x),
            (m = parseFloat(d)),
            (v = d.substr((m + '').length)),
            (c = Wr.lastIndex - v.length),
            v ||
              ((v = v || ln.units[t] || x),
              c === i.length && ((i += v), (a.e += v))),
            x !== v && (p = Ni(e, t, g, v) || 0),
            (a._pt = {
              _next: a._pt,
              p: y || l === 1 ? y : ',',
              s: p,
              c: m - p,
              m: (_ && _ < 4) || t === 'zIndex' ? Math.round : 0
            }));
      a.c = c < i.length ? i.substring(c, i.length) : '';
    } else a.r = t === 'display' && i === 'none' ? Sd : Md;
    return Ff.test(i) && (a.e = 0), (this._pt = a), a;
  },
  xh = { top: '0%', bottom: '100%', left: '0%', right: '100%', center: '50%' },
  lg = function (e) {
    var t = e.split(' '),
      n = t[0],
      i = t[1] || '50%';
    return (
      (n === 'top' || n === 'bottom' || i === 'left' || i === 'right') &&
        ((e = n), (n = i), (i = e)),
      (t[0] = xh[n] || n),
      (t[1] = xh[i] || i),
      t.join(' ')
    );
  },
  hg = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var n = t.t,
        i = n.style,
        s = t.u,
        o = n._gsap,
        a,
        c,
        l;
      if (s === 'all' || s === !0) (i.cssText = ''), (c = 1);
      else
        for (s = s.split(','), l = s.length; --l > -1; )
          (a = s[l]),
            hi[a] && ((c = 1), (a = a === 'transformOrigin' ? Ln : rt)),
            Ys(n, a);
      c &&
        (Ys(n, rt),
        o &&
          (o.svg && n.removeAttribute('transform'),
          $s(n, 1),
          (o.uncache = 1),
          bd(i)));
    }
  },
  sa = {
    clearProps: function (e, t, n, i, s) {
      if (s.data !== 'isFromStart') {
        var o = (e._pt = new Zt(e._pt, t, n, 0, 0, hg));
        return (o.u = i), (o.pr = -10), (o.tween = s), e._props.push(n), 1;
      }
    }
  },
  Ks = [1, 0, 0, 1, 0, 0],
  Rd = {},
  Cd = function (e) {
    return e === 'matrix(1, 0, 0, 1, 0, 0)' || e === 'none' || !e;
  },
  Mh = function (e) {
    var t = Bn(e, rt);
    return Cd(t) ? Ks : t.substr(7).match(Nf).map(ht);
  },
  wl = function (e, t) {
    var n = e._gsap || or(e),
      i = e.style,
      s = Mh(e),
      o,
      a,
      c,
      l;
    return n.svg && e.getAttribute('transform')
      ? ((c = e.transform.baseVal.consolidate().matrix),
        (s = [c.a, c.b, c.c, c.d, c.e, c.f]),
        s.join(',') === '1,0,0,1,0,0' ? Ks : s)
      : (s === Ks &&
          !e.offsetParent &&
          e !== Kr &&
          !n.svg &&
          ((c = i.display),
          (i.display = 'block'),
          (o = e.parentNode),
          (!o || !e.offsetParent) &&
            ((l = 1), (a = e.nextElementSibling), Kr.appendChild(e)),
          (s = Mh(e)),
          c ? (i.display = c) : Ys(e, 'display'),
          l &&
            (a
              ? o.insertBefore(e, a)
              : o
              ? o.appendChild(e)
              : Kr.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  Hc = function (e, t, n, i, s, o) {
    var a = e._gsap,
      c = s || wl(e, !0),
      l = a.xOrigin || 0,
      h = a.yOrigin || 0,
      f = a.xOffset || 0,
      u = a.yOffset || 0,
      p = c[0],
      _ = c[1],
      g = c[2],
      d = c[3],
      m = c[4],
      y = c[5],
      v = t.split(' '),
      x = parseFloat(v[0]) || 0,
      S = parseFloat(v[1]) || 0,
      b,
      T,
      C,
      M;
    n
      ? c !== Ks &&
        (T = p * d - _ * g) &&
        ((C = x * (d / T) + S * (-g / T) + (g * y - d * m) / T),
        (M = x * (-_ / T) + S * (p / T) - (p * y - _ * m) / T),
        (x = C),
        (S = M))
      : ((b = Ad(e)),
        (x = b.x + (~v[0].indexOf('%') ? (x / 100) * b.width : x)),
        (S = b.y + (~(v[1] || v[0]).indexOf('%') ? (S / 100) * b.height : S))),
      i || (i !== !1 && a.smooth)
        ? ((m = x - l),
          (y = S - h),
          (a.xOffset = f + (m * p + y * g) - m),
          (a.yOffset = u + (m * _ + y * d) - y))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = x),
      (a.yOrigin = S),
      (a.smooth = !!i),
      (a.origin = t),
      (a.originIsAbsolute = !!n),
      (e.style[Ln] = '0px 0px'),
      o &&
        (Ri(o, a, 'xOrigin', l, x),
        Ri(o, a, 'yOrigin', h, S),
        Ri(o, a, 'xOffset', f, a.xOffset),
        Ri(o, a, 'yOffset', u, a.yOffset)),
      e.setAttribute('data-svg-origin', x + ' ' + S);
  },
  $s = function (e, t) {
    var n = e._gsap || new fd(e);
    if ('x' in n && !t && !n.uncache) return n;
    var i = e.style,
      s = n.scaleX < 0,
      o = 'px',
      a = 'deg',
      c = getComputedStyle(e),
      l = Bn(e, Ln) || '0',
      h,
      f,
      u,
      p,
      _,
      g,
      d,
      m,
      y,
      v,
      x,
      S,
      b,
      T,
      C,
      M,
      A,
      X,
      Y,
      D,
      F,
      N,
      K,
      z,
      j,
      J,
      $,
      k,
      V,
      oe,
      re,
      le;
    return (
      (h = f = u = g = d = m = y = v = x = 0),
      (p = _ = 1),
      (n.svg = !!(e.getCTM && wd(e))),
      c.translate &&
        ((c.translate !== 'none' ||
          c.scale !== 'none' ||
          c.rotate !== 'none') &&
          (i[rt] =
            (c.translate !== 'none'
              ? 'translate3d(' +
                (c.translate + ' 0 0').split(' ').slice(0, 3).join(', ') +
                ') '
              : '') +
            (c.rotate !== 'none' ? 'rotate(' + c.rotate + ') ' : '') +
            (c.scale !== 'none'
              ? 'scale(' + c.scale.split(' ').join(',') + ') '
              : '') +
            (c[rt] !== 'none' ? c[rt] : '')),
        (i.scale = i.rotate = i.translate = 'none')),
      (T = wl(e, n.svg)),
      n.svg &&
        (n.uncache
          ? ((j = e.getBBox()),
            (l = n.xOrigin - j.x + 'px ' + (n.yOrigin - j.y) + 'px'),
            (z = ''))
          : (z = !t && e.getAttribute('data-svg-origin')),
        Hc(e, z || l, !!z || n.originIsAbsolute, n.smooth !== !1, T)),
      (S = n.xOrigin || 0),
      (b = n.yOrigin || 0),
      T !== Ks &&
        ((X = T[0]),
        (Y = T[1]),
        (D = T[2]),
        (F = T[3]),
        (h = N = T[4]),
        (f = K = T[5]),
        T.length === 6
          ? ((p = Math.sqrt(X * X + Y * Y)),
            (_ = Math.sqrt(F * F + D * D)),
            (g = X || Y ? Sr(Y, X) * Ki : 0),
            (y = D || F ? Sr(D, F) * Ki + g : 0),
            y && (_ *= Math.abs(Math.cos(y * $r))),
            n.svg && ((h -= S - (S * X + b * D)), (f -= b - (S * Y + b * F))))
          : ((le = T[6]),
            (oe = T[7]),
            ($ = T[8]),
            (k = T[9]),
            (V = T[10]),
            (re = T[11]),
            (h = T[12]),
            (f = T[13]),
            (u = T[14]),
            (C = Sr(le, V)),
            (d = C * Ki),
            C &&
              ((M = Math.cos(-C)),
              (A = Math.sin(-C)),
              (z = N * M + $ * A),
              (j = K * M + k * A),
              (J = le * M + V * A),
              ($ = N * -A + $ * M),
              (k = K * -A + k * M),
              (V = le * -A + V * M),
              (re = oe * -A + re * M),
              (N = z),
              (K = j),
              (le = J)),
            (C = Sr(-D, V)),
            (m = C * Ki),
            C &&
              ((M = Math.cos(-C)),
              (A = Math.sin(-C)),
              (z = X * M - $ * A),
              (j = Y * M - k * A),
              (J = D * M - V * A),
              (re = F * A + re * M),
              (X = z),
              (Y = j),
              (D = J)),
            (C = Sr(Y, X)),
            (g = C * Ki),
            C &&
              ((M = Math.cos(C)),
              (A = Math.sin(C)),
              (z = X * M + Y * A),
              (j = N * M + K * A),
              (Y = Y * M - X * A),
              (K = K * M - N * A),
              (X = z),
              (N = j)),
            d &&
              Math.abs(d) + Math.abs(g) > 359.9 &&
              ((d = g = 0), (m = 180 - m)),
            (p = ht(Math.sqrt(X * X + Y * Y + D * D))),
            (_ = ht(Math.sqrt(K * K + le * le))),
            (C = Sr(N, K)),
            (y = Math.abs(C) > 2e-4 ? C * Ki : 0),
            (x = re ? 1 / (re < 0 ? -re : re) : 0)),
        n.svg &&
          ((z = e.getAttribute('transform')),
          (n.forceCSS = e.setAttribute('transform', '') || !Cd(Bn(e, rt))),
          z && e.setAttribute('transform', z))),
      Math.abs(y) > 90 &&
        Math.abs(y) < 270 &&
        (s
          ? ((p *= -1), (y += g <= 0 ? 180 : -180), (g += g <= 0 ? 180 : -180))
          : ((_ *= -1), (y += y <= 0 ? 180 : -180))),
      (t = t || n.uncache),
      (n.x =
        h -
        ((n.xPercent =
          h &&
          ((!t && n.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetWidth * n.xPercent) / 100
          : 0) +
        o),
      (n.y =
        f -
        ((n.yPercent =
          f &&
          ((!t && n.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0)))
          ? (e.offsetHeight * n.yPercent) / 100
          : 0) +
        o),
      (n.z = u + o),
      (n.scaleX = ht(p)),
      (n.scaleY = ht(_)),
      (n.rotation = ht(g) + a),
      (n.rotationX = ht(d) + a),
      (n.rotationY = ht(m) + a),
      (n.skewX = y + a),
      (n.skewY = v + a),
      (n.transformPerspective = x + o),
      (n.zOrigin = parseFloat(l.split(' ')[2]) || 0) && (i[Ln] = oa(l)),
      (n.xOffset = n.yOffset = 0),
      (n.force3D = ln.force3D),
      (n.renderTransform = n.svg ? fg : Td ? Ld : ug),
      (n.uncache = 0),
      n
    );
  },
  oa = function (e) {
    return (e = e.split(' '))[0] + ' ' + e[1];
  },
  Na = function (e, t, n) {
    var i = Ft(t);
    return ht(parseFloat(t) + parseFloat(Ni(e, 'x', n + 'px', i))) + i;
  },
  ug = function (e, t) {
    (t.z = '0px'),
      (t.rotationY = t.rotationX = '0deg'),
      (t.force3D = 0),
      Ld(e, t);
  },
  Gi = '0deg',
  Ss = '0px',
  Vi = ') ',
  Ld = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      s = n.yPercent,
      o = n.x,
      a = n.y,
      c = n.z,
      l = n.rotation,
      h = n.rotationY,
      f = n.rotationX,
      u = n.skewX,
      p = n.skewY,
      _ = n.scaleX,
      g = n.scaleY,
      d = n.transformPerspective,
      m = n.force3D,
      y = n.target,
      v = n.zOrigin,
      x = '',
      S = (m === 'auto' && e && e !== 1) || m === !0;
    if (v && (f !== Gi || h !== Gi)) {
      var b = parseFloat(h) * $r,
        T = Math.sin(b),
        C = Math.cos(b),
        M;
      (b = parseFloat(f) * $r),
        (M = Math.cos(b)),
        (o = Na(y, o, T * M * -v)),
        (a = Na(y, a, -Math.sin(b) * -v)),
        (c = Na(y, c, C * M * -v + v));
    }
    d !== Ss && (x += 'perspective(' + d + Vi),
      (i || s) && (x += 'translate(' + i + '%, ' + s + '%) '),
      (S || o !== Ss || a !== Ss || c !== Ss) &&
        (x +=
          c !== Ss || S
            ? 'translate3d(' + o + ', ' + a + ', ' + c + ') '
            : 'translate(' + o + ', ' + a + Vi),
      l !== Gi && (x += 'rotate(' + l + Vi),
      h !== Gi && (x += 'rotateY(' + h + Vi),
      f !== Gi && (x += 'rotateX(' + f + Vi),
      (u !== Gi || p !== Gi) && (x += 'skew(' + u + ', ' + p + Vi),
      (_ !== 1 || g !== 1) && (x += 'scale(' + _ + ', ' + g + Vi),
      (y.style[rt] = x || 'translate(0, 0)');
  },
  fg = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      s = n.yPercent,
      o = n.x,
      a = n.y,
      c = n.rotation,
      l = n.skewX,
      h = n.skewY,
      f = n.scaleX,
      u = n.scaleY,
      p = n.target,
      _ = n.xOrigin,
      g = n.yOrigin,
      d = n.xOffset,
      m = n.yOffset,
      y = n.forceCSS,
      v = parseFloat(o),
      x = parseFloat(a),
      S,
      b,
      T,
      C,
      M;
    (c = parseFloat(c)),
      (l = parseFloat(l)),
      (h = parseFloat(h)),
      h && ((h = parseFloat(h)), (l += h), (c += h)),
      c || l
        ? ((c *= $r),
          (l *= $r),
          (S = Math.cos(c) * f),
          (b = Math.sin(c) * f),
          (T = Math.sin(c - l) * -u),
          (C = Math.cos(c - l) * u),
          l &&
            ((h *= $r),
            (M = Math.tan(l - h)),
            (M = Math.sqrt(1 + M * M)),
            (T *= M),
            (C *= M),
            h &&
              ((M = Math.tan(h)),
              (M = Math.sqrt(1 + M * M)),
              (S *= M),
              (b *= M))),
          (S = ht(S)),
          (b = ht(b)),
          (T = ht(T)),
          (C = ht(C)))
        : ((S = f), (C = u), (b = T = 0)),
      ((v && !~(o + '').indexOf('px')) || (x && !~(a + '').indexOf('px'))) &&
        ((v = Ni(p, 'x', o, 'px')), (x = Ni(p, 'y', a, 'px'))),
      (_ || g || d || m) &&
        ((v = ht(v + _ - (_ * S + g * T) + d)),
        (x = ht(x + g - (_ * b + g * C) + m))),
      (i || s) &&
        ((M = p.getBBox()),
        (v = ht(v + (i / 100) * M.width)),
        (x = ht(x + (s / 100) * M.height))),
      (M =
        'matrix(' + S + ',' + b + ',' + T + ',' + C + ',' + v + ',' + x + ')'),
      p.setAttribute('transform', M),
      y && (p.style[rt] = M);
  },
  dg = function (e, t, n, i, s) {
    var o = 360,
      a = Tt(s),
      c = parseFloat(s) * (a && ~s.indexOf('rad') ? Ki : 1),
      l = c - i,
      h = i + l + 'deg',
      f,
      u;
    return (
      a &&
        ((f = s.split('_')[1]),
        f === 'short' && ((l %= o), l !== l % (o / 2) && (l += l < 0 ? o : -o)),
        f === 'cw' && l < 0
          ? (l = ((l + o * gh) % o) - ~~(l / o) * o)
          : f === 'ccw' && l > 0 && (l = ((l - o * gh) % o) - ~~(l / o) * o)),
      (e._pt = u = new Zt(e._pt, t, n, i, l, $m)),
      (u.e = h),
      (u.u = 'deg'),
      e._props.push(n),
      u
    );
  },
  Sh = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  pg = function (e, t, n) {
    var i = Sh({}, n._gsap),
      s = 'perspective,force3D,transformOrigin,svgOrigin',
      o = n.style,
      a,
      c,
      l,
      h,
      f,
      u,
      p,
      _;
    i.svg
      ? ((l = n.getAttribute('transform')),
        n.setAttribute('transform', ''),
        (o[rt] = t),
        (a = $s(n, 1)),
        Ys(n, rt),
        n.setAttribute('transform', l))
      : ((l = getComputedStyle(n)[rt]),
        (o[rt] = t),
        (a = $s(n, 1)),
        (o[rt] = l));
    for (c in hi)
      (l = i[c]),
        (h = a[c]),
        l !== h &&
          s.indexOf(c) < 0 &&
          ((p = Ft(l)),
          (_ = Ft(h)),
          (f = p !== _ ? Ni(n, c, l, _) : parseFloat(l)),
          (u = parseFloat(h)),
          (e._pt = new Zt(e._pt, a, c, f, u - f, kc)),
          (e._pt.u = _ || 0),
          e._props.push(c));
    Sh(a, i);
  };
$t('padding,margin,Width,Radius', function (r, e) {
  var t = 'Top',
    n = 'Right',
    i = 'Bottom',
    s = 'Left',
    o = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function (a) {
      return e < 2 ? r + a : 'border' + a + r;
    });
  sa[e > 1 ? 'border' + r : r] = function (a, c, l, h, f) {
    var u, p;
    if (arguments.length < 4)
      return (
        (u = o.map(function (_) {
          return ri(a, _, l);
        })),
        (p = u.join(' ')),
        p.split(u[0]).length === 5 ? u[0] : p
      );
    (u = (h + '').split(' ')),
      (p = {}),
      o.forEach(function (_, g) {
        return (p[_] = u[g] = u[g] || u[((g - 1) / 2) | 0]);
      }),
      a.init(c, p, f);
  };
});
var Pd = {
  name: 'css',
  register: zc,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, n, i, s) {
    var o = this._props,
      a = e.style,
      c = n.vars.startAt,
      l,
      h,
      f,
      u,
      p,
      _,
      g,
      d,
      m,
      y,
      v,
      x,
      S,
      b,
      T,
      C;
    El || zc(),
      (this.styles = this.styles || Ed(e)),
      (C = this.styles.props),
      (this.tween = n);
    for (g in t)
      if (g !== 'autoRound' && ((h = t[g]), !(an[g] && dd(g, t, n, i, e, s)))) {
        if (
          ((p = typeof h),
          (_ = sa[g]),
          p === 'function' && ((h = h.call(n, i, e, s)), (p = typeof h)),
          p === 'string' && ~h.indexOf('random(') && (h = qs(h)),
          _)
        )
          _(this, e, g, h, n) && (T = 1);
        else if (g.substr(0, 2) === '--')
          (l = (getComputedStyle(e).getPropertyValue(g) + '').trim()),
            (h += ''),
            (Pi.lastIndex = 0),
            Pi.test(l) || ((d = Ft(l)), (m = Ft(h))),
            m ? d !== m && (l = Ni(e, g, l, m) + m) : d && (h += d),
            this.add(a, 'setProperty', l, h, i, s, 0, 0, g),
            o.push(g),
            C.push(g, 0, a[g]);
        else if (p !== 'undefined') {
          if (
            (c && g in c
              ? ((l = typeof c[g] == 'function' ? c[g].call(n, i, e, s) : c[g]),
                Tt(l) && ~l.indexOf('random(') && (l = qs(l)),
                Ft(l + '') || (l += ln.units[g] || Ft(ri(e, g)) || ''),
                (l + '').charAt(1) === '=' && (l = ri(e, g)))
              : (l = ri(e, g)),
            (u = parseFloat(l)),
            (y = p === 'string' && h.charAt(1) === '=' && h.substr(0, 2)),
            y && (h = h.substr(2)),
            (f = parseFloat(h)),
            g in kn &&
              (g === 'autoAlpha' &&
                (u === 1 && ri(e, 'visibility') === 'hidden' && f && (u = 0),
                C.push('visibility', 0, a.visibility),
                Ri(
                  this,
                  a,
                  'visibility',
                  u ? 'inherit' : 'hidden',
                  f ? 'inherit' : 'hidden',
                  !f
                )),
              g !== 'scale' &&
                g !== 'transform' &&
                ((g = kn[g]), ~g.indexOf(',') && (g = g.split(',')[0]))),
            (v = g in hi),
            v)
          ) {
            if (
              (this.styles.save(g),
              x ||
                ((S = e._gsap),
                (S.renderTransform && !t.parseTransform) ||
                  $s(e, t.parseTransform),
                (b = t.smoothOrigin !== !1 && S.smooth),
                (x = this._pt =
                  new Zt(this._pt, a, rt, 0, 1, S.renderTransform, S, 0, -1)),
                (x.dep = 1)),
              g === 'scale')
            )
              (this._pt = new Zt(
                this._pt,
                S,
                'scaleY',
                S.scaleY,
                (y ? Yr(S.scaleY, y + f) : f) - S.scaleY || 0,
                kc
              )),
                (this._pt.u = 0),
                o.push('scaleY', g),
                (g += 'X');
            else if (g === 'transformOrigin') {
              C.push(Ln, 0, a[Ln]),
                (h = lg(h)),
                S.svg
                  ? Hc(e, h, 0, b, 0, this)
                  : ((m = parseFloat(h.split(' ')[2]) || 0),
                    m !== S.zOrigin && Ri(this, S, 'zOrigin', S.zOrigin, m),
                    Ri(this, a, g, oa(l), oa(h)));
              continue;
            } else if (g === 'svgOrigin') {
              Hc(e, h, 1, b, 0, this);
              continue;
            } else if (g in Rd) {
              dg(this, S, g, u, y ? Yr(u, y + h) : h);
              continue;
            } else if (g === 'smoothOrigin') {
              Ri(this, S, 'smooth', S.smooth, h);
              continue;
            } else if (g === 'force3D') {
              S[g] = h;
              continue;
            } else if (g === 'transform') {
              pg(this, h, e);
              continue;
            }
          } else g in a || (g = ss(g) || g);
          if (v || ((f || f === 0) && (u || u === 0) && !Km.test(h) && g in a))
            (d = (l + '').substr((u + '').length)),
              f || (f = 0),
              (m = Ft(h) || (g in ln.units ? ln.units[g] : d)),
              d !== m && (u = Ni(e, g, l, m)),
              (this._pt = new Zt(
                this._pt,
                v ? S : a,
                g,
                u,
                (y ? Yr(u, y + f) : f) - u,
                !v && (m === 'px' || g === 'zIndex') && t.autoRound !== !1
                  ? Jm
                  : kc
              )),
              (this._pt.u = m || 0),
              d !== m && m !== '%' && ((this._pt.b = l), (this._pt.r = Zm));
          else if (g in a) cg.call(this, e, g, l, y ? y + h : h);
          else if (g in e) this.add(e, g, l || e[g], y ? y + h : h, i, s);
          else if (g !== 'parseTransform') {
            ml(g, h);
            continue;
          }
          v || (g in a ? C.push(g, 0, a[g]) : C.push(g, 1, l || e[g])),
            o.push(g);
        }
      }
    T && yd(this);
  },
  render: function (e, t) {
    if (t.tween._time || !Tl())
      for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
    else t.styles.revert();
  },
  get: ri,
  aliases: kn,
  getSetter: function (e, t, n) {
    var i = kn[t];
    return (
      i && i.indexOf(',') < 0 && (t = i),
      t in hi && t !== Ln && (e._gsap.x || ri(e, 'x'))
        ? n && mh === n
          ? t === 'scale'
            ? ng
            : tg
          : (mh = n || {}) && (t === 'scale' ? ig : rg)
        : e.style && !fl(e.style[t])
        ? Qm
        : ~t.indexOf('-')
        ? eg
        : Sl(e, t)
    );
  },
  core: { _removeProperty: Ys, _getMatrix: wl }
};
Qt.utils.checkPrefix = ss;
Qt.core.getStyleSaver = Ed;
(function (r, e, t, n) {
  var i = $t(r + ',' + e + ',' + t, function (s) {
    hi[s] = 1;
  });
  $t(e, function (s) {
    (ln.units[s] = 'deg'), (Rd[s] = 1);
  }),
    (kn[i[13]] = r + ',' + e),
    $t(n, function (s) {
      var o = s.split(':');
      kn[o[1]] = i[o[0]];
    });
})(
  'x,y,z,scale,scaleX,scaleY,xPercent,yPercent',
  'rotation,rotationX,rotationY,skewX,skewY',
  'transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
  '0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY'
);
$t(
  'x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective',
  function (r) {
    ln.units[r] = 'px';
  }
);
Qt.registerPlugin(Pd);
var Z = Qt.registerPlugin(Pd) || Qt;
Z.core.Tween;
function bh(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      'value' in n && (n.writable = !0),
      Object.defineProperty(r, n.key, n);
  }
}
function Rl(r, e, t) {
  return e && bh(r.prototype, e), t && bh(r, t), r;
}
function tr() {
  return (tr =
    Object.assign ||
    function (r) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
      }
      return r;
    }).apply(this, arguments);
}
function ga(r, e) {
  (r.prototype = Object.create(e.prototype)),
    (r.prototype.constructor = r),
    (r.__proto__ = e);
}
function Dd(r) {
  return (Dd = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(r);
}
function Cl(r, e) {
  return (Cl =
    Object.setPrototypeOf ||
    function (t, n) {
      return (t.__proto__ = n), t;
    })(r, e);
}
function Id(r, e, t) {
  return (Id = (function () {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == 'function') return !0;
    try {
      return (
        Date.prototype.toString.call(
          Reflect.construct(Date, [], function () {})
        ),
        !0
      );
    } catch {
      return !1;
    }
  })()
    ? Reflect.construct
    : function (n, i, s) {
        var o = [null];
        o.push.apply(o, i);
        var a = new (Function.bind.apply(n, o))();
        return s && Cl(a, s.prototype), a;
      }).apply(null, arguments);
}
function Od(r) {
  var e = typeof Map == 'function' ? new Map() : void 0;
  return (Od = function (t) {
    if (t === null || Function.toString.call(t).indexOf('[native code]') === -1)
      return t;
    if (typeof t != 'function')
      throw new TypeError('Super expression must either be null or a function');
    if (e !== void 0) {
      if (e.has(t)) return e.get(t);
      e.set(t, n);
    }
    function n() {
      return Id(t, arguments, Dd(this).constructor);
    }
    return (
      (n.prototype = Object.create(t.prototype, {
        constructor: {
          value: n,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      })),
      Cl(n, t)
    );
  })(r);
}
function Hr(r, e) {
  try {
    var t = r();
  } catch (n) {
    return e(n);
  }
  return t && t.then ? t.then(void 0, e) : t;
}
typeof Symbol < 'u' &&
  (Symbol.iterator || (Symbol.iterator = Symbol('Symbol.iterator'))),
  typeof Symbol < 'u' &&
    (Symbol.asyncIterator ||
      (Symbol.asyncIterator = Symbol('Symbol.asyncIterator')));
var Ti,
  mg = '2.9.7',
  gg = function () {};
(function (r) {
  (r[(r.off = 0)] = 'off'),
    (r[(r.error = 1)] = 'error'),
    (r[(r.warning = 2)] = 'warning'),
    (r[(r.info = 3)] = 'info'),
    (r[(r.debug = 4)] = 'debug');
})(Ti || (Ti = {}));
var Eh = Ti.off,
  nr = (function () {
    function r(t) {
      this.t = t;
    }
    (r.getLevel = function () {
      return Eh;
    }),
      (r.setLevel = function (t) {
        return (Eh = Ti[t]);
      });
    var e = r.prototype;
    return (
      (e.error = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.error, Ti.error, n);
      }),
      (e.warn = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.warn, Ti.warning, n);
      }),
      (e.info = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.info, Ti.info, n);
      }),
      (e.debug = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.log, Ti.debug, n);
      }),
      (e.i = function (t, n, i) {
        n <= r.getLevel() && t.apply(console, ['[' + this.t + '] '].concat(i));
      }),
      r
    );
  })(),
  $i = Dl,
  _g = Nd,
  vg = Ll,
  yg = Fd,
  xg = kd,
  Ud = '/',
  Mg = new RegExp(
    [
      '(\\\\.)',
      '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
    ].join('|'),
    'g'
  );
function Ll(r, e) {
  for (
    var t,
      n = [],
      i = 0,
      s = 0,
      o = '',
      a = (e && e.delimiter) || Ud,
      c = (e && e.whitelist) || void 0,
      l = !1;
    (t = Mg.exec(r)) !== null;

  ) {
    var h = t[0],
      f = t[1],
      u = t.index;
    if (((o += r.slice(s, u)), (s = u + h.length), f)) (o += f[1]), (l = !0);
    else {
      var p = '',
        _ = t[2],
        g = t[3],
        d = t[4],
        m = t[5];
      if (!l && o.length) {
        var y = o.length - 1,
          v = o[y];
        (!c || c.indexOf(v) > -1) && ((p = v), (o = o.slice(0, y)));
      }
      o && (n.push(o), (o = ''), (l = !1));
      var x = g || d,
        S = p || a;
      n.push({
        name: _ || i++,
        prefix: p,
        delimiter: S,
        optional: m === '?' || m === '*',
        repeat: m === '+' || m === '*',
        pattern: x ? Sg(x) : '[^' + ti(S === a ? S : S + a) + ']+?'
      });
    }
  }
  return (o || s < r.length) && n.push(o + r.substr(s)), n;
}
function Nd(r, e) {
  return function (t, n) {
    var i = r.exec(t);
    if (!i) return !1;
    for (
      var s = i[0],
        o = i.index,
        a = {},
        c = (n && n.decode) || decodeURIComponent,
        l = 1;
      l < i.length;
      l++
    )
      if (i[l] !== void 0) {
        var h = e[l - 1];
        a[h.name] = h.repeat
          ? i[l].split(h.delimiter).map(function (f) {
              return c(f, h);
            })
          : c(i[l], h);
      }
    return { path: s, index: o, params: a };
  };
}
function Fd(r, e) {
  for (var t = new Array(r.length), n = 0; n < r.length; n++)
    typeof r[n] == 'object' &&
      (t[n] = new RegExp('^(?:' + r[n].pattern + ')$', Pl(e)));
  return function (i, s) {
    for (
      var o = '',
        a = (s && s.encode) || encodeURIComponent,
        c = !s || s.validate !== !1,
        l = 0;
      l < r.length;
      l++
    ) {
      var h = r[l];
      if (typeof h != 'string') {
        var f,
          u = i ? i[h.name] : void 0;
        if (Array.isArray(u)) {
          if (!h.repeat)
            throw new TypeError(
              'Expected "' + h.name + '" to not repeat, but got array'
            );
          if (u.length === 0) {
            if (h.optional) continue;
            throw new TypeError('Expected "' + h.name + '" to not be empty');
          }
          for (var p = 0; p < u.length; p++) {
            if (((f = a(u[p], h)), c && !t[l].test(f)))
              throw new TypeError(
                'Expected all "' + h.name + '" to match "' + h.pattern + '"'
              );
            o += (p === 0 ? h.prefix : h.delimiter) + f;
          }
        } else if (
          typeof u != 'string' &&
          typeof u != 'number' &&
          typeof u != 'boolean'
        ) {
          if (!h.optional)
            throw new TypeError(
              'Expected "' +
                h.name +
                '" to be ' +
                (h.repeat ? 'an array' : 'a string')
            );
        } else {
          if (((f = a(String(u), h)), c && !t[l].test(f)))
            throw new TypeError(
              'Expected "' +
                h.name +
                '" to match "' +
                h.pattern +
                '", but got "' +
                f +
                '"'
            );
          o += h.prefix + f;
        }
      } else o += h;
    }
    return o;
  };
}
function ti(r) {
  return r.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}
function Sg(r) {
  return r.replace(/([=!:$/()])/g, '\\$1');
}
function Pl(r) {
  return r && r.sensitive ? '' : 'i';
}
function kd(r, e, t) {
  for (
    var n = (t = t || {}).strict,
      i = t.start !== !1,
      s = t.end !== !1,
      o = t.delimiter || Ud,
      a = []
        .concat(t.endsWith || [])
        .map(ti)
        .concat('$')
        .join('|'),
      c = i ? '^' : '',
      l = 0;
    l < r.length;
    l++
  ) {
    var h = r[l];
    if (typeof h == 'string') c += ti(h);
    else {
      var f = h.repeat
        ? '(?:' +
          h.pattern +
          ')(?:' +
          ti(h.delimiter) +
          '(?:' +
          h.pattern +
          '))*'
        : h.pattern;
      e && e.push(h),
        (c += h.optional
          ? h.prefix
            ? '(?:' + ti(h.prefix) + '(' + f + '))?'
            : '(' + f + ')?'
          : ti(h.prefix) + '(' + f + ')');
    }
  }
  if (s)
    n || (c += '(?:' + ti(o) + ')?'), (c += a === '$' ? '$' : '(?=' + a + ')');
  else {
    var u = r[r.length - 1],
      p = typeof u == 'string' ? u[u.length - 1] === o : u === void 0;
    n || (c += '(?:' + ti(o) + '(?=' + a + '))?'),
      p || (c += '(?=' + ti(o) + '|' + a + ')');
  }
  return new RegExp(c, Pl(t));
}
function Dl(r, e, t) {
  return r instanceof RegExp
    ? (function (n, i) {
        if (!i) return n;
        var s = n.source.match(/\((?!\?)/g);
        if (s)
          for (var o = 0; o < s.length; o++)
            i.push({
              name: o,
              prefix: null,
              delimiter: null,
              optional: !1,
              repeat: !1,
              pattern: null
            });
        return n;
      })(r, e)
    : Array.isArray(r)
    ? (function (n, i, s) {
        for (var o = [], a = 0; a < n.length; a++)
          o.push(Dl(n[a], i, s).source);
        return new RegExp('(?:' + o.join('|') + ')', Pl(s));
      })(r, e, t)
    : (function (n, i, s) {
        return kd(Ll(n, s), i, s);
      })(r, e, t);
}
($i.match = function (r, e) {
  var t = [];
  return Nd(Dl(r, t, e), t);
}),
  ($i.regexpToFunction = _g),
  ($i.parse = vg),
  ($i.compile = function (r, e) {
    return Fd(Ll(r, e), e);
  }),
  ($i.tokensToFunction = yg),
  ($i.tokensToRegExp = xg);
var zn = {
    container: 'container',
    history: 'history',
    namespace: 'namespace',
    prefix: 'data-barba',
    prevent: 'prevent',
    wrapper: 'wrapper'
  },
  ir = new ((function () {
    function r() {
      (this.o = zn), (this.u = new DOMParser());
    }
    var e = r.prototype;
    return (
      (e.toString = function (t) {
        return t.outerHTML;
      }),
      (e.toDocument = function (t) {
        return this.u.parseFromString(t, 'text/html');
      }),
      (e.toElement = function (t) {
        var n = document.createElement('div');
        return (n.innerHTML = t), n;
      }),
      (e.getHtml = function (t) {
        return t === void 0 && (t = document), this.toString(t.documentElement);
      }),
      (e.getWrapper = function (t) {
        return (
          t === void 0 && (t = document),
          t.querySelector('[' + this.o.prefix + '="' + this.o.wrapper + '"]')
        );
      }),
      (e.getContainer = function (t) {
        return (
          t === void 0 && (t = document),
          t.querySelector('[' + this.o.prefix + '="' + this.o.container + '"]')
        );
      }),
      (e.removeContainer = function (t) {
        document.body.contains(t) && t.parentNode.removeChild(t);
      }),
      (e.addContainer = function (t, n) {
        var i = this.getContainer();
        i ? this.s(t, i) : n.appendChild(t);
      }),
      (e.getNamespace = function (t) {
        t === void 0 && (t = document);
        var n = t.querySelector(
          '[' + this.o.prefix + '-' + this.o.namespace + ']'
        );
        return n
          ? n.getAttribute(this.o.prefix + '-' + this.o.namespace)
          : null;
      }),
      (e.getHref = function (t) {
        if (t.tagName && t.tagName.toLowerCase() === 'a') {
          if (typeof t.href == 'string') return t.href;
          var n = t.getAttribute('href') || t.getAttribute('xlink:href');
          if (n) return this.resolveUrl(n.baseVal || n);
        }
        return null;
      }),
      (e.resolveUrl = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        var s = n.length;
        if (s === 0)
          throw new Error(
            'resolveUrl requires at least one argument; got none.'
          );
        var o = document.createElement('base');
        if (((o.href = arguments[0]), s === 1)) return o.href;
        var a = document.getElementsByTagName('head')[0];
        a.insertBefore(o, a.firstChild);
        for (var c, l = document.createElement('a'), h = 1; h < s; h++)
          (l.href = arguments[h]), (o.href = c = l.href);
        return a.removeChild(o), c;
      }),
      (e.s = function (t, n) {
        n.parentNode.insertBefore(t, n.nextSibling);
      }),
      r
    );
  })())(),
  Bd = new ((function () {
    function r() {
      (this.h = []), (this.v = -1);
    }
    var e = r.prototype;
    return (
      (e.init = function (t, n) {
        this.l = 'barba';
        var i = {
          ns: n,
          scroll: { x: window.scrollX, y: window.scrollY },
          url: t
        };
        this.h.push(i), (this.v = 0);
        var s = { from: this.l, index: 0, states: [].concat(this.h) };
        window.history && window.history.replaceState(s, '', t);
      }),
      (e.change = function (t, n, i) {
        if (i && i.state) {
          var s = i.state,
            o = s.index;
          (n = this.m(this.v - o)), this.replace(s.states), (this.v = o);
        } else this.add(t, n);
        return n;
      }),
      (e.add = function (t, n) {
        var i = this.size,
          s = this.p(n),
          o = {
            ns: 'tmp',
            scroll: { x: window.scrollX, y: window.scrollY },
            url: t
          };
        this.h.push(o), (this.v = i);
        var a = { from: this.l, index: i, states: [].concat(this.h) };
        switch (s) {
          case 'push':
            window.history && window.history.pushState(a, '', t);
            break;
          case 'replace':
            window.history && window.history.replaceState(a, '', t);
        }
      }),
      (e.update = function (t, n) {
        var i = n || this.v,
          s = tr({}, this.get(i), {}, t);
        this.set(i, s);
      }),
      (e.remove = function (t) {
        t ? this.h.splice(t, 1) : this.h.pop(), this.v--;
      }),
      (e.clear = function () {
        (this.h = []), (this.v = -1);
      }),
      (e.replace = function (t) {
        this.h = t;
      }),
      (e.get = function (t) {
        return this.h[t];
      }),
      (e.set = function (t, n) {
        return (this.h[t] = n);
      }),
      (e.p = function (t) {
        var n = 'push',
          i = t,
          s = zn.prefix + '-' + zn.history;
        return (
          i.hasAttribute && i.hasAttribute(s) && (n = i.getAttribute(s)), n
        );
      }),
      (e.m = function (t) {
        return Math.abs(t) > 1
          ? t > 0
            ? 'forward'
            : 'back'
          : t === 0
          ? 'popstate'
          : t > 0
          ? 'back'
          : 'forward';
      }),
      Rl(r, [
        {
          key: 'current',
          get: function () {
            return this.h[this.v];
          }
        },
        {
          key: 'state',
          get: function () {
            return this.h[this.h.length - 1];
          }
        },
        {
          key: 'previous',
          get: function () {
            return this.v < 1 ? null : this.h[this.v - 1];
          }
        },
        {
          key: 'size',
          get: function () {
            return this.h.length;
          }
        }
      ]),
      r
    );
  })())(),
  aa = function (r, e) {
    try {
      var t = (function () {
        if (!e.next.html)
          return Promise.resolve(r).then(function (n) {
            var i = e.next;
            if (n) {
              var s = ir.toElement(n);
              (i.namespace = ir.getNamespace(s)),
                (i.container = ir.getContainer(s)),
                (i.html = n),
                Bd.update({ ns: i.namespace });
              var o = ir.toDocument(n);
              document.title = o.title;
            }
          });
      })();
      return Promise.resolve(t && t.then ? t.then(function () {}) : void 0);
    } catch (n) {
      return Promise.reject(n);
    }
  },
  zd = $i,
  bg = {
    __proto__: null,
    update: aa,
    nextTick: function () {
      return new Promise(function (r) {
        window.requestAnimationFrame(r);
      });
    },
    pathToRegexp: zd
  },
  Hd = function () {
    return window.location.origin;
  },
  Zs = function (r) {
    return r === void 0 && (r = window.location.href), ca(r).port;
  },
  ca = function (r) {
    var e,
      t = r.match(/:\d+/);
    if (t === null) /^http/.test(r) && (e = 80), /^https/.test(r) && (e = 443);
    else {
      var n = t[0].substring(1);
      e = parseInt(n, 10);
    }
    var i,
      s = r.replace(Hd(), ''),
      o = {},
      a = s.indexOf('#');
    a >= 0 && ((i = s.slice(a + 1)), (s = s.slice(0, a)));
    var c = s.indexOf('?');
    return (
      c >= 0 && ((o = Gd(s.slice(c + 1))), (s = s.slice(0, c))),
      { hash: i, path: s, port: e, query: o }
    );
  },
  Gd = function (r) {
    return r.split('&').reduce(function (e, t) {
      var n = t.split('=');
      return (e[n[0]] = n[1]), e;
    }, {});
  },
  Gc = function (r) {
    return (
      r === void 0 && (r = window.location.href),
      r.replace(/(\/#.*|\/|#.*)$/, '')
    );
  },
  Eg = {
    __proto__: null,
    getHref: function () {
      return window.location.href;
    },
    getOrigin: Hd,
    getPort: Zs,
    getPath: function (r) {
      return r === void 0 && (r = window.location.href), ca(r).path;
    },
    parse: ca,
    parseQuery: Gd,
    clean: Gc
  };
function Tg(r, e, t) {
  return (
    e === void 0 && (e = 2e3),
    new Promise(function (n, i) {
      var s = new XMLHttpRequest();
      (s.onreadystatechange = function () {
        if (s.readyState === XMLHttpRequest.DONE) {
          if (s.status === 200) n(s.responseText);
          else if (s.status) {
            var o = { status: s.status, statusText: s.statusText };
            t(r, o), i(o);
          }
        }
      }),
        (s.ontimeout = function () {
          var o = new Error('Timeout error [' + e + ']');
          t(r, o), i(o);
        }),
        (s.onerror = function () {
          var o = new Error('Fetch error');
          t(r, o), i(o);
        }),
        s.open('GET', r),
        (s.timeout = e),
        s.setRequestHeader(
          'Accept',
          'text/html,application/xhtml+xml,application/xml'
        ),
        s.setRequestHeader('x-barba', 'yes'),
        s.send();
    })
  );
}
var Ag = function (r) {
  return (
    !!r &&
    (typeof r == 'object' || typeof r == 'function') &&
    typeof r.then == 'function'
  );
};
function Xr(r, e) {
  return (
    e === void 0 && (e = {}),
    function () {
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      var s = !1,
        o = new Promise(function (a, c) {
          e.async = function () {
            return (
              (s = !0),
              function (h, f) {
                h ? c(h) : a(f);
              }
            );
          };
          var l = r.apply(e, n);
          s || (Ag(l) ? l.then(a, c) : a(l));
        });
      return o;
    }
  );
}
var Si = new ((function (r) {
    function e() {
      var n;
      return (
        ((n = r.call(this) || this).logger = new nr('@barba/core')),
        (n.all = [
          'ready',
          'page',
          'reset',
          'currentAdded',
          'currentRemoved',
          'nextAdded',
          'nextRemoved',
          'beforeOnce',
          'once',
          'afterOnce',
          'before',
          'beforeLeave',
          'leave',
          'afterLeave',
          'beforeEnter',
          'enter',
          'afterEnter',
          'after'
        ]),
        (n.registered = new Map()),
        n.init(),
        n
      );
    }
    ga(e, r);
    var t = e.prototype;
    return (
      (t.init = function () {
        var n = this;
        this.registered.clear(),
          this.all.forEach(function (i) {
            n[i] ||
              (n[i] = function (s, o) {
                n.registered.has(i) || n.registered.set(i, new Set()),
                  n.registered.get(i).add({ ctx: o || {}, fn: s });
              });
          });
      }),
      (t.do = function (n) {
        for (
          var i = this,
            s = arguments.length,
            o = new Array(s > 1 ? s - 1 : 0),
            a = 1;
          a < s;
          a++
        )
          o[a - 1] = arguments[a];
        if (this.registered.has(n)) {
          var c = Promise.resolve();
          return (
            this.registered.get(n).forEach(function (l) {
              c = c.then(function () {
                return Xr(l.fn, l.ctx).apply(void 0, o);
              });
            }),
            c.catch(function (l) {
              i.logger.debug('Hook error [' + n + ']'), i.logger.error(l);
            })
          );
        }
        return Promise.resolve();
      }),
      (t.clear = function () {
        var n = this;
        this.all.forEach(function (i) {
          delete n[i];
        }),
          this.init();
      }),
      (t.help = function () {
        this.logger.info('Available hooks: ' + this.all.join(','));
        var n = [];
        this.registered.forEach(function (i, s) {
          return n.push(s);
        }),
          this.logger.info('Registered hooks: ' + n.join(','));
      }),
      e
    );
  })(gg))(),
  Vd = (function () {
    function r(e) {
      if (((this.P = []), typeof e == 'boolean')) this.g = e;
      else {
        var t = Array.isArray(e) ? e : [e];
        this.P = t.map(function (n) {
          return zd(n);
        });
      }
    }
    return (
      (r.prototype.checkHref = function (e) {
        if (typeof this.g == 'boolean') return this.g;
        var t = ca(e).path;
        return this.P.some(function (n) {
          return n.exec(t) !== null;
        });
      }),
      r
    );
  })(),
  wg = (function (r) {
    function e(n) {
      var i;
      return ((i = r.call(this, n) || this).k = new Map()), i;
    }
    ga(e, r);
    var t = e.prototype;
    return (
      (t.set = function (n, i, s) {
        return (
          this.k.set(n, { action: s, request: i }), { action: s, request: i }
        );
      }),
      (t.get = function (n) {
        return this.k.get(n);
      }),
      (t.getRequest = function (n) {
        return this.k.get(n).request;
      }),
      (t.getAction = function (n) {
        return this.k.get(n).action;
      }),
      (t.has = function (n) {
        return !this.checkHref(n) && this.k.has(n);
      }),
      (t.delete = function (n) {
        return this.k.delete(n);
      }),
      (t.update = function (n, i) {
        var s = tr({}, this.k.get(n), {}, i);
        return this.k.set(n, s), s;
      }),
      e
    );
  })(Vd),
  Rg = function () {
    return !window.history.pushState;
  },
  Cg = function (r) {
    return !r.el || !r.href;
  },
  Lg = function (r) {
    var e = r.event;
    return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey;
  },
  Pg = function (r) {
    var e = r.el;
    return e.hasAttribute('target') && e.target === '_blank';
  },
  Dg = function (r) {
    var e = r.el;
    return (
      (e.protocol !== void 0 && window.location.protocol !== e.protocol) ||
      (e.hostname !== void 0 && window.location.hostname !== e.hostname)
    );
  },
  Ig = function (r) {
    var e = r.el;
    return e.port !== void 0 && Zs() !== Zs(e.href);
  },
  Og = function (r) {
    var e = r.el;
    return e.getAttribute && typeof e.getAttribute('download') == 'string';
  },
  Ug = function (r) {
    return r.el.hasAttribute(zn.prefix + '-' + zn.prevent);
  },
  Ng = function (r) {
    return !!r.el.closest('[' + zn.prefix + '-' + zn.prevent + '="all"]');
  },
  Fg = function (r) {
    var e = r.href;
    return Gc(e) === Gc() && Zs(e) === Zs();
  },
  kg = (function (r) {
    function e(n) {
      var i;
      return (
        ((i = r.call(this, n) || this).suite = []),
        (i.tests = new Map()),
        i.init(),
        i
      );
    }
    ga(e, r);
    var t = e.prototype;
    return (
      (t.init = function () {
        this.add('pushState', Rg),
          this.add('exists', Cg),
          this.add('newTab', Lg),
          this.add('blank', Pg),
          this.add('corsDomain', Dg),
          this.add('corsPort', Ig),
          this.add('download', Og),
          this.add('preventSelf', Ug),
          this.add('preventAll', Ng),
          this.add('sameUrl', Fg, !1);
      }),
      (t.add = function (n, i, s) {
        s === void 0 && (s = !0), this.tests.set(n, i), s && this.suite.push(n);
      }),
      (t.run = function (n, i, s, o) {
        return this.tests.get(n)({ el: i, event: s, href: o });
      }),
      (t.checkLink = function (n, i, s) {
        var o = this;
        return this.suite.some(function (a) {
          return o.run(a, n, i, s);
        });
      }),
      e
    );
  })(Vd),
  Fa = (function (r) {
    function e(t, n) {
      var i;
      n === void 0 && (n = 'Barba error');
      for (
        var s = arguments.length, o = new Array(s > 2 ? s - 2 : 0), a = 2;
        a < s;
        a++
      )
        o[a - 2] = arguments[a];
      return (
        ((i = r.call.apply(r, [this].concat(o)) || this).error = t),
        (i.label = n),
        Error.captureStackTrace &&
          Error.captureStackTrace(
            (function (c) {
              if (c === void 0)
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              return c;
            })(i),
            e
          ),
        (i.name = 'BarbaError'),
        i
      );
    }
    return ga(e, r), e;
  })(Od(Error)),
  Bg = (function () {
    function r(t) {
      t === void 0 && (t = []),
        (this.logger = new nr('@barba/core')),
        (this.all = []),
        (this.page = []),
        (this.once = []),
        (this.A = [
          { name: 'namespace', type: 'strings' },
          { name: 'custom', type: 'function' }
        ]),
        t && (this.all = this.all.concat(t)),
        this.update();
    }
    var e = r.prototype;
    return (
      (e.add = function (t, n) {
        switch (t) {
          case 'rule':
            this.A.splice(n.position || 0, 0, n.value);
            break;
          case 'transition':
          default:
            this.all.push(n);
        }
        this.update();
      }),
      (e.resolve = function (t, n) {
        var i = this;
        n === void 0 && (n = {});
        var s = n.once ? this.once : this.page;
        s = s.filter(
          n.self
            ? function (u) {
                return u.name && u.name === 'self';
              }
            : function (u) {
                return !u.name || u.name !== 'self';
              }
        );
        var o = new Map(),
          a = s.find(function (u) {
            var p = !0,
              _ = {};
            return (
              !(!n.self || u.name !== 'self') ||
              (i.A.reverse().forEach(function (g) {
                p &&
                  ((p = i.R(u, g, t, _)),
                  u.from &&
                    u.to &&
                    (p = i.R(u, g, t, _, 'from') && i.R(u, g, t, _, 'to')),
                  u.from && !u.to && (p = i.R(u, g, t, _, 'from')),
                  !u.from && u.to && (p = i.R(u, g, t, _, 'to')));
              }),
              o.set(u, _),
              p)
            );
          }),
          c = o.get(a),
          l = [];
        if ((l.push(n.once ? 'once' : 'page'), n.self && l.push('self'), c)) {
          var h,
            f = [a];
          Object.keys(c).length > 0 && f.push(c),
            (h = this.logger).info.apply(
              h,
              ['Transition found [' + l.join(',') + ']'].concat(f)
            );
        } else this.logger.info('No transition found [' + l.join(',') + ']');
        return a;
      }),
      (e.update = function () {
        var t = this;
        (this.all = this.all
          .map(function (n) {
            return t.T(n);
          })
          .sort(function (n, i) {
            return n.priority - i.priority;
          })
          .reverse()
          .map(function (n) {
            return delete n.priority, n;
          })),
          (this.page = this.all.filter(function (n) {
            return n.leave !== void 0 || n.enter !== void 0;
          })),
          (this.once = this.all.filter(function (n) {
            return n.once !== void 0;
          }));
      }),
      (e.R = function (t, n, i, s, o) {
        var a = !0,
          c = !1,
          l = t,
          h = n.name,
          f = h,
          u = h,
          p = h,
          _ = o ? l[o] : l,
          g = o === 'to' ? i.next : i.current;
        if (o ? _ && _[h] : _[h]) {
          switch (n.type) {
            case 'strings':
            default:
              var d = Array.isArray(_[f]) ? _[f] : [_[f]];
              g[f] && d.indexOf(g[f]) !== -1 && (c = !0),
                d.indexOf(g[f]) === -1 && (a = !1);
              break;
            case 'object':
              var m = Array.isArray(_[u]) ? _[u] : [_[u]];
              g[u]
                ? (g[u].name && m.indexOf(g[u].name) !== -1 && (c = !0),
                  m.indexOf(g[u].name) === -1 && (a = !1))
                : (a = !1);
              break;
            case 'function':
              _[p](i) ? (c = !0) : (a = !1);
          }
          c && (o ? ((s[o] = s[o] || {}), (s[o][h] = l[o][h])) : (s[h] = l[h]));
        }
        return a;
      }),
      (e.O = function (t, n, i) {
        var s = 0;
        return (
          (t[n] || (t.from && t.from[n]) || (t.to && t.to[n])) &&
            ((s += Math.pow(10, i)),
            t.from && t.from[n] && (s += 1),
            t.to && t.to[n] && (s += 2)),
          s
        );
      }),
      (e.T = function (t) {
        var n = this;
        t.priority = 0;
        var i = 0;
        return (
          this.A.forEach(function (s, o) {
            i += n.O(t, s.name, o + 1);
          }),
          (t.priority = i),
          t
        );
      }),
      r
    );
  })(),
  zg = (function () {
    function r(t) {
      t === void 0 && (t = []),
        (this.logger = new nr('@barba/core')),
        (this.S = !1),
        (this.store = new Bg(t));
    }
    var e = r.prototype;
    return (
      (e.get = function (t, n) {
        return this.store.resolve(t, n);
      }),
      (e.doOnce = function (t) {
        var n = t.data,
          i = t.transition;
        try {
          var s = function () {
              o.S = !1;
            },
            o = this,
            a = i || {};
          o.S = !0;
          var c = Hr(
            function () {
              return Promise.resolve(o.j('beforeOnce', n, a)).then(function () {
                return Promise.resolve(o.once(n, a)).then(function () {
                  return Promise.resolve(o.j('afterOnce', n, a)).then(
                    function () {}
                  );
                });
              });
            },
            function (l) {
              (o.S = !1),
                o.logger.debug('Transition error [before/after/once]'),
                o.logger.error(l);
            }
          );
          return Promise.resolve(c && c.then ? c.then(s) : s());
        } catch (l) {
          return Promise.reject(l);
        }
      }),
      (e.doPage = function (t) {
        var n = t.data,
          i = t.transition,
          s = t.page,
          o = t.wrapper;
        try {
          var a = function (p) {
              if (c) return p;
              l.S = !1;
            },
            c = !1,
            l = this,
            h = i || {},
            f = h.sync === !0 || !1;
          l.S = !0;
          var u = Hr(
            function () {
              function p() {
                return Promise.resolve(l.j('before', n, h)).then(function () {
                  var g = !1;
                  function d(y) {
                    return g
                      ? y
                      : Promise.resolve(l.remove(n)).then(function () {
                          return Promise.resolve(l.j('after', n, h)).then(
                            function () {}
                          );
                        });
                  }
                  var m = (function () {
                    if (f)
                      return Hr(
                        function () {
                          return Promise.resolve(l.add(n, o)).then(function () {
                            return Promise.resolve(
                              l.j('beforeLeave', n, h)
                            ).then(function () {
                              return Promise.resolve(
                                l.j('beforeEnter', n, h)
                              ).then(function () {
                                return Promise.resolve(
                                  Promise.all([l.leave(n, h), l.enter(n, h)])
                                ).then(function () {
                                  return Promise.resolve(
                                    l.j('afterLeave', n, h)
                                  ).then(function () {
                                    return Promise.resolve(
                                      l.j('afterEnter', n, h)
                                    ).then(function () {});
                                  });
                                });
                              });
                            });
                          });
                        },
                        function (S) {
                          if (l.M(S))
                            throw new Fa(S, 'Transition error [sync]');
                        }
                      );
                    var y = function (S) {
                        return g
                          ? S
                          : Hr(
                              function () {
                                var b = (function () {
                                  if (v !== !1)
                                    return Promise.resolve(l.add(n, o)).then(
                                      function () {
                                        return Promise.resolve(
                                          l.j('beforeEnter', n, h)
                                        ).then(function () {
                                          return Promise.resolve(
                                            l.enter(n, h, v)
                                          ).then(function () {
                                            return Promise.resolve(
                                              l.j('afterEnter', n, h)
                                            ).then(function () {});
                                          });
                                        });
                                      }
                                    );
                                })();
                                if (b && b.then) return b.then(function () {});
                              },
                              function (b) {
                                if (l.M(b))
                                  throw new Fa(
                                    b,
                                    'Transition error [before/after/enter]'
                                  );
                              }
                            );
                      },
                      v = !1,
                      x = Hr(
                        function () {
                          return Promise.resolve(l.j('beforeLeave', n, h)).then(
                            function () {
                              return Promise.resolve(
                                Promise.all([l.leave(n, h), aa(s, n)]).then(
                                  function (S) {
                                    return S[0];
                                  }
                                )
                              ).then(function (S) {
                                return (
                                  (v = S),
                                  Promise.resolve(l.j('afterLeave', n, h)).then(
                                    function () {}
                                  )
                                );
                              });
                            }
                          );
                        },
                        function (S) {
                          if (l.M(S))
                            throw new Fa(
                              S,
                              'Transition error [before/after/leave]'
                            );
                        }
                      );
                    return x && x.then ? x.then(y) : y(x);
                  })();
                  return m && m.then ? m.then(d) : d(m);
                });
              }
              var _ = (function () {
                if (f) return Promise.resolve(aa(s, n)).then(function () {});
              })();
              return _ && _.then ? _.then(p) : p();
            },
            function (p) {
              throw (
                ((l.S = !1),
                p.name && p.name === 'BarbaError'
                  ? (l.logger.debug(p.label), l.logger.error(p.error), p)
                  : (l.logger.debug('Transition error [page]'),
                    l.logger.error(p),
                    p))
              );
            }
          );
          return Promise.resolve(u && u.then ? u.then(a) : a(u));
        } catch (p) {
          return Promise.reject(p);
        }
      }),
      (e.once = function (t, n) {
        try {
          return Promise.resolve(Si.do('once', t, n)).then(function () {
            return n.once ? Xr(n.once, n)(t) : Promise.resolve();
          });
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.leave = function (t, n) {
        try {
          return Promise.resolve(Si.do('leave', t, n)).then(function () {
            return n.leave ? Xr(n.leave, n)(t) : Promise.resolve();
          });
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.enter = function (t, n, i) {
        try {
          return Promise.resolve(Si.do('enter', t, n)).then(function () {
            return n.enter ? Xr(n.enter, n)(t, i) : Promise.resolve();
          });
        } catch (s) {
          return Promise.reject(s);
        }
      }),
      (e.add = function (t, n) {
        try {
          return (
            ir.addContainer(t.next.container, n),
            Si.do('nextAdded', t),
            Promise.resolve()
          );
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.remove = function (t) {
        try {
          return (
            ir.removeContainer(t.current.container),
            Si.do('currentRemoved', t),
            Promise.resolve()
          );
        } catch (n) {
          return Promise.reject(n);
        }
      }),
      (e.M = function (t) {
        return t.message
          ? !/Timeout error|Fetch error/.test(t.message)
          : !t.status;
      }),
      (e.j = function (t, n, i) {
        try {
          return Promise.resolve(Si.do(t, n, i)).then(function () {
            return i[t] ? Xr(i[t], i)(n) : Promise.resolve();
          });
        } catch (s) {
          return Promise.reject(s);
        }
      }),
      Rl(r, [
        {
          key: 'isRunning',
          get: function () {
            return this.S;
          },
          set: function (t) {
            this.S = t;
          }
        },
        {
          key: 'hasOnce',
          get: function () {
            return this.store.once.length > 0;
          }
        },
        {
          key: 'hasSelf',
          get: function () {
            return this.store.all.some(function (t) {
              return t.name === 'self';
            });
          }
        },
        {
          key: 'shouldWait',
          get: function () {
            return this.store.all.some(function (t) {
              return (t.to && !t.to.route) || t.sync;
            });
          }
        }
      ]),
      r
    );
  })(),
  Hg = (function () {
    function r(e) {
      var t = this;
      (this.names = ['beforeLeave', 'afterLeave', 'beforeEnter', 'afterEnter']),
        (this.byNamespace = new Map()),
        e.length !== 0 &&
          (e.forEach(function (n) {
            t.byNamespace.set(n.namespace, n);
          }),
          this.names.forEach(function (n) {
            Si[n](t.L(n));
          }));
    }
    return (
      (r.prototype.L = function (e) {
        var t = this;
        return function (n) {
          var i = e.match(/enter/i) ? n.next : n.current,
            s = t.byNamespace.get(i.namespace);
          return s && s[e] ? Xr(s[e], s)(n) : Promise.resolve();
        };
      }),
      r
    );
  })();
Element.prototype.matches ||
  (Element.prototype.matches =
    Element.prototype.msMatchesSelector ||
    Element.prototype.webkitMatchesSelector),
  Element.prototype.closest ||
    (Element.prototype.closest = function (r) {
      var e = this;
      do {
        if (e.matches(r)) return e;
        e = e.parentElement || e.parentNode;
      } while (e !== null && e.nodeType === 1);
      return null;
    });
var Gg = {
    container: null,
    html: '',
    namespace: '',
    url: { hash: '', href: '', path: '', port: null, query: {} }
  },
  co = new ((function () {
    function r() {
      (this.version = mg),
        (this.schemaPage = Gg),
        (this.Logger = nr),
        (this.logger = new nr('@barba/core')),
        (this.plugins = []),
        (this.hooks = Si),
        (this.dom = ir),
        (this.helpers = bg),
        (this.history = Bd),
        (this.request = Tg),
        (this.url = Eg);
    }
    var e = r.prototype;
    return (
      (e.use = function (t, n) {
        var i = this.plugins;
        i.indexOf(t) > -1
          ? this.logger.warn('Plugin [' + t.name + '] already installed.')
          : typeof t.install == 'function'
          ? (t.install(this, n), i.push(t))
          : this.logger.warn(
              'Plugin [' + t.name + '] has no "install" method.'
            );
      }),
      (e.init = function (t) {
        var n = t === void 0 ? {} : t,
          i = n.transitions,
          s = i === void 0 ? [] : i,
          o = n.views,
          a = o === void 0 ? [] : o,
          c = n.schema,
          l = c === void 0 ? zn : c,
          h = n.requestError,
          f = n.timeout,
          u = f === void 0 ? 2e3 : f,
          p = n.cacheIgnore,
          _ = p !== void 0 && p,
          g = n.prefetchIgnore,
          d = g !== void 0 && g,
          m = n.preventRunning,
          y = m !== void 0 && m,
          v = n.prevent,
          x = v === void 0 ? null : v,
          S = n.debug,
          b = n.logLevel;
        if (
          (nr.setLevel(
            (S !== void 0 && S) === !0 ? 'debug' : b === void 0 ? 'off' : b
          ),
          this.logger.info(this.version),
          Object.keys(l).forEach(function (M) {
            zn[M] && (zn[M] = l[M]);
          }),
          (this.$ = h),
          (this.timeout = u),
          (this.cacheIgnore = _),
          (this.prefetchIgnore = d),
          (this.preventRunning = y),
          (this._ = this.dom.getWrapper()),
          !this._)
        )
          throw new Error('[@barba/core] No Barba wrapper found');
        this._.setAttribute('aria-live', 'polite'), this.q();
        var T = this.data.current;
        if (!T.container)
          throw new Error('[@barba/core] No Barba container found');
        if (
          ((this.cache = new wg(_)),
          (this.prevent = new kg(d)),
          (this.transitions = new zg(s)),
          (this.views = new Hg(a)),
          x !== null)
        ) {
          if (typeof x != 'function')
            throw new Error('[@barba/core] Prevent should be a function');
          this.prevent.add('preventCustom', x);
        }
        this.history.init(T.url.href, T.namespace),
          (this.B = this.B.bind(this)),
          (this.U = this.U.bind(this)),
          (this.D = this.D.bind(this)),
          this.F(),
          this.plugins.forEach(function (M) {
            return M.init();
          });
        var C = this.data;
        (C.trigger = 'barba'),
          (C.next = C.current),
          (C.current = tr({}, this.schemaPage)),
          this.hooks.do('ready', C),
          this.once(C),
          this.q();
      }),
      (e.destroy = function () {
        this.q(),
          this.H(),
          this.history.clear(),
          this.hooks.clear(),
          (this.plugins = []);
      }),
      (e.force = function (t) {
        window.location.assign(t);
      }),
      (e.go = function (t, n, i) {
        var s;
        if ((n === void 0 && (n = 'barba'), this.transitions.isRunning))
          this.force(t);
        else if (
          !(s =
            n === 'popstate'
              ? this.history.current &&
                this.url.getPath(this.history.current.url) ===
                  this.url.getPath(t)
              : this.prevent.run('sameUrl', null, null, t)) ||
          this.transitions.hasSelf
        )
          return (
            (n = this.history.change(t, n, i)),
            i && (i.stopPropagation(), i.preventDefault()),
            this.page(t, n, s)
          );
      }),
      (e.once = function (t) {
        try {
          var n = this;
          return Promise.resolve(n.hooks.do('beforeEnter', t)).then(
            function () {
              function i() {
                return Promise.resolve(n.hooks.do('afterEnter', t)).then(
                  function () {}
                );
              }
              var s = (function () {
                if (n.transitions.hasOnce) {
                  var o = n.transitions.get(t, { once: !0 });
                  return Promise.resolve(
                    n.transitions.doOnce({ transition: o, data: t })
                  ).then(function () {});
                }
              })();
              return s && s.then ? s.then(i) : i();
            }
          );
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.page = function (t, n, i) {
        try {
          var s = function () {
              var l = o.data;
              return Promise.resolve(o.hooks.do('page', l)).then(function () {
                var h = Hr(
                  function () {
                    var f = o.transitions.get(l, { once: !1, self: i });
                    return Promise.resolve(
                      o.transitions.doPage({
                        data: l,
                        page: a,
                        transition: f,
                        wrapper: o._
                      })
                    ).then(function () {
                      o.q();
                    });
                  },
                  function () {
                    nr.getLevel() === 0 && o.force(l.current.url.href);
                  }
                );
                if (h && h.then) return h.then(function () {});
              });
            },
            o = this;
          (o.data.next.url = tr({ href: t }, o.url.parse(t))),
            (o.data.trigger = n);
          var a = o.cache.has(t)
              ? o.cache.update(t, { action: 'click' }).request
              : o.cache.set(
                  t,
                  o.request(t, o.timeout, o.onRequestError.bind(o, n)),
                  'click'
                ).request,
            c = (function () {
              if (o.transitions.shouldWait)
                return Promise.resolve(aa(a, o.data)).then(function () {});
            })();
          return Promise.resolve(c && c.then ? c.then(s) : s());
        } catch (l) {
          return Promise.reject(l);
        }
      }),
      (e.onRequestError = function (t) {
        this.transitions.isRunning = !1;
        for (
          var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1;
          s < n;
          s++
        )
          i[s - 1] = arguments[s];
        var o = i[0],
          a = i[1],
          c = this.cache.getAction(o);
        return (
          this.cache.delete(o),
          !(
            (this.$ && this.$(t, c, o, a) === !1) ||
            (c === 'click' && this.force(o), 1)
          )
        );
      }),
      (e.prefetch = function (t) {
        var n = this;
        this.cache.has(t) ||
          this.cache.set(
            t,
            this.request(
              t,
              this.timeout,
              this.onRequestError.bind(this, 'barba')
            ).catch(function (i) {
              n.logger.error(i);
            }),
            'prefetch'
          );
      }),
      (e.F = function () {
        this.prefetchIgnore !== !0 &&
          (document.addEventListener('mouseover', this.B),
          document.addEventListener('touchstart', this.B)),
          document.addEventListener('click', this.U),
          window.addEventListener('popstate', this.D);
      }),
      (e.H = function () {
        this.prefetchIgnore !== !0 &&
          (document.removeEventListener('mouseover', this.B),
          document.removeEventListener('touchstart', this.B)),
          document.removeEventListener('click', this.U),
          window.removeEventListener('popstate', this.D);
      }),
      (e.B = function (t) {
        var n = this,
          i = this.I(t);
        if (i) {
          var s = this.dom.getHref(i);
          this.prevent.checkHref(s) ||
            this.cache.has(s) ||
            this.cache.set(
              s,
              this.request(
                s,
                this.timeout,
                this.onRequestError.bind(this, i)
              ).catch(function (o) {
                n.logger.error(o);
              }),
              'enter'
            );
        }
      }),
      (e.U = function (t) {
        var n = this.I(t);
        if (n)
          return this.transitions.isRunning && this.preventRunning
            ? (t.preventDefault(), void t.stopPropagation())
            : void this.go(this.dom.getHref(n), n, t);
      }),
      (e.D = function (t) {
        this.go(this.url.getHref(), 'popstate', t);
      }),
      (e.I = function (t) {
        for (var n = t.target; n && !this.dom.getHref(n); ) n = n.parentNode;
        if (n && !this.prevent.checkLink(n, t, this.dom.getHref(n))) return n;
      }),
      (e.q = function () {
        var t = this.url.getHref(),
          n = {
            container: this.dom.getContainer(),
            html: this.dom.getHtml(),
            namespace: this.dom.getNamespace(),
            url: tr({ href: t }, this.url.parse(t))
          };
        (this.C = {
          current: n,
          next: tr({}, this.schemaPage),
          trigger: void 0
        }),
          this.hooks.do('reset', this.data);
      }),
      Rl(r, [
        {
          key: 'data',
          get: function () {
            return this.C;
          }
        },
        {
          key: 'wrapper',
          get: function () {
            return this._;
          }
        }
      ]),
      r
    );
  })())();
const Vg = {
    namespace: 'play',
    beforeEnter() {},
    afterEnter() {},
    beforeLeave() {}
  },
  Wg = (r) => ({
    name: 'play-transition',
    sync: !0,
    leave({ current: e }) {
      return new Promise((t) => {
        const n = e.container.querySelectorAll('.js-title .char > span'),
          i = e.container.querySelectorAll('.js-subtitle'),
          s = e.container.querySelectorAll('.js-content');
        Z.to(n, { y: '100%', autoAlpha: 0, duration: 0.4 }),
          Z.to(i, { autoAlpha: 0, duration: 0.4 }),
          Z.to(s, { autoAlpha: 0, duration: 0.4, onComplete: () => t() });
      });
    },
    enter() {
      Z.to('#js-background', { scaleX: 1, duration: 1.2 }),
        Z.to('#js-background', { x: 0, autoAlpha: 1 }),
        r.call('changeStatus', ['pending'], 'webgl'),
        r.call('moveScene', '', 'webgl');
    },
    once() {
      r.call('changeStatus', ['pending'], 'webgl'),
        Z.set('#js-background', { x: 0, scaleX: 1 }),
        Z.to('#js-background', { autoAlpha: 1 });
    },
    to: { namespace: ['play'] }
  });
function si(r, e) {
  e = e || {};
  const t = (e == null ? void 0 : e.tagName) ?? 'span',
    n = e.type || 'letter',
    i = e.nesting || 1,
    s = e.classPrefix != null ? e.classPrefix : n;
  let o = 1;
  function a(c) {
    const l = (c == null ? void 0 : c.parentNode) ?? document,
      h = c.nodeValue || '',
      f = n === 'letter' ? h : h.split(' ').map((d) => d + ' '),
      u = f.length;
    let p = -1;
    const _ = [],
      g = [];
    for (let d = 1; d < i; d++) _.push(`<${t}>`), g.push(`</${t}>`);
    for (; ++p < u; ) {
      const d = document.createElement(t);
      s && ((d.className = s + o), o++),
        (d.innerHTML = _.join(' ') + f[p] + g.join(' ')),
        l.insertBefore(d, c);
    }
    l.removeChild(c);
  }
  (function c(l) {
    if (l.nodeType === Node.TEXT_NODE) return a(l);
    const h = Array.prototype.slice.call(l.childNodes),
      f = h.length;
    if (f === 1 && h[0].nodeType === Node.TEXT_NODE) return a(h[0]);
    let u = -1;
    for (; ++u < f; ) c(h[u]);
  })(r);
}
const qg = { namespace: 'home', beforeEnter() {}, afterEnter() {} },
  Th = {},
  Ah = function (r) {
    r.call('changeStatus', ['init'], 'webgl'),
      r.call('moveScene', '', 'webgl'),
      r.call('appear', '', 'webgl');
  },
  lo = function (r) {
    const e = (r == null ? void 0 : r.container) ?? document;
    (Th.titles = [...e.querySelectorAll('.js-title')]),
      Z.set(e.querySelector('.js-title'), { autoAlpha: 1 }),
      Z.set('#js-background', { transformOrigin: 'left' }),
      Th.titles.forEach((t) => {
        si(t, {
          tagName: 'span',
          type: 'word',
          nesting: 1,
          classPrefix: 'word word'
        }),
          si(t, {
            tagName: 'span',
            type: 'letter',
            nesting: 2,
            classPrefix: 'char char'
          });
      }),
      Z.to('#js-background', {
        x: '50%',
        scaleY: 1,
        autoAlpha: 1,
        scaleX: 1.1,
        duration: 1
      }),
      Z.to(e.querySelectorAll('.js-title .char > span'), {
        y: '-10%',
        duration: 0.4,
        stagger: 0.015,
        delay: 0.6
      }),
      Z.to(e.querySelector('.js-subtitle'), {
        autoAlpha: 1,
        duration: 1,
        delay: 1
      }),
      Z.to(e.querySelector('.js-content'), {
        autoAlpha: 1,
        duration: 1,
        delay: 1
      });
  },
  Xg = (r) => [
    {
      name: 'home-transition-play',
      sync: !0,
      from: { namespace: ['play'] },
      to: { namespace: ['home'] },
      leave() {
        return Promise.all([
          r.call('disappear', '', 'Gameoptions'),
          r.call('disappear', '', 'Gameplayers', 'me'),
          r.call('disappear', '', 'Gameplayers', 'rival'),
          r.call('disappear', '', 'Gamecontrols'),
          r.call('disappear', '', 'gamecategory'),
          r.call('disappear', '', 'Gameboard')
        ]);
      },
      enter({ next: e }) {
        lo(e), Ah(r);
      }
    },
    {
      name: 'home-transition-about',
      from: { namespace: ['about'] },
      to: { namespace: ['home'] },
      leave({ current: e }) {
        const t = new Promise((n) => {
          const i = e.container.querySelectorAll('.js-title .char > span'),
            s = e.container.querySelectorAll('.js-subtitle'),
            o = e.container.querySelectorAll('.js-content');
          i && Z.to(i, { y: '100%', autoAlpha: 0, duration: 0.4 }),
            s && Z.to(s, { autoAlpha: 0, duration: 0.4 }),
            o &&
              Z.to(o, { autoAlpha: 0, duration: 0.4, onComplete: () => n() });
        });
        return Promise.all([t]);
      },
      enter({ next: e }) {
        lo(e);
      }
    },
    {
      name: 'home-transition-dashboard',
      sync: !0,
      from: { namespace: ['dashboard'] },
      to: { namespace: ['home'] },
      leave({ current: e }) {
        const t = new Promise((n) => {
          const i = e.container.querySelector('.js-dashboardheader'),
            s = e.container.querySelector('.js-dashboard'),
            o = e.container.querySelectorAll('.js-dashboard article');
          Z.to(i, { autoAlpha: 0, duration: 0.4 }),
            Z.to(s, { '--sidepane': '100%' }),
            Z.to(o, { autoAlpha: 0, duration: 0.4, onComplete: () => n() });
        });
        return Promise.all([t]);
      },
      enter({ next: e }) {
        lo(e), Ah(r);
      }
    },
    {
      to: { namespace: ['home'] },
      once() {
        lo();
      }
    }
  ],
  jg = { namespace: 'about', beforeEnter() {}, afterEnter() {} },
  ho = {},
  Yg = (r) => [
    {
      name: 'generic-transition',
      sync: !0,
      to: { namespace: ['generic'] },
      leave() {
        return Promise.all([
          r.call('disappear', '', 'Gameoptions'),
          r.call('disappear', '', 'Gameplayers', 'me'),
          r.call('disappear', '', 'Gameplayers', 'rival'),
          r.call('disappear', '', 'gamecategory'),
          r.call('disappear', '', 'Gamecontrols')
        ]);
      },
      enter() {
        (ho.titles = [...document.querySelectorAll('.js-title')]),
          Z.set('.js-title', { autoAlpha: 1 }),
          Z.set('#js-background', { transformOrigin: 'left' }),
          ho.titles.forEach((e) => {
            si(e, {
              tagName: 'span',
              type: 'word',
              nesting: 1,
              classPrefix: 'word word'
            }),
              si(e, {
                tagName: 'span',
                type: 'letter',
                nesting: 2,
                classPrefix: 'char char'
              });
          }),
          Z.to('#js-background', {
            x: '50%',
            scaleY: 1,
            scaleX: 1.1,
            duration: 1
          }),
          Z.to('.js-title  .char > span', {
            y: '0%',
            stagger: 0.04,
            duration: 0.4,
            delay: 0.7
          }),
          Z.to('.js-subtitle', { autoAlpha: 1, duration: 1, delay: 0.8 }),
          Z.to('.js-content', { autoAlpha: 1, duration: 1, delay: 0.8 });
      }
    },
    {
      to: { namespace: ['generic'] },
      once() {
        (ho.titles = [...document.querySelectorAll('.js-title')]),
          ho.titles.forEach((e) => {
            si(e, {
              tagName: 'span',
              type: 'word',
              nesting: 1,
              classPrefix: 'word word'
            }),
              si(e, {
                tagName: 'span',
                type: 'letter',
                nesting: 2,
                classPrefix: 'char char'
              });
          }),
          Z.to('#js-background', { autoAlpha: 1, x: '50%' }),
          Z.set('.js-title', { autoAlpha: 1 }),
          Z.to('.js-title  .char > span', {
            y: '0%',
            stagger: 0.04,
            duration: 0.4
          }),
          Z.to('.js-subtitle', { autoAlpha: 1, duration: 1, delay: 0.6 }),
          Z.to('.js-content', { autoAlpha: 1, duration: 1, delay: 0.6 });
      }
    }
  ],
  Kg = { namespace: 'about', beforeEnter() {}, afterEnter() {} },
  wh = function (r) {
    r.call('changeStatus', ['init'], 'webgl'),
      r.call('moveScene', '', 'webgl'),
      r.call('appear', '', 'webgl');
  },
  uo = function (r) {
    const e = (r == null ? void 0 : r.container) ?? document;
    (Rh.titles = [...e.querySelectorAll('.js-title')]),
      Z.set(e.querySelectorAll('.js-title'), { autoAlpha: 1 }),
      Z.set('#js-background', { transformOrigin: 'left' }),
      Rh.titles.forEach((t) => {
        si(t, {
          tagName: 'span',
          type: 'word',
          nesting: 1,
          classPrefix: 'word word'
        }),
          si(t, {
            tagName: 'span',
            type: 'letter',
            nesting: 2,
            classPrefix: 'char char'
          });
      }),
      Z.to('#js-background', {
        autoAlpha: 1,
        x: '50%',
        scaleY: 1,
        scaleX: 1.1,
        duration: 1
      }),
      Z.to(e.querySelectorAll('.js-title .char > span'), {
        y: '0%',
        stagger: 0.04,
        duration: 0.4,
        delay: 0.7
      }),
      Z.to(e.querySelectorAll('.js-content'), {
        autoAlpha: 1,
        duration: 1,
        delay: 0.8
      });
  },
  Rh = {},
  $g = (r) => [
    {
      name: 'about-transition-home',
      to: { namespace: ['about'] },
      from: { namespace: ['home'] },
      leave({ current: e }) {
        const t = new Promise((n) => {
          const i = e.container.querySelectorAll('.js-title .char > span'),
            s = e.container.querySelectorAll('.js-subtitle'),
            o = e.container.querySelectorAll('.js-content');
          i && Z.to(i, { y: '100%', autoAlpha: 0, duration: 0.4 }),
            s && Z.to(s, { autoAlpha: 0, duration: 0.4 }),
            o &&
              Z.to(o, { autoAlpha: 0, duration: 0.4, onComplete: () => n() });
        });
        return Promise.all([t]);
      },
      enter({ next: e }) {
        uo(e);
      }
    },
    {
      name: 'about-transition-dashboard',
      sync: !0,
      from: { namespace: ['dashboard'] },
      to: { namespace: ['about'] },
      leave({ current: e }) {
        const t = new Promise((n) => {
          const i = e.container.querySelector('.js-dashboardheader'),
            s = e.container.querySelector('.js-dashboard'),
            o = e.container.querySelectorAll('.js-dashboard article');
          Z.to(i, { autoAlpha: 0, duration: 0.4 }),
            Z.to(s, { '--sidepane': '100%' }),
            Z.to(o, { autoAlpha: 0, duration: 0.4, onComplete: () => n() });
        });
        return Promise.all([t]);
      },
      enter({ next: e }) {
        uo(e), wh(r);
      }
    },
    {
      name: 'about-transition-play',
      to: { namespace: ['about'] },
      from: { namespace: ['play'] },
      leave() {
        return Promise.all([
          r.call('disappear', '', 'Gameoptions'),
          r.call('disappear', '', 'Gameplayers', 'me'),
          r.call('disappear', '', 'Gameplayers', 'rival'),
          r.call('disappear', '', 'Gamecontrols')
        ]);
      },
      enter({ next: e }) {
        uo(e), wh(r);
      }
    },
    {
      to: { namespace: ['about'] },
      once() {
        uo();
      }
    }
  ],
  Zg = { namespace: 'dashboard', beforeEnter() {}, afterEnter() {} },
  Jg = (r) => [
    {
      name: 'dashboard-transition',
      leave({ current: e }) {
        const t = new Promise((n) => {
          const i = e.container.querySelectorAll('.js-title  .char > span'),
            s = e.container.querySelectorAll('.js-subtitle'),
            o = e.container.querySelectorAll('.js-content');
          i && Z.to(i, { y: '100%', autoAlpha: 0, duration: 0.4 }),
            s && Z.to(s, { autoAlpha: 0, duration: 0.4 }),
            o &&
              Z.to(o, { autoAlpha: 0, duration: 0.4, onComplete: () => n() });
        });
        return Promise.all([
          r.call('disappear', '', 'Gameoptions'),
          r.call('disappear', '', 'Gameplayers', 'me'),
          r.call('disappear', '', 'Gameplayers', 'rival'),
          r.call('disappear', '', 'Gamecontrols'),
          r.call('disappear', '', 'Gameboard'),
          r.call('disappear', '', 'gamecategory'),
          r.call('disappear', !0, 'webgl'),
          Z.to('#js-background', { autoAlpha: 1, x: '105%', scaleX: 1 }),
          t
        ]);
      },
      enter() {
        r.call('disappear', !0, 'webgl'),
          Z.to('.js-dashboardheader', { autoAlpha: 1 }),
          Z.to('.js-dashboard', { '--sidepane': 0 }),
          Z.to('.js-dashboard article', { autoAlpha: 1, y: 0, stagger: 0.05 });
      }
    },
    {
      to: { namespace: ['dashboard'] },
      once() {
        r.call('changeStatus', 'none', 'webgl'),
          r.call('disappear', !0, 'webgl'),
          Z.to('.js-dashboardheader', { autoAlpha: 1 }),
          Z.to('.js-dashboard', { '--sidepane': 0 }),
          Z.to('.js-dashboard article', { autoAlpha: 1, y: 0, stagger: 0.05 });
      }
    }
  ],
  Qg = class extends Wn.Component {
    constructor(r) {
      super(r);
    }
    init() {
      (this.loadedViews = [Vg, qg, Kg, jg, Zg]),
        (this.loadedTransition = [
          Wg(this),
          ...Xg(this),
          ...$g(this),
          ...Yg(this),
          ...Jg(this)
        ]),
        (this.views = []),
        (this.transitions = []),
        this._updateModules(),
        this._createModules('views', this.loadedViews),
        this._createModules('transitions', this.loadedTransition),
        co.init({ views: this.views, transitions: this.transitions }),
        co.hooks.enter(() => {
          window.scrollTo(0, 0);
        });
    }
    goTo(r) {
      co.go(r);
    }
    _createModules(r, e = []) {
      e.forEach((t) => this[r].push(t));
    }
    _updateModules() {
      this.loadedViews.forEach((r) => {
        const e = r.afterEnter ? r.afterEnter : null,
          t = r.beforeLeave ? r.beforeLeave : null;
        (r.beforeLeave = () => {
          t && t();
        }),
          (r.afterEnter = (n) => {
            e && e(),
              this.trigger('pageLoad'),
              n.current.container &&
                (this.call('destroy', n.current.container, 'app'),
                this.call('update', n.next.container, 'app'));
          });
      });
    }
    destroy() {
      co.destroy();
    }
  },
  Vn = Object.create(null);
Vn.open = '0';
Vn.close = '1';
Vn.ping = '2';
Vn.pong = '3';
Vn.message = '4';
Vn.upgrade = '5';
Vn.noop = '6';
const Xo = Object.create(null);
Object.keys(Vn).forEach((r) => {
  Xo[Vn[r]] = r;
});
const Vc = { type: 'error', data: 'parser error' },
  Wd =
    typeof Blob == 'function' ||
    (typeof Blob < 'u' &&
      Object.prototype.toString.call(Blob) === '[object BlobConstructor]'),
  qd = typeof ArrayBuffer == 'function',
  Xd = (r) =>
    typeof ArrayBuffer.isView == 'function'
      ? ArrayBuffer.isView(r)
      : r && r.buffer instanceof ArrayBuffer,
  Il = ({ type: r, data: e }, t, n) =>
    Wd && e instanceof Blob
      ? t
        ? n(e)
        : Ch(e, n)
      : qd && (e instanceof ArrayBuffer || Xd(e))
      ? t
        ? n(e)
        : Ch(new Blob([e]), n)
      : n(Vn[r] + (e || '')),
  Ch = (r, e) => {
    const t = new FileReader();
    return (
      (t.onload = function () {
        const n = t.result.split(',')[1];
        e('b' + (n || ''));
      }),
      t.readAsDataURL(r)
    );
  };
function Lh(r) {
  return r instanceof Uint8Array
    ? r
    : r instanceof ArrayBuffer
    ? new Uint8Array(r)
    : new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
}
let ka;
function e_(r, e) {
  if (Wd && r.data instanceof Blob)
    return r.data.arrayBuffer().then(Lh).then(e);
  if (qd && (r.data instanceof ArrayBuffer || Xd(r.data))) return e(Lh(r.data));
  Il(r, !1, (t) => {
    ka || (ka = new TextEncoder()), e(ka.encode(t));
  });
}
const Ph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  Us = typeof Uint8Array > 'u' ? [] : new Uint8Array(256);
for (let r = 0; r < Ph.length; r++) Us[Ph.charCodeAt(r)] = r;
const t_ = (r) => {
    let e = r.length * 0.75,
      t = r.length,
      n,
      i = 0,
      s,
      o,
      a,
      c;
    r[r.length - 1] === '=' && (e--, r[r.length - 2] === '=' && e--);
    const l = new ArrayBuffer(e),
      h = new Uint8Array(l);
    for (n = 0; n < t; n += 4)
      (s = Us[r.charCodeAt(n)]),
        (o = Us[r.charCodeAt(n + 1)]),
        (a = Us[r.charCodeAt(n + 2)]),
        (c = Us[r.charCodeAt(n + 3)]),
        (h[i++] = (s << 2) | (o >> 4)),
        (h[i++] = ((o & 15) << 4) | (a >> 2)),
        (h[i++] = ((a & 3) << 6) | (c & 63));
    return l;
  },
  n_ = typeof ArrayBuffer == 'function',
  Ol = (r, e) => {
    if (typeof r != 'string') return { type: 'message', data: jd(r, e) };
    const t = r.charAt(0);
    return t === 'b'
      ? { type: 'message', data: i_(r.substring(1), e) }
      : Xo[t]
      ? r.length > 1
        ? { type: Xo[t], data: r.substring(1) }
        : { type: Xo[t] }
      : Vc;
  },
  i_ = (r, e) => {
    if (n_) {
      const t = t_(r);
      return jd(t, e);
    } else return { base64: !0, data: r };
  },
  jd = (r, e) => {
    switch (e) {
      case 'blob':
        return r instanceof Blob ? r : new Blob([r]);
      case 'arraybuffer':
      default:
        return r instanceof ArrayBuffer ? r : r.buffer;
    }
  },
  Yd = String.fromCharCode(30),
  r_ = (r, e) => {
    const t = r.length,
      n = new Array(t);
    let i = 0;
    r.forEach((s, o) => {
      Il(s, !1, (a) => {
        (n[o] = a), ++i === t && e(n.join(Yd));
      });
    });
  },
  s_ = (r, e) => {
    const t = r.split(Yd),
      n = [];
    for (let i = 0; i < t.length; i++) {
      const s = Ol(t[i], e);
      if ((n.push(s), s.type === 'error')) break;
    }
    return n;
  };
function o_() {
  return new TransformStream({
    transform(r, e) {
      e_(r, (t) => {
        const n = t.length;
        let i;
        if (n < 126)
          (i = new Uint8Array(1)), new DataView(i.buffer).setUint8(0, n);
        else if (n < 65536) {
          i = new Uint8Array(3);
          const s = new DataView(i.buffer);
          s.setUint8(0, 126), s.setUint16(1, n);
        } else {
          i = new Uint8Array(9);
          const s = new DataView(i.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(n));
        }
        r.data && typeof r.data != 'string' && (i[0] |= 128),
          e.enqueue(i),
          e.enqueue(t);
      });
    }
  });
}
let Ba;
function fo(r) {
  return r.reduce((e, t) => e + t.length, 0);
}
function po(r, e) {
  if (r[0].length === e) return r.shift();
  const t = new Uint8Array(e);
  let n = 0;
  for (let i = 0; i < e; i++)
    (t[i] = r[0][n++]), n === r[0].length && (r.shift(), (n = 0));
  return r.length && n < r[0].length && (r[0] = r[0].slice(n)), t;
}
function a_(r, e) {
  Ba || (Ba = new TextDecoder());
  const t = [];
  let n = 0,
    i = -1,
    s = !1;
  return new TransformStream({
    transform(o, a) {
      for (t.push(o); ; ) {
        if (n === 0) {
          if (fo(t) < 1) break;
          const c = po(t, 1);
          (s = (c[0] & 128) === 128),
            (i = c[0] & 127),
            i < 126 ? (n = 3) : i === 126 ? (n = 1) : (n = 2);
        } else if (n === 1) {
          if (fo(t) < 2) break;
          const c = po(t, 2);
          (i = new DataView(c.buffer, c.byteOffset, c.length).getUint16(0)),
            (n = 3);
        } else if (n === 2) {
          if (fo(t) < 8) break;
          const c = po(t, 8),
            l = new DataView(c.buffer, c.byteOffset, c.length),
            h = l.getUint32(0);
          if (h > Math.pow(2, 53 - 32) - 1) {
            a.enqueue(Vc);
            break;
          }
          (i = h * Math.pow(2, 32) + l.getUint32(4)), (n = 3);
        } else {
          if (fo(t) < i) break;
          const c = po(t, i);
          a.enqueue(Ol(s ? c : Ba.decode(c), e)), (n = 0);
        }
        if (i === 0 || i > r) {
          a.enqueue(Vc);
          break;
        }
      }
    }
  });
}
const Kd = 4;
function gt(r) {
  if (r) return c_(r);
}
function c_(r) {
  for (var e in gt.prototype) r[e] = gt.prototype[e];
  return r;
}
gt.prototype.on = gt.prototype.addEventListener = function (r, e) {
  return (
    (this._callbacks = this._callbacks || {}),
    (this._callbacks['$' + r] = this._callbacks['$' + r] || []).push(e),
    this
  );
};
gt.prototype.once = function (r, e) {
  function t() {
    this.off(r, t), e.apply(this, arguments);
  }
  return (t.fn = e), this.on(r, t), this;
};
gt.prototype.off =
  gt.prototype.removeListener =
  gt.prototype.removeAllListeners =
  gt.prototype.removeEventListener =
    function (r, e) {
      if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
        return (this._callbacks = {}), this;
      var t = this._callbacks['$' + r];
      if (!t) return this;
      if (arguments.length == 1) return delete this._callbacks['$' + r], this;
      for (var n, i = 0; i < t.length; i++)
        if (((n = t[i]), n === e || n.fn === e)) {
          t.splice(i, 1);
          break;
        }
      return t.length === 0 && delete this._callbacks['$' + r], this;
    };
gt.prototype.emit = function (r) {
  this._callbacks = this._callbacks || {};
  for (
    var e = new Array(arguments.length - 1),
      t = this._callbacks['$' + r],
      n = 1;
    n < arguments.length;
    n++
  )
    e[n - 1] = arguments[n];
  if (t) {
    t = t.slice(0);
    for (var n = 0, i = t.length; n < i; ++n) t[n].apply(this, e);
  }
  return this;
};
gt.prototype.emitReserved = gt.prototype.emit;
gt.prototype.listeners = function (r) {
  return (
    (this._callbacks = this._callbacks || {}), this._callbacks['$' + r] || []
  );
};
gt.prototype.hasListeners = function (r) {
  return !!this.listeners(r).length;
};
const _n = (() =>
  typeof self < 'u'
    ? self
    : typeof window < 'u'
    ? window
    : Function('return this')())();
function $d(r, ...e) {
  return e.reduce((t, n) => (r.hasOwnProperty(n) && (t[n] = r[n]), t), {});
}
const l_ = _n.setTimeout,
  h_ = _n.clearTimeout;
function _a(r, e) {
  e.useNativeTimers
    ? ((r.setTimeoutFn = l_.bind(_n)), (r.clearTimeoutFn = h_.bind(_n)))
    : ((r.setTimeoutFn = _n.setTimeout.bind(_n)),
      (r.clearTimeoutFn = _n.clearTimeout.bind(_n)));
}
const u_ = 1.33;
function f_(r) {
  return typeof r == 'string'
    ? d_(r)
    : Math.ceil((r.byteLength || r.size) * u_);
}
function d_(r) {
  let e = 0,
    t = 0;
  for (let n = 0, i = r.length; n < i; n++)
    (e = r.charCodeAt(n)),
      e < 128
        ? (t += 1)
        : e < 2048
        ? (t += 2)
        : e < 55296 || e >= 57344
        ? (t += 3)
        : (n++, (t += 4));
  return t;
}
function p_(r) {
  let e = '';
  for (let t in r)
    r.hasOwnProperty(t) &&
      (e.length && (e += '&'),
      (e += encodeURIComponent(t) + '=' + encodeURIComponent(r[t])));
  return e;
}
function m_(r) {
  let e = {},
    t = r.split('&');
  for (let n = 0, i = t.length; n < i; n++) {
    let s = t[n].split('=');
    e[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return e;
}
class g_ extends Error {
  constructor(e, t, n) {
    super(e),
      (this.description = t),
      (this.context = n),
      (this.type = 'TransportError');
  }
}
class Ul extends gt {
  constructor(e) {
    super(),
      (this.writable = !1),
      _a(this, e),
      (this.opts = e),
      (this.query = e.query),
      (this.socket = e.socket);
  }
  onError(e, t, n) {
    return super.emitReserved('error', new g_(e, t, n)), this;
  }
  open() {
    return (this.readyState = 'opening'), this.doOpen(), this;
  }
  close() {
    return (
      (this.readyState === 'opening' || this.readyState === 'open') &&
        (this.doClose(), this.onClose()),
      this
    );
  }
  send(e) {
    this.readyState === 'open' && this.write(e);
  }
  onOpen() {
    (this.readyState = 'open'),
      (this.writable = !0),
      super.emitReserved('open');
  }
  onData(e) {
    const t = Ol(e, this.socket.binaryType);
    this.onPacket(t);
  }
  onPacket(e) {
    super.emitReserved('packet', e);
  }
  onClose(e) {
    (this.readyState = 'closed'), super.emitReserved('close', e);
  }
  pause(e) {}
  createUri(e, t = {}) {
    return (
      e +
      '://' +
      this._hostname() +
      this._port() +
      this.opts.path +
      this._query(t)
    );
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(':') === -1 ? e : '[' + e + ']';
  }
  _port() {
    return this.opts.port &&
      ((this.opts.secure && +(this.opts.port !== 443)) ||
        (!this.opts.secure && Number(this.opts.port) !== 80))
      ? ':' + this.opts.port
      : '';
  }
  _query(e) {
    const t = p_(e);
    return t.length ? '?' + t : '';
  }
}
const Zd =
    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(
      ''
    ),
  Wc = 64,
  __ = {};
let Dh = 0,
  mo = 0,
  Ih;
function Oh(r) {
  let e = '';
  do (e = Zd[r % Wc] + e), (r = Math.floor(r / Wc));
  while (r > 0);
  return e;
}
function Jd() {
  const r = Oh(+new Date());
  return r !== Ih ? ((Dh = 0), (Ih = r)) : r + '.' + Oh(Dh++);
}
for (; mo < Wc; mo++) __[Zd[mo]] = mo;
let Qd = !1;
try {
  Qd = typeof XMLHttpRequest < 'u' && 'withCredentials' in new XMLHttpRequest();
} catch {}
const v_ = Qd;
function ep(r) {
  const e = r.xdomain;
  try {
    if (typeof XMLHttpRequest < 'u' && (!e || v_)) return new XMLHttpRequest();
  } catch {}
  if (!e)
    try {
      return new _n[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch {}
}
function y_() {}
const x_ = (function () {
  return new ep({ xdomain: !1 }).responseType != null;
})();
class M_ extends Ul {
  constructor(e) {
    if ((super(e), (this.polling = !1), typeof location < 'u')) {
      const n = location.protocol === 'https:';
      let i = location.port;
      i || (i = n ? '443' : '80'),
        (this.xd =
          (typeof location < 'u' && e.hostname !== location.hostname) ||
          i !== e.port);
    }
    const t = e && e.forceBase64;
    (this.supportsBinary = x_ && !t),
      this.opts.withCredentials && (this.cookieJar = void 0);
  }
  get name() {
    return 'polling';
  }
  doOpen() {
    this.poll();
  }
  pause(e) {
    this.readyState = 'pausing';
    const t = () => {
      (this.readyState = 'paused'), e();
    };
    if (this.polling || !this.writable) {
      let n = 0;
      this.polling &&
        (n++,
        this.once('pollComplete', function () {
          --n || t();
        })),
        this.writable ||
          (n++,
          this.once('drain', function () {
            --n || t();
          }));
    } else t();
  }
  poll() {
    (this.polling = !0), this.doPoll(), this.emitReserved('poll');
  }
  onData(e) {
    const t = (n) => {
      if (
        (this.readyState === 'opening' && n.type === 'open' && this.onOpen(),
        n.type === 'close')
      )
        return (
          this.onClose({ description: 'transport closed by the server' }), !1
        );
      this.onPacket(n);
    };
    s_(e, this.socket.binaryType).forEach(t),
      this.readyState !== 'closed' &&
        ((this.polling = !1),
        this.emitReserved('pollComplete'),
        this.readyState === 'open' && this.poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: 'close' }]);
    };
    this.readyState === 'open' ? e() : this.once('open', e);
  }
  write(e) {
    (this.writable = !1),
      r_(e, (t) => {
        this.doWrite(t, () => {
          (this.writable = !0), this.emitReserved('drain');
        });
      });
  }
  uri() {
    const e = this.opts.secure ? 'https' : 'http',
      t = this.query || {};
    return (
      this.opts.timestampRequests !== !1 &&
        (t[this.opts.timestampParam] = Jd()),
      !this.supportsBinary && !t.sid && (t.b64 = 1),
      this.createUri(e, t)
    );
  }
  request(e = {}) {
    return (
      Object.assign(e, { xd: this.xd, cookieJar: this.cookieJar }, this.opts),
      new Zr(this.uri(), e)
    );
  }
  doWrite(e, t) {
    const n = this.request({ method: 'POST', data: e });
    n.on('success', t),
      n.on('error', (i, s) => {
        this.onError('xhr post error', i, s);
      });
  }
  doPoll() {
    const e = this.request();
    e.on('data', this.onData.bind(this)),
      e.on('error', (t, n) => {
        this.onError('xhr poll error', t, n);
      }),
      (this.pollXhr = e);
  }
}
let Zr = class jo extends gt {
  constructor(e, t) {
    super(),
      _a(this, t),
      (this.opts = t),
      (this.method = t.method || 'GET'),
      (this.uri = e),
      (this.data = t.data !== void 0 ? t.data : null),
      this.create();
  }
  create() {
    var e;
    const t = $d(
      this.opts,
      'agent',
      'pfx',
      'key',
      'passphrase',
      'cert',
      'ca',
      'ciphers',
      'rejectUnauthorized',
      'autoUnref'
    );
    t.xdomain = !!this.opts.xd;
    const n = (this.xhr = new ep(t));
    try {
      n.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
          for (let i in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(i) &&
              n.setRequestHeader(i, this.opts.extraHeaders[i]);
        }
      } catch {}
      if (this.method === 'POST')
        try {
          n.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        } catch {}
      try {
        n.setRequestHeader('Accept', '*/*');
      } catch {}
      (e = this.opts.cookieJar) === null || e === void 0 || e.addCookies(n),
        'withCredentials' in n &&
          (n.withCredentials = this.opts.withCredentials),
        this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout),
        (n.onreadystatechange = () => {
          var i;
          n.readyState === 3 &&
            ((i = this.opts.cookieJar) === null ||
              i === void 0 ||
              i.parseCookies(n)),
            n.readyState === 4 &&
              (n.status === 200 || n.status === 1223
                ? this.onLoad()
                : this.setTimeoutFn(() => {
                    this.onError(typeof n.status == 'number' ? n.status : 0);
                  }, 0));
        }),
        n.send(this.data);
    } catch (i) {
      this.setTimeoutFn(() => {
        this.onError(i);
      }, 0);
      return;
    }
    typeof document < 'u' &&
      ((this.index = jo.requestsCount++), (jo.requests[this.index] = this));
  }
  onError(e) {
    this.emitReserved('error', e, this.xhr), this.cleanup(!0);
  }
  cleanup(e) {
    if (!(typeof this.xhr > 'u' || this.xhr === null)) {
      if (((this.xhr.onreadystatechange = y_), e))
        try {
          this.xhr.abort();
        } catch {}
      typeof document < 'u' && delete jo.requests[this.index],
        (this.xhr = null);
    }
  }
  onLoad() {
    const e = this.xhr.responseText;
    e !== null &&
      (this.emitReserved('data', e),
      this.emitReserved('success'),
      this.cleanup());
  }
  abort() {
    this.cleanup();
  }
};
Zr.requestsCount = 0;
Zr.requests = {};
if (typeof document < 'u') {
  if (typeof attachEvent == 'function') attachEvent('onunload', Uh);
  else if (typeof addEventListener == 'function') {
    const r = 'onpagehide' in _n ? 'pagehide' : 'unload';
    addEventListener(r, Uh, !1);
  }
}
function Uh() {
  for (let r in Zr.requests)
    Zr.requests.hasOwnProperty(r) && Zr.requests[r].abort();
}
const Nl = (() =>
    typeof Promise == 'function' && typeof Promise.resolve == 'function'
      ? (e) => Promise.resolve().then(e)
      : (e, t) => t(e, 0))(),
  go = _n.WebSocket || _n.MozWebSocket,
  Nh = !0,
  S_ = 'arraybuffer',
  Fh =
    typeof navigator < 'u' &&
    typeof navigator.product == 'string' &&
    navigator.product.toLowerCase() === 'reactnative';
class b_ extends Ul {
  constructor(e) {
    super(e), (this.supportsBinary = !e.forceBase64);
  }
  get name() {
    return 'websocket';
  }
  doOpen() {
    if (!this.check()) return;
    const e = this.uri(),
      t = this.opts.protocols,
      n = Fh
        ? {}
        : $d(
            this.opts,
            'agent',
            'perMessageDeflate',
            'pfx',
            'key',
            'passphrase',
            'cert',
            'ca',
            'ciphers',
            'rejectUnauthorized',
            'localAddress',
            'protocolVersion',
            'origin',
            'maxPayload',
            'family',
            'checkServerIdentity'
          );
    this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
    try {
      this.ws = Nh && !Fh ? (t ? new go(e, t) : new go(e)) : new go(e, t, n);
    } catch (i) {
      return this.emitReserved('error', i);
    }
    (this.ws.binaryType = this.socket.binaryType), this.addEventListeners();
  }
  addEventListeners() {
    (this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }),
      (this.ws.onclose = (e) =>
        this.onClose({
          description: 'websocket connection closed',
          context: e
        })),
      (this.ws.onmessage = (e) => this.onData(e.data)),
      (this.ws.onerror = (e) => this.onError('websocket error', e));
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const n = e[t],
        i = t === e.length - 1;
      Il(n, this.supportsBinary, (s) => {
        const o = {};
        try {
          Nh && this.ws.send(s);
        } catch {}
        i &&
          Nl(() => {
            (this.writable = !0), this.emitReserved('drain');
          }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < 'u' && (this.ws.close(), (this.ws = null));
  }
  uri() {
    const e = this.opts.secure ? 'wss' : 'ws',
      t = this.query || {};
    return (
      this.opts.timestampRequests && (t[this.opts.timestampParam] = Jd()),
      this.supportsBinary || (t.b64 = 1),
      this.createUri(e, t)
    );
  }
  check() {
    return !!go;
  }
}
class E_ extends Ul {
  get name() {
    return 'webtransport';
  }
  doOpen() {
    typeof WebTransport == 'function' &&
      ((this.transport = new WebTransport(
        this.createUri('https'),
        this.opts.transportOptions[this.name]
      )),
      this.transport.closed
        .then(() => {
          this.onClose();
        })
        .catch((e) => {
          this.onError('webtransport error', e);
        }),
      this.transport.ready.then(() => {
        this.transport.createBidirectionalStream().then((e) => {
          const t = a_(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
            n = e.readable.pipeThrough(t).getReader(),
            i = o_();
          i.readable.pipeTo(e.writable), (this.writer = i.writable.getWriter());
          const s = () => {
            n.read()
              .then(({ done: a, value: c }) => {
                a || (this.onPacket(c), s());
              })
              .catch((a) => {});
          };
          s();
          const o = { type: 'open' };
          this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`),
            this.writer.write(o).then(() => this.onOpen());
        });
      }));
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const n = e[t],
        i = t === e.length - 1;
      this.writer.write(n).then(() => {
        i &&
          Nl(() => {
            (this.writable = !0), this.emitReserved('drain');
          }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this.transport) === null || e === void 0 || e.close();
  }
}
const T_ = { websocket: b_, webtransport: E_, polling: M_ },
  A_ =
    /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
  w_ = [
    'source',
    'protocol',
    'authority',
    'userInfo',
    'user',
    'password',
    'host',
    'port',
    'relative',
    'path',
    'directory',
    'file',
    'query',
    'anchor'
  ];
function qc(r) {
  const e = r,
    t = r.indexOf('['),
    n = r.indexOf(']');
  t != -1 &&
    n != -1 &&
    (r =
      r.substring(0, t) +
      r.substring(t, n).replace(/:/g, ';') +
      r.substring(n, r.length));
  let i = A_.exec(r || ''),
    s = {},
    o = 14;
  for (; o--; ) s[w_[o]] = i[o] || '';
  return (
    t != -1 &&
      n != -1 &&
      ((s.source = e),
      (s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ':')),
      (s.authority = s.authority
        .replace('[', '')
        .replace(']', '')
        .replace(/;/g, ':')),
      (s.ipv6uri = !0)),
    (s.pathNames = R_(s, s.path)),
    (s.queryKey = C_(s, s.query)),
    s
  );
}
function R_(r, e) {
  const t = /\/{2,9}/g,
    n = e.replace(t, '/').split('/');
  return (
    (e.slice(0, 1) == '/' || e.length === 0) && n.splice(0, 1),
    e.slice(-1) == '/' && n.splice(n.length - 1, 1),
    n
  );
}
function C_(r, e) {
  const t = {};
  return (
    e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (n, i, s) {
      i && (t[i] = s);
    }),
    t
  );
}
let tp = class Gr extends gt {
  constructor(e, t = {}) {
    super(),
      (this.binaryType = S_),
      (this.writeBuffer = []),
      e && typeof e == 'object' && ((t = e), (e = null)),
      e
        ? ((e = qc(e)),
          (t.hostname = e.host),
          (t.secure = e.protocol === 'https' || e.protocol === 'wss'),
          (t.port = e.port),
          e.query && (t.query = e.query))
        : t.host && (t.hostname = qc(t.host).host),
      _a(this, t),
      (this.secure =
        t.secure != null
          ? t.secure
          : typeof location < 'u' && location.protocol === 'https:'),
      t.hostname && !t.port && (t.port = this.secure ? '443' : '80'),
      (this.hostname =
        t.hostname ||
        (typeof location < 'u' ? location.hostname : 'localhost')),
      (this.port =
        t.port ||
        (typeof location < 'u' && location.port
          ? location.port
          : this.secure
          ? '443'
          : '80')),
      (this.transports = t.transports || [
        'polling',
        'websocket',
        'webtransport'
      ]),
      (this.writeBuffer = []),
      (this.prevBufferLen = 0),
      (this.opts = Object.assign(
        {
          path: '/engine.io',
          agent: !1,
          withCredentials: !1,
          upgrade: !0,
          timestampParam: 't',
          rememberUpgrade: !1,
          addTrailingSlash: !0,
          rejectUnauthorized: !0,
          perMessageDeflate: { threshold: 1024 },
          transportOptions: {},
          closeOnBeforeunload: !1
        },
        t
      )),
      (this.opts.path =
        this.opts.path.replace(/\/$/, '') +
        (this.opts.addTrailingSlash ? '/' : '')),
      typeof this.opts.query == 'string' &&
        (this.opts.query = m_(this.opts.query)),
      (this.id = null),
      (this.upgrades = null),
      (this.pingInterval = null),
      (this.pingTimeout = null),
      (this.pingTimeoutTimer = null),
      typeof addEventListener == 'function' &&
        (this.opts.closeOnBeforeunload &&
          ((this.beforeunloadEventListener = () => {
            this.transport &&
              (this.transport.removeAllListeners(), this.transport.close());
          }),
          addEventListener('beforeunload', this.beforeunloadEventListener, !1)),
        this.hostname !== 'localhost' &&
          ((this.offlineEventListener = () => {
            this.onClose('transport close', {
              description: 'network connection lost'
            });
          }),
          addEventListener('offline', this.offlineEventListener, !1))),
      this.open();
  }
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    (t.EIO = Kd), (t.transport = e), this.id && (t.sid = this.id);
    const n = Object.assign(
      {},
      this.opts,
      {
        query: t,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      },
      this.opts.transportOptions[e]
    );
    return new T_[e](n);
  }
  open() {
    let e;
    if (
      this.opts.rememberUpgrade &&
      Gr.priorWebsocketSuccess &&
      this.transports.indexOf('websocket') !== -1
    )
      e = 'websocket';
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved('error', 'No transports available');
      }, 0);
      return;
    } else e = this.transports[0];
    this.readyState = 'opening';
    try {
      e = this.createTransport(e);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    e.open(), this.setTransport(e);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(),
      (this.transport = e),
      e
        .on('drain', this.onDrain.bind(this))
        .on('packet', this.onPacket.bind(this))
        .on('error', this.onError.bind(this))
        .on('close', (t) => this.onClose('transport close', t));
  }
  probe(e) {
    let t = this.createTransport(e),
      n = !1;
    Gr.priorWebsocketSuccess = !1;
    const i = () => {
      n ||
        (t.send([{ type: 'ping', data: 'probe' }]),
        t.once('packet', (f) => {
          if (!n)
            if (f.type === 'pong' && f.data === 'probe') {
              if (
                ((this.upgrading = !0), this.emitReserved('upgrading', t), !t)
              )
                return;
              (Gr.priorWebsocketSuccess = t.name === 'websocket'),
                this.transport.pause(() => {
                  n ||
                    (this.readyState !== 'closed' &&
                      (h(),
                      this.setTransport(t),
                      t.send([{ type: 'upgrade' }]),
                      this.emitReserved('upgrade', t),
                      (t = null),
                      (this.upgrading = !1),
                      this.flush()));
                });
            } else {
              const u = new Error('probe error');
              (u.transport = t.name), this.emitReserved('upgradeError', u);
            }
        }));
    };
    function s() {
      n || ((n = !0), h(), t.close(), (t = null));
    }
    const o = (f) => {
      const u = new Error('probe error: ' + f);
      (u.transport = t.name), s(), this.emitReserved('upgradeError', u);
    };
    function a() {
      o('transport closed');
    }
    function c() {
      o('socket closed');
    }
    function l(f) {
      t && f.name !== t.name && s();
    }
    const h = () => {
      t.removeListener('open', i),
        t.removeListener('error', o),
        t.removeListener('close', a),
        this.off('close', c),
        this.off('upgrading', l);
    };
    t.once('open', i),
      t.once('error', o),
      t.once('close', a),
      this.once('close', c),
      this.once('upgrading', l),
      this.upgrades.indexOf('webtransport') !== -1 && e !== 'webtransport'
        ? this.setTimeoutFn(() => {
            n || t.open();
          }, 200)
        : t.open();
  }
  onOpen() {
    if (
      ((this.readyState = 'open'),
      (Gr.priorWebsocketSuccess = this.transport.name === 'websocket'),
      this.emitReserved('open'),
      this.flush(),
      this.readyState === 'open' && this.opts.upgrade)
    ) {
      let e = 0;
      const t = this.upgrades.length;
      for (; e < t; e++) this.probe(this.upgrades[e]);
    }
  }
  onPacket(e) {
    if (
      this.readyState === 'opening' ||
      this.readyState === 'open' ||
      this.readyState === 'closing'
    )
      switch (
        (this.emitReserved('packet', e),
        this.emitReserved('heartbeat'),
        this.resetPingTimeout(),
        e.type)
      ) {
        case 'open':
          this.onHandshake(JSON.parse(e.data));
          break;
        case 'ping':
          this.sendPacket('pong'),
            this.emitReserved('ping'),
            this.emitReserved('pong');
          break;
        case 'error':
          const t = new Error('server error');
          (t.code = e.data), this.onError(t);
          break;
        case 'message':
          this.emitReserved('data', e.data),
            this.emitReserved('message', e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved('handshake', e),
      (this.id = e.sid),
      (this.transport.query.sid = e.sid),
      (this.upgrades = this.filterUpgrades(e.upgrades)),
      (this.pingInterval = e.pingInterval),
      (this.pingTimeout = e.pingTimeout),
      (this.maxPayload = e.maxPayload),
      this.onOpen(),
      this.readyState !== 'closed' && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer),
      (this.pingTimeoutTimer = this.setTimeoutFn(() => {
        this.onClose('ping timeout');
      }, this.pingInterval + this.pingTimeout)),
      this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen),
      (this.prevBufferLen = 0),
      this.writeBuffer.length === 0 ? this.emitReserved('drain') : this.flush();
  }
  flush() {
    if (
      this.readyState !== 'closed' &&
      this.transport.writable &&
      !this.upgrading &&
      this.writeBuffer.length
    ) {
      const e = this.getWritablePackets();
      this.transport.send(e),
        (this.prevBufferLen = e.length),
        this.emitReserved('flush');
    }
  }
  getWritablePackets() {
    if (
      !(
        this.maxPayload &&
        this.transport.name === 'polling' &&
        this.writeBuffer.length > 1
      )
    )
      return this.writeBuffer;
    let t = 1;
    for (let n = 0; n < this.writeBuffer.length; n++) {
      const i = this.writeBuffer[n].data;
      if ((i && (t += f_(i)), n > 0 && t > this.maxPayload))
        return this.writeBuffer.slice(0, n);
      t += 2;
    }
    return this.writeBuffer;
  }
  write(e, t, n) {
    return this.sendPacket('message', e, t, n), this;
  }
  send(e, t, n) {
    return this.sendPacket('message', e, t, n), this;
  }
  sendPacket(e, t, n, i) {
    if (
      (typeof t == 'function' && ((i = t), (t = void 0)),
      typeof n == 'function' && ((i = n), (n = null)),
      this.readyState === 'closing' || this.readyState === 'closed')
    )
      return;
    (n = n || {}), (n.compress = n.compress !== !1);
    const s = { type: e, data: t, options: n };
    this.emitReserved('packetCreate', s),
      this.writeBuffer.push(s),
      i && this.once('flush', i),
      this.flush();
  }
  close() {
    const e = () => {
        this.onClose('forced close'), this.transport.close();
      },
      t = () => {
        this.off('upgrade', t), this.off('upgradeError', t), e();
      },
      n = () => {
        this.once('upgrade', t), this.once('upgradeError', t);
      };
    return (
      (this.readyState === 'opening' || this.readyState === 'open') &&
        ((this.readyState = 'closing'),
        this.writeBuffer.length
          ? this.once('drain', () => {
              this.upgrading ? n() : e();
            })
          : this.upgrading
          ? n()
          : e()),
      this
    );
  }
  onError(e) {
    (Gr.priorWebsocketSuccess = !1),
      this.emitReserved('error', e),
      this.onClose('transport error', e);
  }
  onClose(e, t) {
    (this.readyState === 'opening' ||
      this.readyState === 'open' ||
      this.readyState === 'closing') &&
      (this.clearTimeoutFn(this.pingTimeoutTimer),
      this.transport.removeAllListeners('close'),
      this.transport.close(),
      this.transport.removeAllListeners(),
      typeof removeEventListener == 'function' &&
        (removeEventListener(
          'beforeunload',
          this.beforeunloadEventListener,
          !1
        ),
        removeEventListener('offline', this.offlineEventListener, !1)),
      (this.readyState = 'closed'),
      (this.id = null),
      this.emitReserved('close', e, t),
      (this.writeBuffer = []),
      (this.prevBufferLen = 0));
  }
  filterUpgrades(e) {
    const t = [];
    let n = 0;
    const i = e.length;
    for (; n < i; n++) ~this.transports.indexOf(e[n]) && t.push(e[n]);
    return t;
  }
};
tp.protocol = Kd;
function L_(r, e = '', t) {
  let n = r;
  (t = t || (typeof location < 'u' && location)),
    r == null && (r = t.protocol + '//' + t.host),
    typeof r == 'string' &&
      (r.charAt(0) === '/' &&
        (r.charAt(1) === '/' ? (r = t.protocol + r) : (r = t.host + r)),
      /^(https?|wss?):\/\//.test(r) ||
        (typeof t < 'u' ? (r = t.protocol + '//' + r) : (r = 'https://' + r)),
      (n = qc(r))),
    n.port ||
      (/^(http|ws)$/.test(n.protocol)
        ? (n.port = '80')
        : /^(http|ws)s$/.test(n.protocol) && (n.port = '443')),
    (n.path = n.path || '/');
  const s = n.host.indexOf(':') !== -1 ? '[' + n.host + ']' : n.host;
  return (
    (n.id = n.protocol + '://' + s + ':' + n.port + e),
    (n.href =
      n.protocol + '://' + s + (t && t.port === n.port ? '' : ':' + n.port)),
    n
  );
}
const P_ = typeof ArrayBuffer == 'function',
  D_ = (r) =>
    typeof ArrayBuffer.isView == 'function'
      ? ArrayBuffer.isView(r)
      : r.buffer instanceof ArrayBuffer,
  np = Object.prototype.toString,
  I_ =
    typeof Blob == 'function' ||
    (typeof Blob < 'u' && np.call(Blob) === '[object BlobConstructor]'),
  O_ =
    typeof File == 'function' ||
    (typeof File < 'u' && np.call(File) === '[object FileConstructor]');
function Fl(r) {
  return (
    (P_ && (r instanceof ArrayBuffer || D_(r))) ||
    (I_ && r instanceof Blob) ||
    (O_ && r instanceof File)
  );
}
function Yo(r, e) {
  if (!r || typeof r != 'object') return !1;
  if (Array.isArray(r)) {
    for (let t = 0, n = r.length; t < n; t++) if (Yo(r[t])) return !0;
    return !1;
  }
  if (Fl(r)) return !0;
  if (r.toJSON && typeof r.toJSON == 'function' && arguments.length === 1)
    return Yo(r.toJSON(), !0);
  for (const t in r)
    if (Object.prototype.hasOwnProperty.call(r, t) && Yo(r[t])) return !0;
  return !1;
}
function U_(r) {
  const e = [],
    t = r.data,
    n = r;
  return (
    (n.data = Xc(t, e)), (n.attachments = e.length), { packet: n, buffers: e }
  );
}
function Xc(r, e) {
  if (!r) return r;
  if (Fl(r)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(r), t;
  } else if (Array.isArray(r)) {
    const t = new Array(r.length);
    for (let n = 0; n < r.length; n++) t[n] = Xc(r[n], e);
    return t;
  } else if (typeof r == 'object' && !(r instanceof Date)) {
    const t = {};
    for (const n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = Xc(r[n], e));
    return t;
  }
  return r;
}
function N_(r, e) {
  return (r.data = jc(r.data, e)), delete r.attachments, r;
}
function jc(r, e) {
  if (!r) return r;
  if (r && r._placeholder === !0) {
    if (typeof r.num == 'number' && r.num >= 0 && r.num < e.length)
      return e[r.num];
    throw new Error('illegal attachments');
  } else if (Array.isArray(r))
    for (let t = 0; t < r.length; t++) r[t] = jc(r[t], e);
  else if (typeof r == 'object')
    for (const t in r)
      Object.prototype.hasOwnProperty.call(r, t) && (r[t] = jc(r[t], e));
  return r;
}
const F_ = [
    'connect',
    'connect_error',
    'disconnect',
    'disconnecting',
    'newListener',
    'removeListener'
  ],
  k_ = 5;
var ze;
(function (r) {
  (r[(r.CONNECT = 0)] = 'CONNECT'),
    (r[(r.DISCONNECT = 1)] = 'DISCONNECT'),
    (r[(r.EVENT = 2)] = 'EVENT'),
    (r[(r.ACK = 3)] = 'ACK'),
    (r[(r.CONNECT_ERROR = 4)] = 'CONNECT_ERROR'),
    (r[(r.BINARY_EVENT = 5)] = 'BINARY_EVENT'),
    (r[(r.BINARY_ACK = 6)] = 'BINARY_ACK');
})(ze || (ze = {}));
class B_ {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === ze.EVENT || e.type === ze.ACK) && Yo(e)
      ? this.encodeAsBinary({
          type: e.type === ze.EVENT ? ze.BINARY_EVENT : ze.BINARY_ACK,
          nsp: e.nsp,
          data: e.data,
          id: e.id
        })
      : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let t = '' + e.type;
    return (
      (e.type === ze.BINARY_EVENT || e.type === ze.BINARY_ACK) &&
        (t += e.attachments + '-'),
      e.nsp && e.nsp !== '/' && (t += e.nsp + ','),
      e.id != null && (t += e.id),
      e.data != null && (t += JSON.stringify(e.data, this.replacer)),
      t
    );
  }
  encodeAsBinary(e) {
    const t = U_(e),
      n = this.encodeAsString(t.packet),
      i = t.buffers;
    return i.unshift(n), i;
  }
}
function kh(r) {
  return Object.prototype.toString.call(r) === '[object Object]';
}
class kl extends gt {
  constructor(e) {
    super(), (this.reviver = e);
  }
  add(e) {
    let t;
    if (typeof e == 'string') {
      if (this.reconstructor)
        throw new Error('got plaintext data when reconstructing a packet');
      t = this.decodeString(e);
      const n = t.type === ze.BINARY_EVENT;
      n || t.type === ze.BINARY_ACK
        ? ((t.type = n ? ze.EVENT : ze.ACK),
          (this.reconstructor = new z_(t)),
          t.attachments === 0 && super.emitReserved('decoded', t))
        : super.emitReserved('decoded', t);
    } else if (Fl(e) || e.base64)
      if (this.reconstructor)
        (t = this.reconstructor.takeBinaryData(e)),
          t && ((this.reconstructor = null), super.emitReserved('decoded', t));
      else throw new Error('got binary data when not reconstructing a packet');
    else throw new Error('Unknown type: ' + e);
  }
  decodeString(e) {
    let t = 0;
    const n = { type: Number(e.charAt(0)) };
    if (ze[n.type] === void 0) throw new Error('unknown packet type ' + n.type);
    if (n.type === ze.BINARY_EVENT || n.type === ze.BINARY_ACK) {
      const s = t + 1;
      for (; e.charAt(++t) !== '-' && t != e.length; );
      const o = e.substring(s, t);
      if (o != Number(o) || e.charAt(t) !== '-')
        throw new Error('Illegal attachments');
      n.attachments = Number(o);
    }
    if (e.charAt(t + 1) === '/') {
      const s = t + 1;
      for (; ++t && !(e.charAt(t) === ',' || t === e.length); );
      n.nsp = e.substring(s, t);
    } else n.nsp = '/';
    const i = e.charAt(t + 1);
    if (i !== '' && Number(i) == i) {
      const s = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length) break;
      }
      n.id = Number(e.substring(s, t + 1));
    }
    if (e.charAt(++t)) {
      const s = this.tryParse(e.substr(t));
      if (kl.isPayloadValid(n.type, s)) n.data = s;
      else throw new Error('invalid payload');
    }
    return n;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case ze.CONNECT:
        return kh(t);
      case ze.DISCONNECT:
        return t === void 0;
      case ze.CONNECT_ERROR:
        return typeof t == 'string' || kh(t);
      case ze.EVENT:
      case ze.BINARY_EVENT:
        return (
          Array.isArray(t) &&
          (typeof t[0] == 'number' ||
            (typeof t[0] == 'string' && F_.indexOf(t[0]) === -1))
        );
      case ze.ACK:
      case ze.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  destroy() {
    this.reconstructor &&
      (this.reconstructor.finishedReconstruction(),
      (this.reconstructor = null));
  }
}
class z_ {
  constructor(e) {
    (this.packet = e), (this.buffers = []), (this.reconPack = e);
  }
  takeBinaryData(e) {
    if (
      (this.buffers.push(e), this.buffers.length === this.reconPack.attachments)
    ) {
      const t = N_(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  finishedReconstruction() {
    (this.reconPack = null), (this.buffers = []);
  }
}
const H_ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      Decoder: kl,
      Encoder: B_,
      get PacketType() {
        return ze;
      },
      protocol: k_
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
function Rn(r, e, t) {
  return (
    r.on(e, t),
    function () {
      r.off(e, t);
    }
  );
}
const G_ = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class ip extends gt {
  constructor(e, t, n) {
    super(),
      (this.connected = !1),
      (this.recovered = !1),
      (this.receiveBuffer = []),
      (this.sendBuffer = []),
      (this._queue = []),
      (this._queueSeq = 0),
      (this.ids = 0),
      (this.acks = {}),
      (this.flags = {}),
      (this.io = e),
      (this.nsp = t),
      n && n.auth && (this.auth = n.auth),
      (this._opts = Object.assign({}, n)),
      this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs) return;
    const e = this.io;
    this.subs = [
      Rn(e, 'open', this.onopen.bind(this)),
      Rn(e, 'packet', this.onpacket.bind(this)),
      Rn(e, 'error', this.onerror.bind(this)),
      Rn(e, 'close', this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected
      ? this
      : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === 'open' && this.onopen(),
        this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift('message'), this.emit.apply(this, e), this;
  }
  emit(e, ...t) {
    if (G_.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (
      (t.unshift(e),
      this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
    )
      return this._addToQueue(t), this;
    const n = { type: ze.EVENT, data: t };
    if (
      ((n.options = {}),
      (n.options.compress = this.flags.compress !== !1),
      typeof t[t.length - 1] == 'function')
    ) {
      const o = this.ids++,
        a = t.pop();
      this._registerAckCallback(o, a), (n.id = o);
    }
    const i =
      this.io.engine &&
      this.io.engine.transport &&
      this.io.engine.transport.writable;
    return (
      (this.flags.volatile && (!i || !this.connected)) ||
        (this.connected
          ? (this.notifyOutgoingListeners(n), this.packet(n))
          : this.sendBuffer.push(n)),
      (this.flags = {}),
      this
    );
  }
  _registerAckCallback(e, t) {
    var n;
    const i =
      (n = this.flags.timeout) !== null && n !== void 0
        ? n
        : this._opts.ackTimeout;
    if (i === void 0) {
      this.acks[e] = t;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      t.call(this, new Error('operation has timed out'));
    }, i);
    this.acks[e] = (...o) => {
      this.io.clearTimeoutFn(s), t.apply(this, [null, ...o]);
    };
  }
  emitWithAck(e, ...t) {
    const n = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((i, s) => {
      t.push((o, a) => (n ? (o ? s(o) : i(a)) : i(o))), this.emit(e, ...t);
    });
  }
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == 'function' && (t = e.pop());
    const n = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((i, ...s) =>
      n !== this._queue[0]
        ? void 0
        : (i !== null
            ? n.tryCount > this._opts.retries &&
              (this._queue.shift(), t && t(i))
            : (this._queue.shift(), t && t(null, ...s)),
          (n.pending = !1),
          this._drainQueue())
    ),
      this._queue.push(n),
      this._drainQueue();
  }
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0) return;
    const t = this._queue[0];
    (t.pending && !e) ||
      ((t.pending = !0),
      t.tryCount++,
      (this.flags = t.flags),
      this.emit.apply(this, t.args));
  }
  packet(e) {
    (e.nsp = this.nsp), this.io._packet(e);
  }
  onopen() {
    typeof this.auth == 'function'
      ? this.auth((e) => {
          this._sendConnectPacket(e);
        })
      : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({
      type: ze.CONNECT,
      data: this._pid
        ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e)
        : e
    });
  }
  onerror(e) {
    this.connected || this.emitReserved('connect_error', e);
  }
  onclose(e, t) {
    (this.connected = !1),
      delete this.id,
      this.emitReserved('disconnect', e, t);
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case ze.CONNECT:
          e.data && e.data.sid
            ? this.onconnect(e.data.sid, e.data.pid)
            : this.emitReserved(
                'connect_error',
                new Error(
                  'It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)'
                )
              );
          break;
        case ze.EVENT:
        case ze.BINARY_EVENT:
          this.onevent(e);
          break;
        case ze.ACK:
        case ze.BINARY_ACK:
          this.onack(e);
          break;
        case ze.DISCONNECT:
          this.ondisconnect();
          break;
        case ze.CONNECT_ERROR:
          this.destroy();
          const n = new Error(e.data.message);
          (n.data = e.data.data), this.emitReserved('connect_error', n);
          break;
      }
  }
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)),
      this.connected
        ? this.emitEvent(t)
        : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const n of t) n.apply(this, e);
    }
    super.emit.apply(this, e),
      this._pid &&
        e.length &&
        typeof e[e.length - 1] == 'string' &&
        (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const t = this;
    let n = !1;
    return function (...i) {
      n || ((n = !0), t.packet({ type: ze.ACK, id: e, data: i }));
    };
  }
  onack(e) {
    const t = this.acks[e.id];
    typeof t == 'function' && (t.apply(this, e.data), delete this.acks[e.id]);
  }
  onconnect(e, t) {
    (this.id = e),
      (this.recovered = t && this._pid === t),
      (this._pid = t),
      (this.connected = !0),
      this.emitBuffered(),
      this.emitReserved('connect'),
      this._drainQueue(!0);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)),
      (this.receiveBuffer = []),
      this.sendBuffer.forEach((e) => {
        this.notifyOutgoingListeners(e), this.packet(e);
      }),
      (this.sendBuffer = []);
  }
  ondisconnect() {
    this.destroy(), this.onclose('io server disconnect');
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
      this.io._destroy(this);
  }
  disconnect() {
    return (
      this.connected && this.packet({ type: ze.DISCONNECT }),
      this.destroy(),
      this.connected && this.onclose('io client disconnect'),
      this
    );
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return (this.flags.compress = e), this;
  }
  get volatile() {
    return (this.flags.volatile = !0), this;
  }
  timeout(e) {
    return (this.flags.timeout = e), this;
  }
  onAny(e) {
    return (
      (this._anyListeners = this._anyListeners || []),
      this._anyListeners.push(e),
      this
    );
  }
  prependAny(e) {
    return (
      (this._anyListeners = this._anyListeners || []),
      this._anyListeners.unshift(e),
      this
    );
  }
  offAny(e) {
    if (!this._anyListeners) return this;
    if (e) {
      const t = this._anyListeners;
      for (let n = 0; n < t.length; n++)
        if (e === t[n]) return t.splice(n, 1), this;
    } else this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.push(e),
      this
    );
  }
  prependAnyOutgoing(e) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.unshift(e),
      this
    );
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners) return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let n = 0; n < t.length; n++)
        if (e === t[n]) return t.splice(n, 1), this;
    } else this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const n of t) n.apply(this, e.data);
    }
  }
}
function gs(r) {
  (r = r || {}),
    (this.ms = r.min || 100),
    (this.max = r.max || 1e4),
    (this.factor = r.factor || 2),
    (this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0),
    (this.attempts = 0);
}
gs.prototype.duration = function () {
  var r = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(),
      t = Math.floor(e * this.jitter * r);
    r = Math.floor(e * 10) & 1 ? r + t : r - t;
  }
  return Math.min(r, this.max) | 0;
};
gs.prototype.reset = function () {
  this.attempts = 0;
};
gs.prototype.setMin = function (r) {
  this.ms = r;
};
gs.prototype.setMax = function (r) {
  this.max = r;
};
gs.prototype.setJitter = function (r) {
  this.jitter = r;
};
class Yc extends gt {
  constructor(e, t) {
    var n;
    super(),
      (this.nsps = {}),
      (this.subs = []),
      e && typeof e == 'object' && ((t = e), (e = void 0)),
      (t = t || {}),
      (t.path = t.path || '/socket.io'),
      (this.opts = t),
      _a(this, t),
      this.reconnection(t.reconnection !== !1),
      this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0),
      this.reconnectionDelay(t.reconnectionDelay || 1e3),
      this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3),
      this.randomizationFactor(
        (n = t.randomizationFactor) !== null && n !== void 0 ? n : 0.5
      ),
      (this.backoff = new gs({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      })),
      this.timeout(t.timeout == null ? 2e4 : t.timeout),
      (this._readyState = 'closed'),
      (this.uri = e);
    const i = t.parser || H_;
    (this.encoder = new i.Encoder()),
      (this.decoder = new i.Decoder()),
      (this._autoConnect = t.autoConnect !== !1),
      this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length
      ? ((this._reconnection = !!e), this)
      : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0
      ? this._reconnectionAttempts
      : ((this._reconnectionAttempts = e), this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0
      ? this._reconnectionDelay
      : ((this._reconnectionDelay = e),
        (t = this.backoff) === null || t === void 0 || t.setMin(e),
        this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0
      ? this._randomizationFactor
      : ((this._randomizationFactor = e),
        (t = this.backoff) === null || t === void 0 || t.setJitter(e),
        this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0
      ? this._reconnectionDelayMax
      : ((this._reconnectionDelayMax = e),
        (t = this.backoff) === null || t === void 0 || t.setMax(e),
        this);
  }
  timeout(e) {
    return arguments.length ? ((this._timeout = e), this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting &&
      this._reconnection &&
      this.backoff.attempts === 0 &&
      this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf('open')) return this;
    this.engine = new tp(this.uri, this.opts);
    const t = this.engine,
      n = this;
    (this._readyState = 'opening'), (this.skipReconnect = !1);
    const i = Rn(t, 'open', function () {
        n.onopen(), e && e();
      }),
      s = (a) => {
        this.cleanup(),
          (this._readyState = 'closed'),
          this.emitReserved('error', a),
          e ? e(a) : this.maybeReconnectOnOpen();
      },
      o = Rn(t, 'error', s);
    if (this._timeout !== !1) {
      const a = this._timeout,
        c = this.setTimeoutFn(() => {
          i(), s(new Error('timeout')), t.close();
        }, a);
      this.opts.autoUnref && c.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(c);
        });
    }
    return this.subs.push(i), this.subs.push(o), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), (this._readyState = 'open'), this.emitReserved('open');
    const e = this.engine;
    this.subs.push(
      Rn(e, 'ping', this.onping.bind(this)),
      Rn(e, 'data', this.ondata.bind(this)),
      Rn(e, 'error', this.onerror.bind(this)),
      Rn(e, 'close', this.onclose.bind(this)),
      Rn(this.decoder, 'decoded', this.ondecoded.bind(this))
    );
  }
  onping() {
    this.emitReserved('ping');
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose('parse error', t);
    }
  }
  ondecoded(e) {
    Nl(() => {
      this.emitReserved('packet', e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved('error', e);
  }
  socket(e, t) {
    let n = this.nsps[e];
    return (
      n
        ? this._autoConnect && !n.active && n.connect()
        : ((n = new ip(this, e, t)), (this.nsps[e] = n)),
      n
    );
  }
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const n of t) if (this.nsps[n].active) return;
    this._close();
  }
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let n = 0; n < t.length; n++) this.engine.write(t[n], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()),
      (this.subs.length = 0),
      this.decoder.destroy();
  }
  _close() {
    (this.skipReconnect = !0),
      (this._reconnecting = !1),
      this.onclose('forced close'),
      this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(e, t) {
    this.cleanup(),
      this.backoff.reset(),
      (this._readyState = 'closed'),
      this.emitReserved('close', e, t),
      this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect) return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(),
        this.emitReserved('reconnect_failed'),
        (this._reconnecting = !1);
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const n = this.setTimeoutFn(() => {
        e.skipReconnect ||
          (this.emitReserved('reconnect_attempt', e.backoff.attempts),
          !e.skipReconnect &&
            e.open((i) => {
              i
                ? ((e._reconnecting = !1),
                  e.reconnect(),
                  this.emitReserved('reconnect_error', i))
                : e.onreconnect();
            }));
      }, t);
      this.opts.autoUnref && n.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(n);
        });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    (this._reconnecting = !1),
      this.backoff.reset(),
      this.emitReserved('reconnect', e);
  }
}
const bs = {};
function Ko(r, e) {
  typeof r == 'object' && ((e = r), (r = void 0)), (e = e || {});
  const t = L_(r, e.path || '/socket.io'),
    n = t.source,
    i = t.id,
    s = t.path,
    o = bs[i] && s in bs[i].nsps,
    a = e.forceNew || e['force new connection'] || e.multiplex === !1 || o;
  let c;
  return (
    a ? (c = new Yc(n, e)) : (bs[i] || (bs[i] = new Yc(n, e)), (c = bs[i])),
    t.query && !e.query && (e.query = t.queryKey),
    c.socket(t.path, e)
  );
}
Object.assign(Ko, { Manager: Yc, Socket: ip, io: Ko, connect: Ko });
const V_ = (r, e) => {
    localStorage.setItem(e, r);
  },
  W_ = (r) => localStorage.getItem(r) ?? '';
var Bl = { exports: {} };
function zl() {}
zl.prototype = {
  on: function (r, e, t) {
    var n = this.e || (this.e = {});
    return (n[r] || (n[r] = [])).push({ fn: e, ctx: t }), this;
  },
  once: function (r, e, t) {
    var n = this;
    function i() {
      n.off(r, i), e.apply(t, arguments);
    }
    return (i._ = e), this.on(r, i, t);
  },
  emit: function (r) {
    var e = [].slice.call(arguments, 1),
      t = ((this.e || (this.e = {}))[r] || []).slice(),
      n = 0,
      i = t.length;
    for (n; n < i; n++) t[n].fn.apply(t[n].ctx, e);
    return this;
  },
  off: function (r, e) {
    var t = this.e || (this.e = {}),
      n = t[r],
      i = [];
    if (n && e)
      for (var s = 0, o = n.length; s < o; s++)
        n[s].fn !== e && n[s].fn._ !== e && i.push(n[s]);
    return i.length ? (t[r] = i) : delete t[r], this;
  }
};
Bl.exports = zl;
Bl.exports.TinyEmitter = zl;
var q_ = Bl.exports;
const X_ = em(q_),
  Kc = new X_(),
  Rt = new (class {
    constructor() {
      console.log('Gno-Client actions init'), console.log(Ko);
    }
    setToken(r) {
      V_(r, 'token');
    }
    getToken() {
      return W_('token');
    }
    createGame(r) {
      return new Promise((e) => {
        console.log(r);
        const t = ['w', 'b'][Math.round(Math.random())],
          n = {
            me: { color: t, id: 'glnaglnaglnaglnae558' },
            rival: { color: t === 'w' ? 'b' : 'w', id: 'grbqszfoiqefouqiz254' }
          };
        setTimeout(() => e(n), 1e3), this.listenDraw();
      });
    }
    getRivalMove(r, e = !1) {
      return new Promise((t) => {
        if (e) {
          const n = r.moves(),
            i = Math.floor(Math.random() * n.length);
          setTimeout(() => t(n[i]), 1e3);
        } else t('INSERT_MOVE_HERE');
      });
    }
    makeMove(r, e, t = 0) {
      return new Promise((n) => {
        console.log(r + ' - ' + e + ' - ' + t), setTimeout(() => n(!0), 200);
      });
    }
    isGameover(r) {
      return new Promise((e) => {
        console.log(r), setTimeout(() => e(!0), 200);
      });
    }
    requestDraw() {
      return new Promise((r) => {
        setTimeout(() => r(!1), 9e3);
      });
    }
    requestResign() {
      return console.log('resign'), !0;
    }
    listenDraw() {
      setTimeout(() => {
        console.log('Draw proposition'), Kc.emit('drawPropal');
      }, 8e3);
    }
    declineDraw() {
      console.log('draw refused');
    }
    acceptDraw() {
      console.log('draw accepted');
    }
    getUserData() {
      console.log('getUserData');
    }
    getUserScore() {}
    getLeaderbord() {}
    getBlitzRating() {
      return { loses: 13, wins: 0, draws: 2 };
    }
    getRapidRating() {
      return { loses: 2, wins: 13, draws: 1 };
    }
    getBlitzLeaders() {
      return [
        { token: 'azerty1234' },
        { token: 'qsdfgt765' },
        { token: 'UJHFGVC565' },
        { token: 'azerty1234' },
        { token: 'qsdfgt765' },
        { token: 'UJHFGVC565' },
        { token: 'azerty1234' },
        { token: 'qsdfgt765' },
        { token: 'UJHFGVC565' },
        { token: 'qsdfgt765' }
      ];
    }
    getRapidLeaders() {
      return [
        { token: 'azerty1234erfezg' },
        { token: 'qsdfgt765ezrgach' },
        { token: 'UJHFGVC565pokuna' },
        { token: 'azerty1234' },
        { token: 'qsdfgt765' },
        { token: 'UJHFGVC565' },
        { token: 'azerty1234' },
        { token: 'qsdfgt765' },
        { token: 'UJHFGVC565' },
        { token: 'qsdfgt765' }
      ];
    }
    destroy() {}
  })(),
  j_ = class extends Wn.Component {
    constructor(e) {
      super(e);
      tn(this, 'eventsConfig', {
        pressOnCtrl1: {
          e: 'keypress',
          target: document,
          cb: this._pressOnCtrl1.bind(this)
        },
        clickOnCtrl1: {
          e: 'click',
          target: document.querySelector('#js-gameoptions-ctr1'),
          cb: this._clickOnCtrl1.bind(this)
        },
        clickOnCtrl0: {
          e: 'click',
          target: document.querySelector('#js-gameoptions-ctr0'),
          cb: this._clickOnCtrl0.bind(this)
        }
      });
      (this.states = [
        { name: 'token', panels: ['token'], ctrls: ['cross', 'Connection'] },
        { name: 'token', panels: ['game'], ctrls: ['arrow', 'Play'] }
      ]),
        (this.lookingForRival = !1),
        (this.currentState = 0),
        (this.timer = 0),
        (this.timers = {
          rapid: [
            [10, 0],
            [10, 5],
            [15, 10]
          ],
          blitz: [
            [3, 0],
            [3, 2],
            [5, 0],
            [5, 3]
          ]
        }),
        (this.options = { token: '', category: 'rapid', timer: [10, 0] }),
        (this.events = {});
    }
    init() {
      console.log('PlayControls component init'),
        (this.DOM.paneConnection = this.DOM.el.querySelector('#js-connection')),
        (this.DOM.paneCategory = this.DOM.el.querySelector('#js-category')),
        (this.DOM.paneTimer = this.DOM.el.querySelector('#js-timer')),
        (this.DOM.paneLoader = this.DOM.el.querySelector('#js-paneloader')),
        (this.DOM.categoryBtns = [
          ...this.DOM.el.querySelectorAll('.js-categoryUpdate')
        ]),
        (this.DOM.categorySwitch =
          this.DOM.el.querySelector('#js-categorySwitch')),
        (this.DOM.timerBtns = [
          ...this.DOM.el.querySelectorAll('.js-timerUpdate')
        ]),
        (this.DOM.timerDisplay = this.DOM.el.querySelector('#js-timerdisplay')),
        (this.DOM.timerIncrement =
          this.DOM.el.querySelector('#js-timerincrement')),
        (this.DOM.ctrl1 = this.DOM.el.querySelector('#js-gameoptions-ctr1')),
        (this.events.clickOnCtrl0 = this.on(this.eventsConfig.clickOnCtrl0)),
        (this.events.clickOnCtrl1 = this.on(this.eventsConfig.clickOnCtrl1)),
        (this.events.pressOnCtrl1 = this.on(this.eventsConfig.pressOnCtrl1)),
        this.DOM.categoryBtns.forEach((e, t) => {
          this.events['clickOnCategory' + t] = this.on({
            e: 'change',
            target: e,
            cb: this._updateCategory.bind(this)
          });
        }),
        this.DOM.timerBtns.forEach((e, t) => {
          this.events['clickOnTimer' + t] = this.on({
            e: 'click',
            target: e,
            cb: this._updateTimer.bind(this)
          });
        }),
        (this.switchAnimation1 = Z.timeline({ paused: !0 })
          .to(this.DOM.paneConnection, {
            autoAlpha: 0,
            display: 'none',
            duration: 0.6
          })
          .to(this.DOM.paneCategory, {
            autoAlpha: 1,
            display: 'flex',
            duration: 0.6
          })
          .to(
            this.DOM.paneTimer,
            { autoAlpha: 1, display: 'flex', duration: 0.6 },
            '<'
          )),
        (this.switchAnimation2 = Z.timeline({ paused: !0 })
          .to(this.DOM.paneCategory, {
            autoAlpha: 0,
            display: 'none',
            duration: 0.6
          })
          .to(
            this.DOM.paneTimer,
            { autoAlpha: 0, display: 'none', duration: 0.6 },
            '<'
          )
          .to(this.DOM.ctrl1, { autoAlpha: 0, duration: 0.6 }, '<')
          .to(this.DOM.paneLoader, {
            autoAlpha: 1,
            display: 'flex',
            duration: 0.6
          })),
        (this.DOM.timerDisplay.innerHTML = this.options.timer[0]),
        (this.DOM.timerIncrement.innerHTML = this.options.timer[1]),
        Rt.getToken() && this._clickOnCtrl1(null, !0),
        this.appear();
    }
    _clickOnCtrl0() {
      this.currentState--,
        this.currentState === 1
          ? (this.switchAnimation2.reverse(), (this.lookingForRival = !1))
          : this.call('goTo', ['/'], 'Router');
    }
    _pressOnCtrl1(e) {
      (e.keyCode ? e.keyCode : e.which) === 13 && this._clickOnCtrl1(e);
    }
    async _clickOnCtrl1(e, t = !1) {
      if ((this.currentState++, this.currentState === 1))
        (this.options.token = this._inputToken()),
          (this.DOM.ctrl1.innerHTML = this.states[this.currentState].ctrls[1]),
          this.switchAnimation1[t ? 'progress' : 'play'](t ? 1 : 0);
      else if (this.currentState === 2) {
        this.switchAnimation2.play(),
          this.call('changeStatus', ['action'], 'webgl'),
          this.call('moveScene', [''], 'webgl'),
          (this.lookingForRival = !0);
        const n = await Rt.createGame(this.options.timer);
        console.log(n),
          this.lookingForRival &&
            (this.call('disappear', [], 'webgl'),
            this.call('setCategory', [this.options.category], 'gamecategory'),
            this.disappear().then((i) => {
              this.call(
                'config',
                [
                  this.options.timer,
                  n.me.color,
                  n.me.id,
                  this.options.category
                ],
                'gameplayers',
                'me'
              ),
                this.call(
                  'config',
                  [
                    this.options.timer,
                    n.rival.color,
                    n.rival.id,
                    this.options.category
                  ],
                  'gameplayers',
                  'rival'
                ),
                Z.set('#js-background', { transformOrigin: 'center' }),
                Z.to('#js-background', { scale: 1.1, duration: 1.4 }),
                this.call('appear', [], 'gamecategory'),
                this.call('appear', '', 'gameplayers', 'me'),
                this.call('appear', '', 'gameplayers', 'rival'),
                this.call('appear', '', 'gamecontrols'),
                this.call('appear', '', 'gameboard'),
                this.call('startGame', n.me.color, 'gameboard');
            }));
      }
    }
    _inputToken() {
      const e = this.DOM.el.querySelector('#id-gameoptions-token').value || '';
      return Rt.getToken() || Rt.setToken(e), e;
    }
    _inputCategory() {
      return [...document.getElementsByName('category')].filter(
        (t) => t.checked
      )[0].value;
    }
    _updateTimer(e, t) {
      if (t !== void 0) {
        const n = t ?? 0;
        this.timer = n;
      } else {
        const n = e ? (e.currentTarget.dataset.ctrl === '+' ? 1 : -1) : 0;
        this.timer = Math.min(
          this.timers[this.options.category].length - 1,
          Math.max(0, this.timer + n)
        );
      }
      (this.options.timer = this.timers[this.options.category][this.timer]),
        (this.DOM.timerDisplay.innerHTML = this.options.timer[0]),
        (this.DOM.timerIncrement.innerHTML = this.options.timer[1]);
    }
    _updateCategory(e) {
      const t = e.currentTarget.value === 'blitz';
      (this.options.category = this._inputCategory()),
        this._updateTimer('', 0),
        Z.to('.gameoptions-sprite', {
          backgroundPosition: t ? '100%' : '0',
          ease: 'steps(9)',
          duration: 0.4
        }),
        Z.to(this.DOM.categorySwitch, { x: t ? '100%' : '0' }),
        Z.to('#js-categoryWord', { x: t ? '-60%' : '-15%' });
    }
    appear() {
      Z.to(this.DOM.el, { autoAlpha: 1 });
    }
    disappear() {
      const e = Z.timeline();
      return (
        e.to('#gameoptions-actions', { autoAlpha: 0, duration: 0.3 }),
        e.to('.js-pane', { autoAlpha: 0, duration: 0.3 }, 0),
        e.to(
          this.DOM.el,
          { autoAlpha: 0, height: 0, display: 'none', duration: 0.7 },
          '<+.1'
        ),
        this.off(this.events.pressOnCtrl1, this.eventsConfig.pressOnCtrl1),
        e
      );
    }
    destroy() {
      for (const e of Object.getOwnPropertyNames(this.options))
        delete this.options[e];
      this.switchAnimation1.kill(), this.switchAnimation2.kill();
    }
  };
function $c(r, e = r.length, t = 0, n = 3) {
  if (r.length <= e + t) return r;
  const i = r.slice(0, e),
    s = r.slice(-t),
    o = '.'.repeat(n);
  return `${i}${o}${s}`;
}
const Y_ = class extends Wn.Component {
    constructor(r) {
      super(r), (this.timerActive = !1);
    }
    init() {
      console.log('PlayPlay component init'),
        (this.player = this.DOM.el.dataset.componentId),
        (this.DOM.timer = this.DOM.el.querySelector('.js-playertime')),
        (this.DOM.pawns = this.DOM.el.querySelector('.js-playercapturepawns')),
        (this.DOM.token = this.DOM.el.querySelector('.js-playertoken')),
        (this.DOM.avatar = this.DOM.el.querySelector('.js-playeravatar')),
        (this.DOM.content = this.DOM.el.querySelector('.js-playercontent'));
    }
    appear() {
      Z.to(this.DOM.el, { autoAlpha: 1, display: 'flex' });
    }
    disappear() {
      return (
        Z.to('.player-info', { '--banner-x': '-100%' }),
        Z.to(this.DOM.el, { autoAlpha: 0, display: 'none', duration: 0.8 })
      );
    }
    config(r, e, t = '', n) {
      (this.DOM.token.innerHTML = $c(t, 4, 4)),
        (this.color = e),
        (this.category = n),
        (this.increment = r[1]),
        (this.timer = r[0] * 60),
        this._createTime(this.timer),
        Z.set(this.DOM.avatar, {
          backgroundColor: e === 'b' ? '#777777' : '#FFFFFF'
        }),
        Z.set(this.DOM.content, { color: e === 'b' ? '#777777' : '#FFFFFF' });
    }
    _createTime(r) {
      const e = (i) => (i < 10 ? '0' : '') + i,
        t = Math.floor(r / 60),
        n = Math.floor(r % 60);
      this.DOM.timer.innerHTML = `${e(t)}:${e(n)}`;
    }
    startTimer() {
      clearInterval(this.clock), (this.timerActive = !0);
      const r = () => {
        this.timer--,
          this._createTime(this.timer),
          this.timer <= 0 &&
            (clearInterval(this.clock),
            (this.DOM.timer.innerHTML = '00:00'),
            this.call('engine', ['timeout'], 'gameboard'));
      };
      this.clock = setInterval(r, 1e3);
    }
    stopTimer(r = !1) {
      clearInterval(this.clock),
        this.timerActive &&
          ((this.timer += r ? 0 : this.increment),
          this._createTime(this.timer)),
        (this.timerActive = !1);
    }
    capturePawn(r) {
      const e = document.createElement('DIV');
      (e.style.backgroundImage = `url('/img/images/pieces/staunton/basic/${
        (this.color === 'b' ? 'w' : 'b') + r.toUpperCase()
      }.png')`),
        this.DOM.pawns.appendChild(e);
    }
    finishGame() {
      (this.DOM.el.querySelector('.js-playergametype').innerHTML =
        this.category),
        (this.DOM.el.querySelector('.js-playerpoints').innerHTML = `${this.call(
          'getMoveNumber',
          '',
          'gameboard'
        )} moves`),
        Z.timeline()
          .set('.player-info', {
            '--banner-y': this.player === 'rival' ? 0 : '57.5%'
          })
          .to('.player-info', { '--banner-x': 0 })
          .to(
            this.DOM.el.querySelector('.js-playercontent'),
            { color: '#777777' },
            0
          )
          .to(
            this.DOM.el.querySelector('.js-playerfinish'),
            { autoAlpha: 1 },
            0.6
          )
          .to(
            this.DOM.el.querySelector('.js-playerwinner'),
            { autoAlpha: 1, scale: 1 },
            0.8
          );
    }
    destroy() {
      clearInterval(this.clock);
    }
  },
  K_ = class extends Wn.Component {
    constructor(r) {
      super(r);
    }
    init() {
      console.log('PlayFen component init');
    }
    appear() {
      Z.to(this.DOM.el, { autoAlpha: 1, display: 'flex' });
    }
    disappear() {}
    destroy() {}
  },
  $_ = class extends Wn.Component {
    constructor(r) {
      super(r), (this.events = {});
    }
    init() {
      console.log('PlayControls component init'),
        (this.action = 'void'),
        (this.pendingDraw = !1),
        (this.timer = 9),
        (this.contents = {
          resign: {
            title: 'Resign',
            content: 'Do you really want to Resign the Match?',
            btn: 'Confirm'
          },
          draw: {
            title: 'Draw',
            content: 'Do you really want to offer a draw?',
            btn: 'Confirm'
          },
          offer: {
            title: 'Draw',
            content: 'You were offered a Draw. Do you accept?',
            btn: 'Agree'
          }
        }),
        (this.DOM.ctr0 = this.DOM.el.querySelector('#js-gamecontrols-ctr0')),
        (this.DOM.ctr1 = this.DOM.el.querySelector('#js-gamecontrols-ctr1')),
        (this.DOM.ctrConfirm = this.DOM.el.querySelector(
          '#js-gamecontrols-confirm'
        )),
        (this.DOM.paneValidation = this.DOM.el.querySelector('#js-validation')),
        (this.DOM.title = this.DOM.el.querySelector('.js-gamecontrols-title')),
        (this.DOM.content = this.DOM.el.querySelector(
          '.js-gamecontrols-content'
        )),
        (this.DOM.timer = this.DOM.el.querySelector(
          '#js-gamecontrols-confirm-timer'
        )),
        (this.DOM.ctrConfirmContent = this.DOM.el.querySelector(
          '#js-gamecontrols-confirm-content'
        )),
        (this.events.clickOnCtr0 = this.on({
          e: 'click',
          target: this.DOM.ctr0,
          cb: this._clickOnCtr.bind(this, 'resign', !0)
        })),
        (this.events.clickOnCtr1 = this.on({
          e: 'click',
          target: this.DOM.ctr1,
          cb: this._clickOnCtr.bind(this, 'draw', !0)
        })),
        (this.events.clickOnConfirm = this.on({
          e: 'click',
          target: this.DOM.ctrConfirm,
          cb: this._clickOnConfirm.bind(this)
        })),
        Kc.on('drawPropal', this._getDrawProposition.bind(this)),
        (this.validationTL = Z.timeline({ paused: !0 }).to(
          this.DOM.paneValidation,
          { autoAlpha: 1, height: 'auto', duration: 0.6 }
        )),
        (this.disableCtr0TL = this._disableBtn(this.DOM.ctr0)),
        (this.disableCtr1TL = this._disableBtn(this.DOM.ctr1)),
        (this.swithCtr0TL = this._switchIconBtn(this.DOM.ctr0)),
        (this.swithCtr1TL = this._switchIconBtn(this.DOM.ctr1));
    }
    _disableBtn(r) {
      return Z.timeline({ paused: !0 })
        .set(r, { cursor: 'auto' })
        .to(r, {
          background: '#D9D9D9',
          color: '#FFFFFF',
          boxShadow: '0px 0px 0px 0px rgba(255,255,255,0)'
        });
    }
    _switchIconBtn(r) {
      return Z.timeline({ paused: !0 })
        .to(r.querySelector('.js-icon'), { autoAlpha: 0 })
        .to(r.querySelector('.js-cross'), { autoAlpha: 1 }, '<');
    }
    _updateContent(r) {
      (this.DOM.title.innerHTML = this.contents[r].title),
        (this.DOM.content.innerHTML = this.contents[r].content),
        (this.DOM.ctrConfirmContent.innerHTML = this.contents[r].btn);
    }
    _clickOnCtr(r, e) {
      this.action === 'void'
        ? (this._updateContent(r),
          (this.action = r === 'offer' ? 'draw' : r),
          this[r === 'resign' ? 'disableCtr1TL' : 'disableCtr0TL'].play(),
          this[r === 'resign' ? 'swithCtr0TL' : 'swithCtr1TL'].play(),
          this.validationTL.play())
        : this.action === r &&
          e &&
          (this.pendingDraw && this._declineOffer(),
          (this.action = 'void'),
          this[r === 'resign' ? 'disableCtr1TL' : 'disableCtr0TL'].reverse(),
          this[r === 'resign' ? 'swithCtr0TL' : 'swithCtr1TL'].reverse(),
          this.validationTL.reverse().then(() => {
            (this.DOM.timer.innerHTML = this.timer),
              Z.set(this.DOM.timer, { autoAlpha: 0, display: 'none' });
          }));
    }
    async _clickOnConfirm() {
      this.action === 'resign' &&
        (Rt.requestResign(), this.call('goTo', ['/'], 'router')),
        this.action === 'draw' &&
          (this.pendingDraw
            ? (clearInterval(this.pendingDraw),
              (this.timer = 9),
              (this.pendingDraw = null))
            : (await Rt.requestDraw()) &&
              this.call('engine', [!1, 'draw'], 'gameboard')),
        this.validationTL.reverse(),
        this[
          this.action === 'resign' ? 'disableCtr1TL' : 'disableCtr0TL'
        ].reverse(),
        this[
          this.action === 'resign' ? 'swithCtr0TL' : 'swithCtr1TL'
        ].reverse(),
        (this.action = 'void');
    }
    _declineOffer() {
      Rt.declineDraw(),
        clearInterval(this.pendingDraw),
        (this.timer = 9),
        (this.pendingDraw = null);
    }
    _getDrawProposition() {
      Z.set(this.DOM.timer, { autoAlpha: 1, display: 'inline-block' }),
        (this.pendingDraw = setInterval(() => {
          this.timer--,
            (this.DOM.timer.innerHTML = this.timer),
            this.timer <= 0 && (this._clickOnCtr('draw', !0), (this.timer = 9));
        }, 1e3)),
        this._clickOnCtr('offer', !1),
        console.log('propal received');
    }
    appear() {
      Z.to(this.DOM.el, { autoAlpha: 1, display: 'flex' });
    }
    disappear() {
      return Z.to(this.DOM.el, {
        autoAlpha: 0,
        display: 'none',
        duration: 0.8
      });
    }
    destroy() {
      Kc.off('drawPropal'),
        clearInterval(this.pendingDraw),
        this.validationTL.kill(),
        this.disableCtr0TL.kill(),
        this.disableCtr1TL.kill(),
        this.swithCtr0TL.kill(),
        this.swithCtr1TL.kill();
    }
  };
/**
 * @license
 * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */ const Ut = 'w',
  dn = 'b',
  St = 'p',
  Zc = 'n',
  $o = 'b',
  Ns = 'r',
  bi = 'q',
  bt = 'k',
  za = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
  nn = -1,
  Z_ = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q'
  },
  Ee = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64
  },
  we = {
    a8: 0,
    b8: 1,
    c8: 2,
    d8: 3,
    e8: 4,
    f8: 5,
    g8: 6,
    h8: 7,
    a7: 16,
    b7: 17,
    c7: 18,
    d7: 19,
    e7: 20,
    f7: 21,
    g7: 22,
    h7: 23,
    a6: 32,
    b6: 33,
    c6: 34,
    d6: 35,
    e6: 36,
    f6: 37,
    g6: 38,
    h6: 39,
    a5: 48,
    b5: 49,
    c5: 50,
    d5: 51,
    e5: 52,
    f5: 53,
    g5: 54,
    h5: 55,
    a4: 64,
    b4: 65,
    c4: 66,
    d4: 67,
    e4: 68,
    f4: 69,
    g4: 70,
    h4: 71,
    a3: 80,
    b3: 81,
    c3: 82,
    d3: 83,
    e3: 84,
    f3: 85,
    g3: 86,
    h3: 87,
    a2: 96,
    b2: 97,
    c2: 98,
    d2: 99,
    e2: 100,
    f2: 101,
    g2: 102,
    h2: 103,
    a1: 112,
    b1: 113,
    c1: 114,
    d1: 115,
    e1: 116,
    f1: 117,
    g1: 118,
    h1: 119
  },
  Ha = { b: [16, 32, 17, 15], w: [-16, -32, -17, -15] },
  Bh = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14],
    b: [-17, -15, 17, 15],
    r: [-16, 1, 16, -1],
    q: [-17, -16, -15, 1, 17, 16, 15, -1],
    k: [-17, -16, -15, 1, 17, 16, 15, -1]
  },
  J_ = [
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24,
    0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24,
    0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24,
    56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0,
    20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0,
    0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0,
    0, 0, 0, 20
  ],
  Q_ = [
    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16,
    0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,
    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16,
    0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0,
    -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0,
    0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0,
    -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0,
    -16, 0, 0, 0, 0, 0, 0, -17
  ],
  e0 = { p: 1, n: 2, b: 4, r: 8, q: 16, k: 32 },
  t0 = 'pnbrqkPNBRQK',
  zh = [Zc, $o, Ns, bi],
  n0 = 7,
  i0 = 6,
  r0 = 1,
  s0 = 0,
  _o = { [bt]: Ee.KSIDE_CASTLE, [bi]: Ee.QSIDE_CASTLE },
  pi = {
    w: [
      { square: we.a1, flag: Ee.QSIDE_CASTLE },
      { square: we.h1, flag: Ee.KSIDE_CASTLE }
    ],
    b: [
      { square: we.a8, flag: Ee.QSIDE_CASTLE },
      { square: we.h8, flag: Ee.KSIDE_CASTLE }
    ]
  },
  o0 = { b: r0, w: i0 },
  a0 = ['1-0', '0-1', '1/2-1/2', '*'];
function hr(r) {
  return r >> 4;
}
function Js(r) {
  return r & 15;
}
function rp(r) {
  return '0123456789'.indexOf(r) !== -1;
}
function on(r) {
  const e = Js(r),
    t = hr(r);
  return 'abcdefgh'.substring(e, e + 1) + '87654321'.substring(t, t + 1);
}
function Es(r) {
  return r === Ut ? dn : Ut;
}
function c0(r) {
  const e = r.split(/\s+/);
  if (e.length !== 6)
    return {
      ok: !1,
      error: 'Invalid FEN: must contain six space-delimited fields'
    };
  const t = parseInt(e[5], 10);
  if (isNaN(t) || t <= 0)
    return {
      ok: !1,
      error: 'Invalid FEN: move number must be a positive integer'
    };
  const n = parseInt(e[4], 10);
  if (isNaN(n) || n < 0)
    return {
      ok: !1,
      error:
        'Invalid FEN: half move counter number must be a non-negative integer'
    };
  if (!/^(-|[abcdefgh][36])$/.test(e[3]))
    return { ok: !1, error: 'Invalid FEN: en-passant square is invalid' };
  if (/[^kKqQ-]/.test(e[2]))
    return { ok: !1, error: 'Invalid FEN: castling availability is invalid' };
  if (!/^(w|b)$/.test(e[1]))
    return { ok: !1, error: 'Invalid FEN: side-to-move is invalid' };
  const i = e[0].split('/');
  if (i.length !== 8)
    return {
      ok: !1,
      error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows"
    };
  for (let o = 0; o < i.length; o++) {
    let a = 0,
      c = !1;
    for (let l = 0; l < i[o].length; l++)
      if (rp(i[o][l])) {
        if (c)
          return {
            ok: !1,
            error: 'Invalid FEN: piece data is invalid (consecutive number)'
          };
        (a += parseInt(i[o][l], 10)), (c = !0);
      } else {
        if (!/^[prnbqkPRNBQK]$/.test(i[o][l]))
          return {
            ok: !1,
            error: 'Invalid FEN: piece data is invalid (invalid piece)'
          };
        (a += 1), (c = !1);
      }
    if (a !== 8)
      return {
        ok: !1,
        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'
      };
  }
  if ((e[3][1] == '3' && e[1] == 'w') || (e[3][1] == '6' && e[1] == 'b'))
    return { ok: !1, error: 'Invalid FEN: illegal en-passant square' };
  const s = [
    { color: 'white', regex: /K/g },
    { color: 'black', regex: /k/g }
  ];
  for (const { color: o, regex: a } of s) {
    if (!a.test(e[0]))
      return { ok: !1, error: `Invalid FEN: missing ${o} king` };
    if ((e[0].match(a) || []).length > 1)
      return { ok: !1, error: `Invalid FEN: too many ${o} kings` };
  }
  return { ok: !0 };
}
function l0(r, e) {
  const t = r.from,
    n = r.to,
    i = r.piece;
  let s = 0,
    o = 0,
    a = 0;
  for (let c = 0, l = e.length; c < l; c++) {
    const h = e[c].from,
      f = e[c].to,
      u = e[c].piece;
    i === u &&
      t !== h &&
      n === f &&
      (s++, hr(t) === hr(h) && o++, Js(t) === Js(h) && a++);
  }
  return s > 0
    ? o > 0 && a > 0
      ? on(t)
      : a > 0
      ? on(t).charAt(1)
      : on(t).charAt(0)
    : '';
}
function mi(r, e, t, n, i, s = void 0, o = Ee.NORMAL) {
  const a = hr(n);
  if (i === St && (a === n0 || a === s0))
    for (let c = 0; c < zh.length; c++) {
      const l = zh[c];
      r.push({
        color: e,
        from: t,
        to: n,
        piece: i,
        captured: s,
        promotion: l,
        flags: o | Ee.PROMOTION
      });
    }
  else r.push({ color: e, from: t, to: n, piece: i, captured: s, flags: o });
}
function Hh(r) {
  let e = r.charAt(0);
  return e >= 'a' && e <= 'h'
    ? r.match(/[a-h]\d.*[a-h]\d/)
      ? void 0
      : St
    : ((e = e.toLowerCase()), e === 'o' ? bt : e);
}
function Ga(r) {
  return r.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
}
class h0 {
  constructor(e = za) {
    tn(this, '_board', new Array(128));
    tn(this, '_turn', Ut);
    tn(this, '_header', {});
    tn(this, '_kings', { w: nn, b: nn });
    tn(this, '_epSquare', -1);
    tn(this, '_halfMoves', 0);
    tn(this, '_moveNumber', 0);
    tn(this, '_history', []);
    tn(this, '_comments', {});
    tn(this, '_castling', { w: 0, b: 0 });
    this.load(e);
  }
  clear(e = !1) {
    (this._board = new Array(128)),
      (this._kings = { w: nn, b: nn }),
      (this._turn = Ut),
      (this._castling = { w: 0, b: 0 }),
      (this._epSquare = nn),
      (this._halfMoves = 0),
      (this._moveNumber = 1),
      (this._history = []),
      (this._comments = {}),
      (this._header = e ? this._header : {}),
      this._updateSetup(this.fen());
  }
  removeHeader(e) {
    e in this._header && delete this._header[e];
  }
  load(e, t = !1) {
    let n = e.split(/\s+/);
    if (n.length >= 2 && n.length < 6) {
      const c = ['-', '-', '0', '1'];
      e = n.concat(c.slice(-(6 - n.length))).join(' ');
    }
    n = e.split(/\s+/);
    const { ok: i, error: s } = c0(e);
    if (!i) throw new Error(s);
    const o = n[0];
    let a = 0;
    this.clear(t);
    for (let c = 0; c < o.length; c++) {
      const l = o.charAt(c);
      if (l === '/') a += 8;
      else if (rp(l)) a += parseInt(l, 10);
      else {
        const h = l < 'a' ? Ut : dn;
        this.put({ type: l.toLowerCase(), color: h }, on(a)), a++;
      }
    }
    (this._turn = n[1]),
      n[2].indexOf('K') > -1 && (this._castling.w |= Ee.KSIDE_CASTLE),
      n[2].indexOf('Q') > -1 && (this._castling.w |= Ee.QSIDE_CASTLE),
      n[2].indexOf('k') > -1 && (this._castling.b |= Ee.KSIDE_CASTLE),
      n[2].indexOf('q') > -1 && (this._castling.b |= Ee.QSIDE_CASTLE),
      (this._epSquare = n[3] === '-' ? nn : we[n[3]]),
      (this._halfMoves = parseInt(n[4], 10)),
      (this._moveNumber = parseInt(n[5], 10)),
      this._updateSetup(this.fen());
  }
  fen() {
    var s, o;
    let e = 0,
      t = '';
    for (let a = we.a8; a <= we.h1; a++) {
      if (this._board[a]) {
        e > 0 && ((t += e), (e = 0));
        const { color: c, type: l } = this._board[a];
        t += c === Ut ? l.toUpperCase() : l.toLowerCase();
      } else e++;
      (a + 1) & 136 &&
        (e > 0 && (t += e), a !== we.h1 && (t += '/'), (e = 0), (a += 8));
    }
    let n = '';
    this._castling[Ut] & Ee.KSIDE_CASTLE && (n += 'K'),
      this._castling[Ut] & Ee.QSIDE_CASTLE && (n += 'Q'),
      this._castling[dn] & Ee.KSIDE_CASTLE && (n += 'k'),
      this._castling[dn] & Ee.QSIDE_CASTLE && (n += 'q'),
      (n = n || '-');
    let i = '-';
    if (this._epSquare !== nn) {
      const a = this._epSquare + (this._turn === Ut ? 16 : -16),
        c = [a + 1, a - 1];
      for (const l of c) {
        if (l & 136) continue;
        const h = this._turn;
        if (
          ((s = this._board[l]) == null ? void 0 : s.color) === h &&
          ((o = this._board[l]) == null ? void 0 : o.type) === St
        ) {
          this._makeMove({
            color: h,
            from: l,
            to: this._epSquare,
            piece: St,
            captured: St,
            flags: Ee.EP_CAPTURE
          });
          const f = !this._isKingAttacked(h);
          if ((this._undoMove(), f)) {
            i = on(this._epSquare);
            break;
          }
        }
      }
    }
    return [t, this._turn, n, i, this._halfMoves, this._moveNumber].join(' ');
  }
  _updateSetup(e) {
    this._history.length > 0 ||
      (e !== za
        ? ((this._header.SetUp = '1'), (this._header.FEN = e))
        : (delete this._header.SetUp, delete this._header.FEN));
  }
  reset() {
    this.load(za);
  }
  get(e) {
    return this._board[we[e]] || !1;
  }
  put({ type: e, color: t }, n) {
    if (t0.indexOf(e.toLowerCase()) === -1 || !(n in we)) return !1;
    const i = we[n];
    return e == bt && !(this._kings[t] == nn || this._kings[t] == i)
      ? !1
      : ((this._board[i] = { type: e, color: t }),
        e === bt && (this._kings[t] = i),
        this._updateCastlingRights(),
        this._updateEnPassantSquare(),
        this._updateSetup(this.fen()),
        !0);
  }
  remove(e) {
    const t = this.get(e);
    return (
      delete this._board[we[e]],
      t && t.type === bt && (this._kings[t.color] = nn),
      this._updateCastlingRights(),
      this._updateEnPassantSquare(),
      this._updateSetup(this.fen()),
      t
    );
  }
  _updateCastlingRights() {
    var n, i, s, o, a, c, l, h, f, u, p, _;
    const e =
        ((n = this._board[we.e1]) == null ? void 0 : n.type) === bt &&
        ((i = this._board[we.e1]) == null ? void 0 : i.color) === Ut,
      t =
        ((s = this._board[we.e8]) == null ? void 0 : s.type) === bt &&
        ((o = this._board[we.e8]) == null ? void 0 : o.color) === dn;
    (!e ||
      ((a = this._board[we.a1]) == null ? void 0 : a.type) !== Ns ||
      ((c = this._board[we.a1]) == null ? void 0 : c.color) !== Ut) &&
      (this._castling.w &= ~Ee.QSIDE_CASTLE),
      (!e ||
        ((l = this._board[we.h1]) == null ? void 0 : l.type) !== Ns ||
        ((h = this._board[we.h1]) == null ? void 0 : h.color) !== Ut) &&
        (this._castling.w &= ~Ee.KSIDE_CASTLE),
      (!t ||
        ((f = this._board[we.a8]) == null ? void 0 : f.type) !== Ns ||
        ((u = this._board[we.a8]) == null ? void 0 : u.color) !== dn) &&
        (this._castling.b &= ~Ee.QSIDE_CASTLE),
      (!t ||
        ((p = this._board[we.h8]) == null ? void 0 : p.type) !== Ns ||
        ((_ = this._board[we.h8]) == null ? void 0 : _.color) !== dn) &&
        (this._castling.b &= ~Ee.KSIDE_CASTLE);
  }
  _updateEnPassantSquare() {
    var s, o;
    if (this._epSquare === nn) return;
    const e = this._epSquare + (this._turn === Ut ? -16 : 16),
      t = this._epSquare + (this._turn === Ut ? 16 : -16),
      n = [t + 1, t - 1];
    if (
      this._board[e] !== null ||
      this._board[this._epSquare] !== null ||
      ((s = this._board[t]) == null ? void 0 : s.color) !== Es(this._turn) ||
      ((o = this._board[t]) == null ? void 0 : o.type) !== St
    ) {
      this._epSquare = nn;
      return;
    }
    const i = (a) => {
      var c, l;
      return (
        !(a & 136) &&
        ((c = this._board[a]) == null ? void 0 : c.color) === this._turn &&
        ((l = this._board[a]) == null ? void 0 : l.type) === St
      );
    };
    n.some(i) || (this._epSquare = nn);
  }
  _attacked(e, t) {
    for (let n = we.a8; n <= we.h1; n++) {
      if (n & 136) {
        n += 7;
        continue;
      }
      if (this._board[n] === void 0 || this._board[n].color !== e) continue;
      const i = this._board[n],
        s = n - t;
      if (s === 0) continue;
      const o = s + 119;
      if (J_[o] & e0[i.type]) {
        if (i.type === St) {
          if (s > 0) {
            if (i.color === Ut) return !0;
          } else if (i.color === dn) return !0;
          continue;
        }
        if (i.type === 'n' || i.type === 'k') return !0;
        const a = Q_[o];
        let c = n + a,
          l = !1;
        for (; c !== t; ) {
          if (this._board[c] != null) {
            l = !0;
            break;
          }
          c += a;
        }
        if (!l) return !0;
      }
    }
    return !1;
  }
  _isKingAttacked(e) {
    const t = this._kings[e];
    return t === -1 ? !1 : this._attacked(Es(e), t);
  }
  isAttacked(e, t) {
    return this._attacked(t, we[e]);
  }
  isCheck() {
    return this._isKingAttacked(this._turn);
  }
  inCheck() {
    return this.isCheck();
  }
  isCheckmate() {
    return this.isCheck() && this._moves().length === 0;
  }
  isStalemate() {
    return !this.isCheck() && this._moves().length === 0;
  }
  isInsufficientMaterial() {
    const e = { b: 0, n: 0, r: 0, q: 0, k: 0, p: 0 },
      t = [];
    let n = 0,
      i = 0;
    for (let s = we.a8; s <= we.h1; s++) {
      if (((i = (i + 1) % 2), s & 136)) {
        s += 7;
        continue;
      }
      const o = this._board[s];
      o &&
        ((e[o.type] = o.type in e ? e[o.type] + 1 : 1),
        o.type === $o && t.push(i),
        n++);
    }
    if (n === 2) return !0;
    if (n === 3 && (e[$o] === 1 || e[Zc] === 1)) return !0;
    if (n === e[$o] + 2) {
      let s = 0;
      const o = t.length;
      for (let a = 0; a < o; a++) s += t[a];
      if (s === 0 || s === o) return !0;
    }
    return !1;
  }
  isThreefoldRepetition() {
    const e = [],
      t = {};
    let n = !1;
    for (;;) {
      const i = this._undoMove();
      if (!i) break;
      e.push(i);
    }
    for (;;) {
      const i = this.fen().split(' ').slice(0, 4).join(' ');
      (t[i] = i in t ? t[i] + 1 : 1), t[i] >= 3 && (n = !0);
      const s = e.pop();
      if (s) this._makeMove(s);
      else break;
    }
    return n;
  }
  isDraw() {
    return (
      this._halfMoves >= 100 ||
      this.isStalemate() ||
      this.isInsufficientMaterial() ||
      this.isThreefoldRepetition()
    );
  }
  isGameOver() {
    return this.isCheckmate() || this.isStalemate() || this.isDraw();
  }
  moves({ verbose: e = !1, square: t = void 0, piece: n = void 0 } = {}) {
    const i = this._moves({ square: t, piece: n });
    return e
      ? i.map((s) => this._makePretty(s))
      : i.map((s) => this._moveToSan(s, i));
  }
  _moves({ legal: e = !0, piece: t = void 0, square: n = void 0 } = {}) {
    var p;
    const i = n ? n.toLowerCase() : void 0,
      s = t == null ? void 0 : t.toLowerCase(),
      o = [],
      a = this._turn,
      c = Es(a);
    let l = we.a8,
      h = we.h1,
      f = !1;
    if (i)
      if (i in we) (l = h = we[i]), (f = !0);
      else return [];
    for (let _ = l; _ <= h; _++) {
      if (_ & 136) {
        _ += 7;
        continue;
      }
      if (!this._board[_] || this._board[_].color === c) continue;
      const { type: g } = this._board[_];
      let d;
      if (g === St) {
        if (s && s !== g) continue;
        (d = _ + Ha[a][0]),
          this._board[d] ||
            (mi(o, a, _, d, St),
            (d = _ + Ha[a][1]),
            o0[a] === hr(_) &&
              !this._board[d] &&
              mi(o, a, _, d, St, void 0, Ee.BIG_PAWN));
        for (let m = 2; m < 4; m++)
          (d = _ + Ha[a][m]),
            !(d & 136) &&
              (((p = this._board[d]) == null ? void 0 : p.color) === c
                ? mi(o, a, _, d, St, this._board[d].type, Ee.CAPTURE)
                : d === this._epSquare &&
                  mi(o, a, _, d, St, St, Ee.EP_CAPTURE));
      } else {
        if (s && s !== g) continue;
        for (let m = 0, y = Bh[g].length; m < y; m++) {
          const v = Bh[g][m];
          for (d = _; (d += v), !(d & 136); ) {
            if (!this._board[d]) mi(o, a, _, d, g);
            else {
              if (this._board[d].color === a) break;
              mi(o, a, _, d, g, this._board[d].type, Ee.CAPTURE);
              break;
            }
            if (g === Zc || g === bt) break;
          }
        }
      }
    }
    if ((s === void 0 || s === bt) && (!f || h === this._kings[a])) {
      if (this._castling[a] & Ee.KSIDE_CASTLE) {
        const _ = this._kings[a],
          g = _ + 2;
        !this._board[_ + 1] &&
          !this._board[g] &&
          !this._attacked(c, this._kings[a]) &&
          !this._attacked(c, _ + 1) &&
          !this._attacked(c, g) &&
          mi(o, a, this._kings[a], g, bt, void 0, Ee.KSIDE_CASTLE);
      }
      if (this._castling[a] & Ee.QSIDE_CASTLE) {
        const _ = this._kings[a],
          g = _ - 2;
        !this._board[_ - 1] &&
          !this._board[_ - 2] &&
          !this._board[_ - 3] &&
          !this._attacked(c, this._kings[a]) &&
          !this._attacked(c, _ - 1) &&
          !this._attacked(c, g) &&
          mi(o, a, this._kings[a], g, bt, void 0, Ee.QSIDE_CASTLE);
      }
    }
    if (!e || this._kings[a] === -1) return o;
    const u = [];
    for (let _ = 0, g = o.length; _ < g; _++)
      this._makeMove(o[_]),
        this._isKingAttacked(a) || u.push(o[_]),
        this._undoMove();
    return u;
  }
  move(e, { strict: t = !1 } = {}) {
    let n = null;
    if (typeof e == 'string') n = this._moveFromSan(e, t);
    else if (typeof e == 'object') {
      const s = this._moves();
      for (let o = 0, a = s.length; o < a; o++)
        if (
          e.from === on(s[o].from) &&
          e.to === on(s[o].to) &&
          (!('promotion' in s[o]) || e.promotion === s[o].promotion)
        ) {
          n = s[o];
          break;
        }
    }
    if (!n)
      throw typeof e == 'string'
        ? new Error(`Invalid move: ${e}`)
        : new Error(`Invalid move: ${JSON.stringify(e)}`);
    const i = this._makePretty(n);
    return this._makeMove(n), i;
  }
  _push(e) {
    this._history.push({
      move: e,
      kings: { b: this._kings.b, w: this._kings.w },
      turn: this._turn,
      castling: { b: this._castling.b, w: this._castling.w },
      epSquare: this._epSquare,
      halfMoves: this._halfMoves,
      moveNumber: this._moveNumber
    });
  }
  _makeMove(e) {
    const t = this._turn,
      n = Es(t);
    if (
      (this._push(e),
      (this._board[e.to] = this._board[e.from]),
      delete this._board[e.from],
      e.flags & Ee.EP_CAPTURE &&
        (this._turn === dn
          ? delete this._board[e.to - 16]
          : delete this._board[e.to + 16]),
      e.promotion && (this._board[e.to] = { type: e.promotion, color: t }),
      this._board[e.to].type === bt)
    ) {
      if (((this._kings[t] = e.to), e.flags & Ee.KSIDE_CASTLE)) {
        const i = e.to - 1,
          s = e.to + 1;
        (this._board[i] = this._board[s]), delete this._board[s];
      } else if (e.flags & Ee.QSIDE_CASTLE) {
        const i = e.to + 1,
          s = e.to - 2;
        (this._board[i] = this._board[s]), delete this._board[s];
      }
      this._castling[t] = 0;
    }
    if (this._castling[t]) {
      for (let i = 0, s = pi[t].length; i < s; i++)
        if (e.from === pi[t][i].square && this._castling[t] & pi[t][i].flag) {
          this._castling[t] ^= pi[t][i].flag;
          break;
        }
    }
    if (this._castling[n]) {
      for (let i = 0, s = pi[n].length; i < s; i++)
        if (e.to === pi[n][i].square && this._castling[n] & pi[n][i].flag) {
          this._castling[n] ^= pi[n][i].flag;
          break;
        }
    }
    e.flags & Ee.BIG_PAWN
      ? t === dn
        ? (this._epSquare = e.to - 16)
        : (this._epSquare = e.to + 16)
      : (this._epSquare = nn),
      e.piece === St
        ? (this._halfMoves = 0)
        : e.flags & (Ee.CAPTURE | Ee.EP_CAPTURE)
        ? (this._halfMoves = 0)
        : this._halfMoves++,
      t === dn && this._moveNumber++,
      (this._turn = n);
  }
  undo() {
    const e = this._undoMove();
    return e ? this._makePretty(e) : null;
  }
  _undoMove() {
    const e = this._history.pop();
    if (e === void 0) return null;
    const t = e.move;
    (this._kings = e.kings),
      (this._turn = e.turn),
      (this._castling = e.castling),
      (this._epSquare = e.epSquare),
      (this._halfMoves = e.halfMoves),
      (this._moveNumber = e.moveNumber);
    const n = this._turn,
      i = Es(n);
    if (
      ((this._board[t.from] = this._board[t.to]),
      (this._board[t.from].type = t.piece),
      delete this._board[t.to],
      t.captured)
    )
      if (t.flags & Ee.EP_CAPTURE) {
        let s;
        n === dn ? (s = t.to - 16) : (s = t.to + 16),
          (this._board[s] = { type: St, color: i });
      } else this._board[t.to] = { type: t.captured, color: i };
    if (t.flags & (Ee.KSIDE_CASTLE | Ee.QSIDE_CASTLE)) {
      let s, o;
      t.flags & Ee.KSIDE_CASTLE
        ? ((s = t.to + 1), (o = t.to - 1))
        : ((s = t.to - 2), (o = t.to + 1)),
        (this._board[s] = this._board[o]),
        delete this._board[o];
    }
    return t;
  }
  pgn({
    newline: e = `
`,
    maxWidth: t = 0
  } = {}) {
    const n = [];
    let i = !1;
    for (const u in this._header)
      n.push('[' + u + ' "' + this._header[u] + '"]' + e), (i = !0);
    i && this._history.length && n.push(e);
    const s = (u) => {
        const p = this._comments[this.fen()];
        if (typeof p < 'u') {
          const _ = u.length > 0 ? ' ' : '';
          u = `${u}${_}{${p}}`;
        }
        return u;
      },
      o = [];
    for (; this._history.length > 0; ) o.push(this._undoMove());
    const a = [];
    let c = '';
    for (o.length === 0 && a.push(s('')); o.length > 0; ) {
      c = s(c);
      const u = o.pop();
      if (!u) break;
      if (!this._history.length && u.color === 'b') {
        const p = `${this._moveNumber}. ...`;
        c = c ? `${c} ${p}` : p;
      } else
        u.color === 'w' &&
          (c.length && a.push(c), (c = this._moveNumber + '.'));
      (c = c + ' ' + this._moveToSan(u, this._moves({ legal: !0 }))),
        this._makeMove(u);
    }
    if (
      (c.length && a.push(s(c)),
      typeof this._header.Result < 'u' && a.push(this._header.Result),
      t === 0)
    )
      return n.join('') + a.join(' ');
    const l = function () {
        return n.length > 0 && n[n.length - 1] === ' ' ? (n.pop(), !0) : !1;
      },
      h = function (u, p) {
        for (const _ of p.split(' '))
          if (_) {
            if (u + _.length > t) {
              for (; l(); ) u--;
              n.push(e), (u = 0);
            }
            n.push(_), (u += _.length), n.push(' '), u++;
          }
        return l() && u--, u;
      };
    let f = 0;
    for (let u = 0; u < a.length; u++) {
      if (f + a[u].length > t && a[u].includes('{')) {
        f = h(f, a[u]);
        continue;
      }
      f + a[u].length > t && u !== 0
        ? (n[n.length - 1] === ' ' && n.pop(), n.push(e), (f = 0))
        : u !== 0 && (n.push(' '), f++),
        n.push(a[u]),
        (f += a[u].length);
    }
    return n.join('');
  }
  header(...e) {
    for (let t = 0; t < e.length; t += 2)
      typeof e[t] == 'string' &&
        typeof e[t + 1] == 'string' &&
        (this._header[e[t]] = e[t + 1]);
    return this._header;
  }
  loadPgn(
    e,
    {
      strict: t = !1,
      newlineChar: n = `\r?
`
    } = {}
  ) {
    function i(v) {
      return v.replace(/\\/g, '\\');
    }
    function s(v) {
      const x = {},
        S = v.split(new RegExp(i(n)));
      let b = '',
        T = '';
      for (let C = 0; C < S.length; C++) {
        const M = /^\s*\[\s*([A-Za-z]+)\s*"(.*)"\s*\]\s*$/;
        (b = S[C].replace(M, '$1')),
          (T = S[C].replace(M, '$2')),
          b.trim().length > 0 && (x[b] = T);
      }
      return x;
    }
    e = e.trim();
    const a = new RegExp(
        '^(\\[((?:' +
          i(n) +
          ')|.)*\\])((?:\\s*' +
          i(n) +
          '){2}|(?:\\s*' +
          i(n) +
          ')*$)'
      ).exec(e),
      c = a && a.length >= 2 ? a[1] : '';
    this.reset();
    const l = s(c);
    let h = '';
    for (const v in l)
      v.toLowerCase() === 'fen' && (h = l[v]), this.header(v, l[v]);
    if (!t) h && this.load(h, !0);
    else if (l.SetUp === '1') {
      if (!('FEN' in l))
        throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');
      this.load(l.FEN, !0);
    }
    function f(v) {
      return Array.from(v)
        .map(function (x) {
          return x.charCodeAt(0) < 128
            ? x.charCodeAt(0).toString(16)
            : encodeURIComponent(x).replace(/%/g, '').toLowerCase();
        })
        .join('');
    }
    function u(v) {
      return v.length == 0
        ? ''
        : decodeURIComponent('%' + (v.match(/.{1,2}/g) || []).join('%'));
    }
    const p = function (v) {
        return (
          (v = v.replace(new RegExp(i(n), 'g'), ' ')),
          `{${f(v.slice(1, v.length - 1))}}`
        );
      },
      _ = function (v) {
        if (v.startsWith('{') && v.endsWith('}'))
          return u(v.slice(1, v.length - 1));
      };
    let g = e
      .replace(c, '')
      .replace(
        new RegExp(`({[^}]*})+?|;([^${i(n)}]*)`, 'g'),
        function (v, x, S) {
          return x !== void 0 ? p(x) : ' ' + p(`{${S.slice(1)}}`);
        }
      )
      .replace(new RegExp(i(n), 'g'), ' ');
    const d = /(\([^()]+\))+?/g;
    for (; d.test(g); ) g = g.replace(d, '');
    (g = g.replace(/\d+\.(\.\.)?/g, '')),
      (g = g.replace(/\.\.\./g, '')),
      (g = g.replace(/\$\d+/g, ''));
    let m = g.trim().split(new RegExp(/\s+/));
    m = m.filter((v) => v !== '');
    let y = '';
    for (let v = 0; v < m.length; v++) {
      const x = _(m[v]);
      if (x !== void 0) {
        this._comments[this.fen()] = x;
        continue;
      }
      const S = this._moveFromSan(m[v], t);
      if (S == null)
        if (a0.indexOf(m[v]) > -1) y = m[v];
        else throw new Error(`Invalid move in PGN: ${m[v]}`);
      else (y = ''), this._makeMove(S);
    }
    y &&
      Object.keys(this._header).length &&
      !this._header.Result &&
      this.header('Result', y);
  }
  _moveToSan(e, t) {
    let n = '';
    if (e.flags & Ee.KSIDE_CASTLE) n = 'O-O';
    else if (e.flags & Ee.QSIDE_CASTLE) n = 'O-O-O';
    else {
      if (e.piece !== St) {
        const i = l0(e, t);
        n += e.piece.toUpperCase() + i;
      }
      e.flags & (Ee.CAPTURE | Ee.EP_CAPTURE) &&
        (e.piece === St && (n += on(e.from)[0]), (n += 'x')),
        (n += on(e.to)),
        e.promotion && (n += '=' + e.promotion.toUpperCase());
    }
    return (
      this._makeMove(e),
      this.isCheck() && (this.isCheckmate() ? (n += '#') : (n += '+')),
      this._undoMove(),
      n
    );
  }
  _moveFromSan(e, t = !1) {
    const n = Ga(e);
    let i = Hh(n),
      s = this._moves({ legal: !0, piece: i });
    for (let u = 0, p = s.length; u < p; u++)
      if (n === Ga(this._moveToSan(s[u], s))) return s[u];
    if (t) return null;
    let o,
      a,
      c,
      l,
      h,
      f = !1;
    if (
      ((a = n.match(
        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/
      )),
      a
        ? ((o = a[1]),
          (c = a[2]),
          (l = a[3]),
          (h = a[4]),
          c.length == 1 && (f = !0))
        : ((a = n.match(
            /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/
          )),
          a &&
            ((o = a[1]),
            (c = a[2]),
            (l = a[3]),
            (h = a[4]),
            c.length == 1 && (f = !0))),
      (i = Hh(n)),
      (s = this._moves({ legal: !0, piece: o || i })),
      !l)
    )
      return null;
    for (let u = 0, p = s.length; u < p; u++)
      if (c) {
        if (
          (!o || o.toLowerCase() == s[u].piece) &&
          we[c] == s[u].from &&
          we[l] == s[u].to &&
          (!h || h.toLowerCase() == s[u].promotion)
        )
          return s[u];
        if (f) {
          const _ = on(s[u].from);
          if (
            (!o || o.toLowerCase() == s[u].piece) &&
            we[l] == s[u].to &&
            (c == _[0] || c == _[1]) &&
            (!h || h.toLowerCase() == s[u].promotion)
          )
            return s[u];
        }
      } else if (n === Ga(this._moveToSan(s[u], s)).replace('x', ''))
        return s[u];
    return null;
  }
  ascii() {
    let e = `   +------------------------+
`;
    for (let t = we.a8; t <= we.h1; t++) {
      if (
        (Js(t) === 0 && (e += ' ' + '87654321'[hr(t)] + ' |'), this._board[t])
      ) {
        const n = this._board[t].type,
          s = this._board[t].color === Ut ? n.toUpperCase() : n.toLowerCase();
        e += ' ' + s + ' ';
      } else e += ' . ';
      (t + 1) & 136 &&
        ((e += `|
`),
        (t += 8));
    }
    return (
      (e += `   +------------------------+
`),
      (e += '     a  b  c  d  e  f  g  h'),
      e
    );
  }
  perft(e) {
    const t = this._moves({ legal: !1 });
    let n = 0;
    const i = this._turn;
    for (let s = 0, o = t.length; s < o; s++)
      this._makeMove(t[s]),
        this._isKingAttacked(i) || (e - 1 > 0 ? (n += this.perft(e - 1)) : n++),
        this._undoMove();
    return n;
  }
  _makePretty(e) {
    const {
      color: t,
      piece: n,
      from: i,
      to: s,
      flags: o,
      captured: a,
      promotion: c
    } = e;
    let l = '';
    for (const p in Ee) Ee[p] & o && (l += Z_[p]);
    const h = on(i),
      f = on(s),
      u = {
        color: t,
        piece: n,
        from: h,
        to: f,
        san: this._moveToSan(e, this._moves({ legal: !0 })),
        flags: l,
        lan: h + f,
        before: this.fen(),
        after: ''
      };
    return (
      this._makeMove(e),
      (u.after = this.fen()),
      this._undoMove(),
      a && (u.captured = a),
      c && ((u.promotion = c), (u.lan += c)),
      u
    );
  }
  turn() {
    return this._turn;
  }
  board() {
    const e = [];
    let t = [];
    for (let n = we.a8; n <= we.h1; n++)
      this._board[n] == null
        ? t.push(null)
        : t.push({
            square: on(n),
            type: this._board[n].type,
            color: this._board[n].color
          }),
        (n + 1) & 136 && (e.push(t), (t = []), (n += 8));
    return e;
  }
  squareColor(e) {
    if (e in we) {
      const t = we[e];
      return (hr(t) + Js(t)) % 2 === 0 ? 'light' : 'dark';
    }
    return null;
  }
  history({ verbose: e = !1 } = {}) {
    const t = [],
      n = [];
    for (; this._history.length > 0; ) t.push(this._undoMove());
    for (;;) {
      const i = t.pop();
      if (!i) break;
      e
        ? n.push(this._makePretty(i))
        : n.push(this._moveToSan(i, this._moves())),
        this._makeMove(i);
    }
    return n;
  }
  _pruneComments() {
    const e = [],
      t = {},
      n = (i) => {
        i in this._comments && (t[i] = this._comments[i]);
      };
    for (; this._history.length > 0; ) e.push(this._undoMove());
    for (n(this.fen()); ; ) {
      const i = e.pop();
      if (!i) break;
      this._makeMove(i), n(this.fen());
    }
    this._comments = t;
  }
  getComment() {
    return this._comments[this.fen()];
  }
  setComment(e) {
    this._comments[this.fen()] = e.replace('{', '[').replace('}', ']');
  }
  deleteComment() {
    const e = this._comments[this.fen()];
    return delete this._comments[this.fen()], e;
  }
  getComments() {
    return (
      this._pruneComments(),
      Object.keys(this._comments).map((e) => ({
        fen: e,
        comment: this._comments[e]
      }))
    );
  }
  deleteComments() {
    return (
      this._pruneComments(),
      Object.keys(this._comments).map((e) => {
        const t = this._comments[e];
        return delete this._comments[e], { fen: e, comment: t };
      })
    );
  }
  setCastlingRights(e, t) {
    for (const i of [bt, bi])
      t[i] !== void 0 &&
        (t[i] ? (this._castling[e] |= _o[i]) : (this._castling[e] &= ~_o[i]));
    this._updateCastlingRights();
    const n = this.getCastlingRights(e);
    return (
      (t[bt] === void 0 || t[bt] === n[bt]) &&
      (t[bi] === void 0 || t[bi] === n[bi])
    );
  }
  getCastlingRights(e) {
    return {
      [bt]: (this._castling[e] & _o[bt]) !== 0,
      [bi]: (this._castling[e] & _o[bi]) !== 0
    };
  }
  moveNumber() {
    return this._moveNumber;
  }
}
const u0 = class extends Wn.Component {
  constructor(r) {
    super(r), (this.events = {});
  }
  init() {
    console.log('PlayBoard component init'),
      (this.chess = new h0()),
      (this.moves = []),
      (this.promotion = []),
      (this.allowedToMove = !1),
      (this.pomotionEvents = []),
      (this.DOM.board = this.DOM.el.querySelector('#js-game')),
      (this.DOM.promotionBtns = [
        ...this.DOM.el.querySelectorAll('.js-topromote')
      ]),
      (this.DOM.moves = []),
      (this.DOM.promoteModal = this.DOM.el.querySelector('#js-promote-modal')),
      (this.board = Chessboard(this.DOM.board, {
        pieceTheme: '/img/images/pieces/staunton/basic/{piece}.png',
        onMoveEnd: this._onSnapEnd.bind(this),
        moveSpeed: 1
      })),
      this.board.start();
  }
  _onSnapEnd() {
    this.board.position(this.chess.fen());
  }
  startGame(r) {
    (this.color = r),
      this.color === 'b' && this.board.flip(),
      (this.rivalColor = this.color === 'w' ? 'b' : 'w'),
      (this.DOM.cells = [...this.DOM.el.querySelectorAll('.square-55d63')]),
      this.DOM.cells.forEach((e, t) => {
        this.events[`cell-${t}`] = this.on({
          e: 'click',
          target: e,
          cb: this.selectCell.bind(this)
        });
      });
  }
  showScoreBoard(r) {
    Z.set(this.DOM.el, { willChange: 'transform' }),
      Z.to(this.DOM.el, {
        rotate: r === 'w' ? '-20deg' : '20deg',
        x: '60%',
        y: r === 'w' ? '0%' : '25%',
        scale: 0.8
      });
  }
  getMoveNumber() {
    return this.chess.moveNumber();
  }
  async engine(r = !1, e) {
    if (this.chess.isGameOver() || e) {
      console.log('GAME OVER!');
      let t = 'checkmate';
      e === 'timeout' &&
        ((t = 'timeout'),
        (await Rt.isGameover('timeout')) &&
          this.call(
            'finishGame',
            ['winner', t],
            'gameplayers',
            this.color === this.chess.turn() ? 'rival' : 'me'
          )),
        this.chess.isCheckmate() &&
          ((t = 'checkmate'),
          (await Rt.isGameover('timeout')) &&
            this.call(
              'finishGame',
              ['winner', t],
              'gameplayers',
              this.color === this.chess.turn() ? 'me' : 'rival'
            )),
        (this.chess.isDraw() || e === 'draw') &&
          ((t = this.chess.isStalemate()
            ? 'stalemate'
            : this.chess.isThreefoldRepetition()
            ? 'threefoldRepetition'
            : this.chess.isInsufficientMaterial()
            ? 'insufficientMaterial'
            : 'draw'),
          (await Rt.isGameover('timeout')) &&
            this.call('finishGame', ['draw', t], 'gameplayers', 'me')),
        this.call('stopTimer', [!0], 'gameplayers', 'me'),
        this.call('stopTimer', [!0], 'gameplayers', 'rival'),
        this.call('disappear', '', 'gamecontrols');
      return;
    }
    this.color === this.chess.turn()
      ? (this.call('stopTimer', [r], 'gameplayers', 'rival'),
        this.call('startTimer', [r], 'gameplayers', 'me'),
        (this.allowedToMove = !0))
      : (this.call('stopTimer', [r], 'gameplayers', 'me'),
        this.call('startTimer', [r], 'gameplayers', 'rival'),
        (this.allowedToMove = !1),
        this.rivalMove());
  }
  async rivalMove() {
    const r = await Rt.getRivalMove(this.chess, !0),
      e = this.chess.move(r);
    this.board.position(this.chess.fen()),
      e.captured &&
        this.call(
          'capturePawn',
          [e.captured],
          'gameplayers',
          e.color === this.color ? 'me' : 'rival'
        ),
      this.engine();
  }
  async promote() {
    return (
      Z.to(this.DOM.promoteModal, { autoAlpha: 1 }),
      new Promise((r) => {
        this.DOM.promotionBtns.forEach((e) => {
          const n = {
              e: 'click',
              target: e,
              cb: ((s) => {
                this.pomotionEvents.forEach((o) => {
                  this.off(o, n);
                }),
                  Z.to(this.DOM.promoteModal, { autoAlpha: 0 }),
                  r(s.currentTarget.dataset.topromote);
              }).bind(this)
            },
            i = this.on(n);
          this.pomotionEvents.push(i);
        });
      })
    );
  }
  async selectCell(r) {
    if (!this.allowedToMove) return;
    const e = r.currentTarget.dataset.square;
    if (this.moves.includes(e)) {
      this.moves = [];
      let t = 0;
      this.promotion.length > 0 &&
        ((this.DOM.board.style.pointerEvents = 'none'),
        (t = await this.promote()),
        (this.DOM.board.style.pointerEvents = 'auto'));
      const n = this.chess.move({ from: this.selected, to: e, promotion: t });
      this.board.move(`${n.from}-${n.to}`),
        n.captured &&
          this.call(
            'capturePawn',
            [n.captured],
            'gameplayers',
            n.color === this.color ? 'me' : 'rival'
          ),
        await Rt.makeMove(n.from, n.to, t),
        this.engine(),
        Z.to('.chess-board [data-square]', { '--disp-opacity': 0 }),
        (this.DOM.moves = []);
    } else {
      this.DOM.moves.length > 0 &&
        (Z.to('.chess-board [data-square]', { '--disp-opacity': 0 }),
        (this.DOM.moves = [])),
        (this.selected = e);
      const t = this.chess.moves({ square: e, verbose: !0 });
      (this.moves = [...new Set(t.map((n) => n.to))]),
        (this.promotion = [
          ...new Set(t.filter((n) => n.promotion).map((n) => n.to))
        ]),
        this.moves.forEach((n) => {
          this.DOM.moves.push(
            this.DOM.el.querySelector(`[data-square="${n}"]`)
          );
        }),
        this.DOM.moves.length > 0 &&
          Z.to(this.DOM.moves, { '--disp-opacity': 1 });
    }
  }
  appear() {
    Z.to(this.DOM.el, { autoAlpha: 1, display: 'flex' }),
      Z.from('.piece-417db', { y: '-65%', ease: 'bounce.out', stagger: 0.03 }),
      Z.from('.piece-417db', { autoAlpha: 0, stagger: 0.03 }).then(() => {
        this.engine(!0);
      });
  }
  disappear() {
    Z.to(this.DOM.el, { autoAlpha: 0 });
  }
  destroy() {
    this.chess.clear(), this.board.destroy();
  }
};
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Hl = '156',
  f0 = 0,
  Gh = 1,
  d0 = 2,
  sp = 1,
  p0 = 2,
  ni = 3,
  ui = 0,
  Jt = 1,
  Nn = 2,
  Di = 0,
  Jr = 1,
  Vh = 2,
  Wh = 3,
  qh = 4,
  m0 = 5,
  Vr = 100,
  g0 = 101,
  _0 = 102,
  Xh = 103,
  jh = 104,
  v0 = 200,
  y0 = 201,
  x0 = 202,
  M0 = 203,
  op = 204,
  ap = 205,
  S0 = 206,
  b0 = 207,
  E0 = 208,
  T0 = 209,
  A0 = 210,
  w0 = 0,
  R0 = 1,
  C0 = 2,
  Jc = 3,
  L0 = 4,
  P0 = 5,
  D0 = 6,
  I0 = 7,
  cp = 0,
  O0 = 1,
  U0 = 2,
  Ii = 0,
  N0 = 1,
  F0 = 2,
  k0 = 3,
  B0 = 4,
  z0 = 5,
  lp = 300,
  os = 301,
  as = 302,
  Qc = 303,
  el = 304,
  va = 306,
  cs = 1e3,
  vn = 1001,
  la = 1002,
  Et = 1003,
  tl = 1004,
  Zo = 1005,
  jt = 1006,
  hp = 1007,
  gr = 1008,
  Oi = 1009,
  H0 = 1010,
  G0 = 1011,
  Gl = 1012,
  up = 1013,
  Ci = 1014,
  oi = 1015,
  Qs = 1016,
  fp = 1017,
  dp = 1018,
  ur = 1020,
  V0 = 1021,
  yn = 1023,
  W0 = 1024,
  q0 = 1025,
  fr = 1026,
  ls = 1027,
  X0 = 1028,
  pp = 1029,
  j0 = 1030,
  mp = 1031,
  gp = 1033,
  Va = 33776,
  Wa = 33777,
  qa = 33778,
  Xa = 33779,
  Yh = 35840,
  Kh = 35841,
  $h = 35842,
  Zh = 35843,
  Y0 = 36196,
  Jh = 37492,
  Qh = 37496,
  eu = 37808,
  tu = 37809,
  nu = 37810,
  iu = 37811,
  ru = 37812,
  su = 37813,
  ou = 37814,
  au = 37815,
  cu = 37816,
  lu = 37817,
  hu = 37818,
  uu = 37819,
  fu = 37820,
  du = 37821,
  ja = 36492,
  pu = 36494,
  mu = 36495,
  K0 = 36283,
  gu = 36284,
  _u = 36285,
  vu = 36286,
  eo = 2300,
  hs = 2301,
  Ya = 2302,
  yu = 2400,
  xu = 2401,
  Mu = 2402,
  $0 = 2500,
  Z0 = 0,
  _p = 1,
  nl = 2,
  vp = 3e3,
  dr = 3001,
  J0 = 3200,
  Q0 = 3201,
  yp = 0,
  ev = 1,
  pr = '',
  qe = 'srgb',
  _t = 'srgb-linear',
  ya = 'display-p3',
  Ka = 7680,
  tv = 519,
  nv = 512,
  iv = 513,
  rv = 514,
  sv = 515,
  ov = 516,
  av = 517,
  cv = 518,
  lv = 519,
  il = 35044,
  Su = '300 es',
  rl = 1035,
  ai = 2e3,
  ha = 2001;
class _s {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const It = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff'
];
let bu = 1234567;
const Hs = Math.PI / 180,
  us = 180 / Math.PI;
function Pn() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    It[r & 255] +
    It[(r >> 8) & 255] +
    It[(r >> 16) & 255] +
    It[(r >> 24) & 255] +
    '-' +
    It[e & 255] +
    It[(e >> 8) & 255] +
    '-' +
    It[((e >> 16) & 15) | 64] +
    It[(e >> 24) & 255] +
    '-' +
    It[(t & 63) | 128] +
    It[(t >> 8) & 255] +
    '-' +
    It[(t >> 16) & 255] +
    It[(t >> 24) & 255] +
    It[n & 255] +
    It[(n >> 8) & 255] +
    It[(n >> 16) & 255] +
    It[(n >> 24) & 255]
  ).toLowerCase();
}
function Nt(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function Vl(r, e) {
  return ((r % e) + e) % e;
}
function hv(r, e, t, n, i) {
  return n + ((r - e) * (i - n)) / (t - e);
}
function uv(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function Gs(r, e, t) {
  return (1 - t) * r + t * e;
}
function fv(r, e, t, n) {
  return Gs(r, e, 1 - Math.exp(-t * n));
}
function dv(r, e = 1) {
  return e - Math.abs(Vl(r, e * 2) - e);
}
function pv(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function mv(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function gv(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function _v(r, e) {
  return r + Math.random() * (e - r);
}
function vv(r) {
  return r * (0.5 - Math.random());
}
function yv(r) {
  r !== void 0 && (bu = r);
  let e = (bu += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function xv(r) {
  return r * Hs;
}
function Mv(r) {
  return r * us;
}
function sl(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function xp(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function ua(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function Sv(r, e, t, n, i) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    c = o(t / 2),
    l = s((e + n) / 2),
    h = o((e + n) / 2),
    f = s((e - n) / 2),
    u = o((e - n) / 2),
    p = s((n - e) / 2),
    _ = o((n - e) / 2);
  switch (i) {
    case 'XYX':
      r.set(a * h, c * f, c * u, a * l);
      break;
    case 'YZY':
      r.set(c * u, a * h, c * f, a * l);
      break;
    case 'ZXZ':
      r.set(c * f, c * u, a * h, a * l);
      break;
    case 'XZX':
      r.set(a * h, c * _, c * p, a * l);
      break;
    case 'YXY':
      r.set(c * p, a * h, c * _, a * l);
      break;
    case 'ZYZ':
      r.set(c * _, c * p, a * h, a * l);
      break;
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          i
      );
  }
}
function Fn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error('Invalid component type.');
  }
}
function Ye(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error('Invalid component type.');
  }
}
const bv = {
  DEG2RAD: Hs,
  RAD2DEG: us,
  generateUUID: Pn,
  clamp: Nt,
  euclideanModulo: Vl,
  mapLinear: hv,
  inverseLerp: uv,
  lerp: Gs,
  damp: fv,
  pingpong: dv,
  smoothstep: pv,
  smootherstep: mv,
  randInt: gv,
  randFloat: _v,
  randFloatSpread: vv,
  seededRandom: yv,
  degToRad: xv,
  radToDeg: Mv,
  isPowerOfTwo: sl,
  ceilPowerOfTwo: xp,
  floorPowerOfTwo: ua,
  setQuaternionFromProperEuler: Sv,
  normalize: Ye,
  denormalize: Fn
};
class Ve {
  constructor(e = 0, t = 0) {
    (Ve.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Nt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * n - o * i + e.x), (this.y = s * i + o * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Oe {
  constructor(e, t, n, i, s, o, a, c, l) {
    (Oe.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, o, a, c, l);
  }
  set(e, t, n, i, s, o, a, c, l) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = c),
      (h[6] = n),
      (h[7] = o),
      (h[8] = l),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      o = n[0],
      a = n[3],
      c = n[6],
      l = n[1],
      h = n[4],
      f = n[7],
      u = n[2],
      p = n[5],
      _ = n[8],
      g = i[0],
      d = i[3],
      m = i[6],
      y = i[1],
      v = i[4],
      x = i[7],
      S = i[2],
      b = i[5],
      T = i[8];
    return (
      (s[0] = o * g + a * y + c * S),
      (s[3] = o * d + a * v + c * b),
      (s[6] = o * m + a * x + c * T),
      (s[1] = l * g + h * y + f * S),
      (s[4] = l * d + h * v + f * b),
      (s[7] = l * m + h * x + f * T),
      (s[2] = u * g + p * y + _ * S),
      (s[5] = u * d + p * v + _ * b),
      (s[8] = u * m + p * x + _ * T),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      l = e[7],
      h = e[8];
    return (
      t * o * h - t * a * l - n * s * h + n * a * c + i * s * l - i * o * c
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      l = e[7],
      h = e[8],
      f = h * o - a * l,
      u = a * c - h * s,
      p = l * s - o * c,
      _ = t * f + n * u + i * p;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / _;
    return (
      (e[0] = f * g),
      (e[1] = (i * l - h * n) * g),
      (e[2] = (a * n - i * o) * g),
      (e[3] = u * g),
      (e[4] = (h * t - i * c) * g),
      (e[5] = (i * s - a * t) * g),
      (e[6] = p * g),
      (e[7] = (n * c - l * t) * g),
      (e[8] = (o * t - n * s) * g),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, s, o, a) {
    const c = Math.cos(s),
      l = Math.sin(s);
    return (
      this.set(
        n * c,
        n * l,
        -n * (c * o + l * a) + o + e,
        -i * l,
        i * c,
        -i * (-l * o + c * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply($a.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply($a.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply($a.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const $a = new Oe();
function Mp(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
function to(r) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', r);
}
function Ev() {
  const r = to('canvas');
  return (r.style.display = 'block'), r;
}
const Eu = {};
function Vs(r) {
  r in Eu || ((Eu[r] = !0), console.warn(r));
}
function Qr(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Za(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const Tv = new Oe().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199
  ]),
  Av = new Oe().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735
  ]);
function wv(r) {
  return r.convertSRGBToLinear().applyMatrix3(Av);
}
function Rv(r) {
  return r.applyMatrix3(Tv).convertLinearToSRGB();
}
const Cv = { [_t]: (r) => r, [qe]: (r) => r.convertSRGBToLinear(), [ya]: wv },
  Lv = { [_t]: (r) => r, [qe]: (r) => r.convertLinearToSRGB(), [ya]: Rv },
  Xt = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
        ),
        !this.enabled
      );
    },
    set legacyMode(r) {
      console.warn(
        'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.'
      ),
        (this.enabled = !r);
    },
    get workingColorSpace() {
      return _t;
    },
    set workingColorSpace(r) {
      console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
    },
    convert: function (r, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return r;
      const n = Cv[e],
        i = Lv[t];
      if (n === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(n(r));
    },
    fromWorkingColorSpace: function (r, e) {
      return this.convert(r, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (r, e) {
      return this.convert(r, e, this.workingColorSpace);
    }
  };
let br;
class Sp {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      br === void 0 && (br = to('canvas')),
        (br.width = e.width),
        (br.height = e.height);
      const n = br.getContext('2d');
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = br);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
          e
        ),
        t.toDataURL('image/jpeg', 0.6))
      : t.toDataURL('image/png');
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
    ) {
      const t = to('canvas');
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext('2d');
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let o = 0; o < s.length; o++) s[o] = Qr(s[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Qr(t[n] / 255) * 255))
          : (t[n] = Qr(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
        ),
        e
      );
  }
}
let Pv = 0;
class bp {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, 'id', { value: Pv++ }),
      (this.uuid = Pn()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: '' },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? s.push(Ja(i[o].image)) : s.push(Ja(i[o]));
      } else s = Ja(i);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Ja(r) {
  return (typeof HTMLImageElement < 'u' && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && r instanceof ImageBitmap)
    ? Sp.getDataURL(r)
    : r.data
    ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
      }
    : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let Dv = 0;
class Ct extends _s {
  constructor(
    e = Ct.DEFAULT_IMAGE,
    t = Ct.DEFAULT_MAPPING,
    n = vn,
    i = vn,
    s = jt,
    o = gr,
    a = yn,
    c = Oi,
    l = Ct.DEFAULT_ANISOTROPY,
    h = pr
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: Dv++ }),
      (this.uuid = Pn()),
      (this.name = ''),
      (this.source = new bp(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = l),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = c),
      (this.offset = new Ve(0, 0)),
      (this.repeat = new Ve(1, 1)),
      (this.center = new Ve(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Oe()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof h == 'string'
        ? (this.colorSpace = h)
        : (Vs(
            'THREE.Texture: Property .encoding has been replaced by .colorSpace.'
          ),
          (this.colorSpace = h === dr ? qe : pr)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  transformUv(e) {
    if (this.mapping !== lp) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case cs:
          e.x = e.x - Math.floor(e.x);
          break;
        case vn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case la:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case cs:
          e.y = e.y - Math.floor(e.y);
          break;
        case vn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case la:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Vs('THREE.Texture: Property .encoding has been replaced by .colorSpace.'),
      this.colorSpace === qe ? dr : vp
    );
  }
  set encoding(e) {
    Vs('THREE.Texture: Property .encoding has been replaced by .colorSpace.'),
      (this.colorSpace = e === dr ? qe : pr);
  }
}
Ct.DEFAULT_IMAGE = null;
Ct.DEFAULT_MAPPING = lp;
Ct.DEFAULT_ANISOTROPY = 1;
class Je {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (Je.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s),
      (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s),
      (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s),
      (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, s;
    const c = e.elements,
      l = c[0],
      h = c[4],
      f = c[8],
      u = c[1],
      p = c[5],
      _ = c[9],
      g = c[2],
      d = c[6],
      m = c[10];
    if (
      Math.abs(h - u) < 0.01 &&
      Math.abs(f - g) < 0.01 &&
      Math.abs(_ - d) < 0.01
    ) {
      if (
        Math.abs(h + u) < 0.1 &&
        Math.abs(f + g) < 0.1 &&
        Math.abs(_ + d) < 0.1 &&
        Math.abs(l + p + m - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const v = (l + 1) / 2,
        x = (p + 1) / 2,
        S = (m + 1) / 2,
        b = (h + u) / 4,
        T = (f + g) / 4,
        C = (_ + d) / 4;
      return (
        v > x && v > S
          ? v < 0.01
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(v)), (i = b / n), (s = T / n))
          : x > S
          ? x < 0.01
            ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(x)), (n = b / i), (s = C / i))
          : S < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(S)), (n = T / s), (i = C / s)),
        this.set(n, i, s, t),
        this
      );
    }
    let y = Math.sqrt(
      (d - _) * (d - _) + (f - g) * (f - g) + (u - h) * (u - h)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (d - _) / y),
      (this.y = (f - g) / y),
      (this.z = (u - h) / y),
      (this.w = Math.acos((l + p + m - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Iv extends _s {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Je(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Je(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 &&
      (Vs(
        'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.'
      ),
      (n.colorSpace = n.encoding === dr ? qe : pr)),
      (this.texture = new Ct(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : jt),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new bp(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
class _r extends Iv {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class Ep extends Ct {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Et),
      (this.minFilter = Et),
      (this.wrapR = vn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Ov extends Ct {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Et),
      (this.minFilter = Et),
      (this.wrapR = vn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class ki {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, s, o, a) {
    let c = n[i + 0],
      l = n[i + 1],
      h = n[i + 2],
      f = n[i + 3];
    const u = s[o + 0],
      p = s[o + 1],
      _ = s[o + 2],
      g = s[o + 3];
    if (a === 0) {
      (e[t + 0] = c), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = f);
      return;
    }
    if (a === 1) {
      (e[t + 0] = u), (e[t + 1] = p), (e[t + 2] = _), (e[t + 3] = g);
      return;
    }
    if (f !== g || c !== u || l !== p || h !== _) {
      let d = 1 - a;
      const m = c * u + l * p + h * _ + f * g,
        y = m >= 0 ? 1 : -1,
        v = 1 - m * m;
      if (v > Number.EPSILON) {
        const S = Math.sqrt(v),
          b = Math.atan2(S, m * y);
        (d = Math.sin(d * b) / S), (a = Math.sin(a * b) / S);
      }
      const x = a * y;
      if (
        ((c = c * d + u * x),
        (l = l * d + p * x),
        (h = h * d + _ * x),
        (f = f * d + g * x),
        d === 1 - a)
      ) {
        const S = 1 / Math.sqrt(c * c + l * l + h * h + f * f);
        (c *= S), (l *= S), (h *= S), (f *= S);
      }
    }
    (e[t] = c), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = f);
  }
  static multiplyQuaternionsFlat(e, t, n, i, s, o) {
    const a = n[i],
      c = n[i + 1],
      l = n[i + 2],
      h = n[i + 3],
      f = s[o],
      u = s[o + 1],
      p = s[o + 2],
      _ = s[o + 3];
    return (
      (e[t] = a * _ + h * f + c * p - l * u),
      (e[t + 1] = c * _ + h * u + l * f - a * p),
      (e[t + 2] = l * _ + h * p + a * u - c * f),
      (e[t + 3] = h * _ - a * f - c * u - l * p),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      c = Math.sin,
      l = a(n / 2),
      h = a(i / 2),
      f = a(s / 2),
      u = c(n / 2),
      p = c(i / 2),
      _ = c(s / 2);
    switch (o) {
      case 'XYZ':
        (this._x = u * h * f + l * p * _),
          (this._y = l * p * f - u * h * _),
          (this._z = l * h * _ + u * p * f),
          (this._w = l * h * f - u * p * _);
        break;
      case 'YXZ':
        (this._x = u * h * f + l * p * _),
          (this._y = l * p * f - u * h * _),
          (this._z = l * h * _ - u * p * f),
          (this._w = l * h * f + u * p * _);
        break;
      case 'ZXY':
        (this._x = u * h * f - l * p * _),
          (this._y = l * p * f + u * h * _),
          (this._z = l * h * _ + u * p * f),
          (this._w = l * h * f - u * p * _);
        break;
      case 'ZYX':
        (this._x = u * h * f - l * p * _),
          (this._y = l * p * f + u * h * _),
          (this._z = l * h * _ - u * p * f),
          (this._w = l * h * f + u * p * _);
        break;
      case 'YZX':
        (this._x = u * h * f + l * p * _),
          (this._y = l * p * f + u * h * _),
          (this._z = l * h * _ - u * p * f),
          (this._w = l * h * f - u * p * _);
        break;
      case 'XZY':
        (this._x = u * h * f - l * p * _),
          (this._y = l * p * f - u * h * _),
          (this._z = l * h * _ + u * p * f),
          (this._w = l * h * f + u * p * _);
        break;
      default:
        console.warn(
          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      c = t[9],
      l = t[2],
      h = t[6],
      f = t[10],
      u = n + a + f;
    if (u > 0) {
      const p = 0.5 / Math.sqrt(u + 1);
      (this._w = 0.25 / p),
        (this._x = (h - c) * p),
        (this._y = (s - l) * p),
        (this._z = (o - i) * p);
    } else if (n > a && n > f) {
      const p = 2 * Math.sqrt(1 + n - a - f);
      (this._w = (h - c) / p),
        (this._x = 0.25 * p),
        (this._y = (i + o) / p),
        (this._z = (s + l) / p);
    } else if (a > f) {
      const p = 2 * Math.sqrt(1 + a - n - f);
      (this._w = (s - l) / p),
        (this._x = (i + o) / p),
        (this._y = 0.25 * p),
        (this._z = (c + h) / p);
    } else {
      const p = 2 * Math.sqrt(1 + f - n - a);
      (this._w = (o - i) / p),
        (this._x = (s + l) / p),
        (this._y = (c + h) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Nt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      c = t._y,
      l = t._z,
      h = t._w;
    return (
      (this._x = n * h + o * a + i * l - s * c),
      (this._y = i * h + o * c + s * a - n * l),
      (this._z = s * h + o * l + n * c - i * a),
      (this._w = o * h - n * a - i * c - s * l),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + n * e._x + i * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = s), this;
    const c = 1 - a * a;
    if (c <= Number.EPSILON) {
      const p = 1 - t;
      return (
        (this._w = p * o + t * this._w),
        (this._x = p * n + t * this._x),
        (this._y = p * i + t * this._y),
        (this._z = p * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const l = Math.sqrt(c),
      h = Math.atan2(l, a),
      f = Math.sin((1 - t) * h) / l,
      u = Math.sin(t * h) / l;
    return (
      (this._w = o * f + this._w * u),
      (this._x = n * f + this._x * u),
      (this._y = i * f + this._y * u),
      (this._z = s * f + this._z * u),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(s),
      n * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class P {
  constructor(e = 0, t = 0, n = 0) {
    (P.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Tu.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Tu.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * i),
      (this.y = s[1] * t + s[4] * n + s[7] * i),
      (this.z = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o),
      (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o),
      (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      c = e.w,
      l = c * t + o * i - a * n,
      h = c * n + a * t - s * i,
      f = c * i + s * n - o * t,
      u = -s * t - o * n - a * i;
    return (
      (this.x = l * c + u * -s + h * -a - f * -o),
      (this.y = h * c + u * -o + f * -s - l * -a),
      (this.z = f * c + u * -a + l * -o - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * i),
      (this.y = s[1] * t + s[5] * n + s[9] * i),
      (this.z = s[2] * t + s[6] * n + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      c = t.z;
    return (
      (this.x = i * c - s * a),
      (this.y = s * o - n * c),
      (this.z = n * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Qa.copy(this).projectOnVector(e), this.sub(Qa);
  }
  reflect(e) {
    return this.sub(Qa.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Nt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Qa = new P(),
  Tu = new ki();
class fi {
  constructor(
    e = new P(1 / 0, 1 / 0, 1 / 0),
    t = new P(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Kn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Kn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Kn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        Er.copy(e.boundingBox),
        Er.applyMatrix4(e.matrixWorld),
        this.union(Er);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const s = i.attributes.position;
          for (let o = 0, a = s.count; o < a; o++)
            Kn.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Kn);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            Er.copy(i.boundingBox),
            Er.applyMatrix4(e.matrixWorld),
            this.union(Er);
    }
    const n = e.children;
    for (let i = 0, s = n.length; i < s; i++) this.expandByObject(n[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Kn),
      Kn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ts),
      vo.subVectors(this.max, Ts),
      Tr.subVectors(e.a, Ts),
      Ar.subVectors(e.b, Ts),
      wr.subVectors(e.c, Ts),
      gi.subVectors(Ar, Tr),
      _i.subVectors(wr, Ar),
      Wi.subVectors(Tr, wr);
    let t = [
      0,
      -gi.z,
      gi.y,
      0,
      -_i.z,
      _i.y,
      0,
      -Wi.z,
      Wi.y,
      gi.z,
      0,
      -gi.x,
      _i.z,
      0,
      -_i.x,
      Wi.z,
      0,
      -Wi.x,
      -gi.y,
      gi.x,
      0,
      -_i.y,
      _i.x,
      0,
      -Wi.y,
      Wi.x,
      0
    ];
    return !ec(t, Tr, Ar, wr, vo) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ec(t, Tr, Ar, wr, vo))
      ? !1
      : (yo.crossVectors(gi, _i),
        (t = [yo.x, yo.y, yo.z]),
        ec(t, Tr, Ar, wr, vo));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Kn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Kn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Yn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Yn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Yn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Yn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Yn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Yn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Yn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Yn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Yn),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Yn = [
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P()
  ],
  Kn = new P(),
  Er = new fi(),
  Tr = new P(),
  Ar = new P(),
  wr = new P(),
  gi = new P(),
  _i = new P(),
  Wi = new P(),
  Ts = new P(),
  vo = new P(),
  yo = new P(),
  qi = new P();
function ec(r, e, t, n, i) {
  for (let s = 0, o = r.length - 3; s <= o; s += 3) {
    qi.fromArray(r, s);
    const a =
        i.x * Math.abs(qi.x) + i.y * Math.abs(qi.y) + i.z * Math.abs(qi.z),
      c = e.dot(qi),
      l = t.dot(qi),
      h = n.dot(qi);
    if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > a) return !1;
  }
  return !0;
}
const Uv = new fi(),
  As = new P(),
  tc = new P();
class qn {
  constructor(e = new P(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Uv.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    As.subVectors(e, this.center);
    const t = As.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(As, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (tc.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(As.copy(e.center).add(tc)),
            this.expandByPoint(As.copy(e.center).sub(tc))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $n = new P(),
  nc = new P(),
  xo = new P(),
  vi = new P(),
  ic = new P(),
  Mo = new P(),
  rc = new P();
class xa {
  constructor(e = new P(), t = new P(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $n)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = $n.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : ($n.copy(this.origin).addScaledVector(this.direction, t),
        $n.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    nc.copy(e).add(t).multiplyScalar(0.5),
      xo.copy(t).sub(e).normalize(),
      vi.copy(this.origin).sub(nc);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(xo),
      a = vi.dot(this.direction),
      c = -vi.dot(xo),
      l = vi.lengthSq(),
      h = Math.abs(1 - o * o);
    let f, u, p, _;
    if (h > 0)
      if (((f = o * c - a), (u = o * a - c), (_ = s * h), f >= 0))
        if (u >= -_)
          if (u <= _) {
            const g = 1 / h;
            (f *= g),
              (u *= g),
              (p = f * (f + o * u + 2 * a) + u * (o * f + u + 2 * c) + l);
          } else
            (u = s),
              (f = Math.max(0, -(o * u + a))),
              (p = -f * f + u * (u + 2 * c) + l);
        else
          (u = -s),
            (f = Math.max(0, -(o * u + a))),
            (p = -f * f + u * (u + 2 * c) + l);
      else
        u <= -_
          ? ((f = Math.max(0, -(-o * s + a))),
            (u = f > 0 ? -s : Math.min(Math.max(-s, -c), s)),
            (p = -f * f + u * (u + 2 * c) + l))
          : u <= _
          ? ((f = 0),
            (u = Math.min(Math.max(-s, -c), s)),
            (p = u * (u + 2 * c) + l))
          : ((f = Math.max(0, -(o * s + a))),
            (u = f > 0 ? s : Math.min(Math.max(-s, -c), s)),
            (p = -f * f + u * (u + 2 * c) + l));
    else
      (u = o > 0 ? -s : s),
        (f = Math.max(0, -(o * u + a))),
        (p = -f * f + u * (u + 2 * c) + l);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, f),
      i && i.copy(nc).addScaledVector(xo, u),
      p
    );
  }
  intersectSphere(e, t) {
    $n.subVectors(e.center, this.origin);
    const n = $n.dot(this.direction),
      i = $n.dot($n) - n * n,
      s = e.radius * e.radius;
    if (i > s) return null;
    const o = Math.sqrt(s - i),
      a = n - o,
      c = n + o;
    return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, s, o, a, c;
    const l = 1 / this.direction.x,
      h = 1 / this.direction.y,
      f = 1 / this.direction.z,
      u = this.origin;
    return (
      l >= 0
        ? ((n = (e.min.x - u.x) * l), (i = (e.max.x - u.x) * l))
        : ((n = (e.max.x - u.x) * l), (i = (e.min.x - u.x) * l)),
      h >= 0
        ? ((s = (e.min.y - u.y) * h), (o = (e.max.y - u.y) * h))
        : ((s = (e.max.y - u.y) * h), (o = (e.min.y - u.y) * h)),
      n > o ||
      s > i ||
      ((s > n || isNaN(n)) && (n = s),
      (o < i || isNaN(i)) && (i = o),
      f >= 0
        ? ((a = (e.min.z - u.z) * f), (c = (e.max.z - u.z) * f))
        : ((a = (e.max.z - u.z) * f), (c = (e.min.z - u.z) * f)),
      n > c || a > i) ||
      ((a > n || n !== n) && (n = a), (c < i || i !== i) && (i = c), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, $n) !== null;
  }
  intersectTriangle(e, t, n, i, s) {
    ic.subVectors(t, e), Mo.subVectors(n, e), rc.crossVectors(ic, Mo);
    let o = this.direction.dot(rc),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    vi.subVectors(this.origin, e);
    const c = a * this.direction.dot(Mo.crossVectors(vi, Mo));
    if (c < 0) return null;
    const l = a * this.direction.dot(ic.cross(vi));
    if (l < 0 || c + l > o) return null;
    const h = -a * vi.dot(rc);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ue {
  constructor(e, t, n, i, s, o, a, c, l, h, f, u, p, _, g, d) {
    (Ue.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, o, a, c, l, h, f, u, p, _, g, d);
  }
  set(e, t, n, i, s, o, a, c, l, h, f, u, p, _, g, d) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[4] = t),
      (m[8] = n),
      (m[12] = i),
      (m[1] = s),
      (m[5] = o),
      (m[9] = a),
      (m[13] = c),
      (m[2] = l),
      (m[6] = h),
      (m[10] = f),
      (m[14] = u),
      (m[3] = p),
      (m[7] = _),
      (m[11] = g),
      (m[15] = d),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Ue().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / Rr.setFromMatrixColumn(e, 0).length(),
      s = 1 / Rr.setFromMatrixColumn(e, 1).length(),
      o = 1 / Rr.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * o),
      (t[9] = n[9] * o),
      (t[10] = n[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z,
      o = Math.cos(n),
      a = Math.sin(n),
      c = Math.cos(i),
      l = Math.sin(i),
      h = Math.cos(s),
      f = Math.sin(s);
    if (e.order === 'XYZ') {
      const u = o * h,
        p = o * f,
        _ = a * h,
        g = a * f;
      (t[0] = c * h),
        (t[4] = -c * f),
        (t[8] = l),
        (t[1] = p + _ * l),
        (t[5] = u - g * l),
        (t[9] = -a * c),
        (t[2] = g - u * l),
        (t[6] = _ + p * l),
        (t[10] = o * c);
    } else if (e.order === 'YXZ') {
      const u = c * h,
        p = c * f,
        _ = l * h,
        g = l * f;
      (t[0] = u + g * a),
        (t[4] = _ * a - p),
        (t[8] = o * l),
        (t[1] = o * f),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = p * a - _),
        (t[6] = g + u * a),
        (t[10] = o * c);
    } else if (e.order === 'ZXY') {
      const u = c * h,
        p = c * f,
        _ = l * h,
        g = l * f;
      (t[0] = u - g * a),
        (t[4] = -o * f),
        (t[8] = _ + p * a),
        (t[1] = p + _ * a),
        (t[5] = o * h),
        (t[9] = g - u * a),
        (t[2] = -o * l),
        (t[6] = a),
        (t[10] = o * c);
    } else if (e.order === 'ZYX') {
      const u = o * h,
        p = o * f,
        _ = a * h,
        g = a * f;
      (t[0] = c * h),
        (t[4] = _ * l - p),
        (t[8] = u * l + g),
        (t[1] = c * f),
        (t[5] = g * l + u),
        (t[9] = p * l - _),
        (t[2] = -l),
        (t[6] = a * c),
        (t[10] = o * c);
    } else if (e.order === 'YZX') {
      const u = o * c,
        p = o * l,
        _ = a * c,
        g = a * l;
      (t[0] = c * h),
        (t[4] = g - u * f),
        (t[8] = _ * f + p),
        (t[1] = f),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -l * h),
        (t[6] = p * f + _),
        (t[10] = u - g * f);
    } else if (e.order === 'XZY') {
      const u = o * c,
        p = o * l,
        _ = a * c,
        g = a * l;
      (t[0] = c * h),
        (t[4] = -f),
        (t[8] = l * h),
        (t[1] = u * f + g),
        (t[5] = o * h),
        (t[9] = p * f - _),
        (t[2] = _ * f - p),
        (t[6] = a * h),
        (t[10] = g * f + u);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Nv, e, Fv);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      rn.subVectors(e, t),
      rn.lengthSq() === 0 && (rn.z = 1),
      rn.normalize(),
      yi.crossVectors(n, rn),
      yi.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (rn.x += 1e-4) : (rn.z += 1e-4),
        rn.normalize(),
        yi.crossVectors(n, rn)),
      yi.normalize(),
      So.crossVectors(rn, yi),
      (i[0] = yi.x),
      (i[4] = So.x),
      (i[8] = rn.x),
      (i[1] = yi.y),
      (i[5] = So.y),
      (i[9] = rn.y),
      (i[2] = yi.z),
      (i[6] = So.z),
      (i[10] = rn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      o = n[0],
      a = n[4],
      c = n[8],
      l = n[12],
      h = n[1],
      f = n[5],
      u = n[9],
      p = n[13],
      _ = n[2],
      g = n[6],
      d = n[10],
      m = n[14],
      y = n[3],
      v = n[7],
      x = n[11],
      S = n[15],
      b = i[0],
      T = i[4],
      C = i[8],
      M = i[12],
      A = i[1],
      X = i[5],
      Y = i[9],
      D = i[13],
      F = i[2],
      N = i[6],
      K = i[10],
      z = i[14],
      j = i[3],
      J = i[7],
      $ = i[11],
      k = i[15];
    return (
      (s[0] = o * b + a * A + c * F + l * j),
      (s[4] = o * T + a * X + c * N + l * J),
      (s[8] = o * C + a * Y + c * K + l * $),
      (s[12] = o * M + a * D + c * z + l * k),
      (s[1] = h * b + f * A + u * F + p * j),
      (s[5] = h * T + f * X + u * N + p * J),
      (s[9] = h * C + f * Y + u * K + p * $),
      (s[13] = h * M + f * D + u * z + p * k),
      (s[2] = _ * b + g * A + d * F + m * j),
      (s[6] = _ * T + g * X + d * N + m * J),
      (s[10] = _ * C + g * Y + d * K + m * $),
      (s[14] = _ * M + g * D + d * z + m * k),
      (s[3] = y * b + v * A + x * F + S * j),
      (s[7] = y * T + v * X + x * N + S * J),
      (s[11] = y * C + v * Y + x * K + S * $),
      (s[15] = y * M + v * D + x * z + S * k),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      c = e[9],
      l = e[13],
      h = e[2],
      f = e[6],
      u = e[10],
      p = e[14],
      _ = e[3],
      g = e[7],
      d = e[11],
      m = e[15];
    return (
      _ *
        (+s * c * f -
          i * l * f -
          s * a * u +
          n * l * u +
          i * a * p -
          n * c * p) +
      g *
        (+t * c * p -
          t * l * u +
          s * o * u -
          i * o * p +
          i * l * h -
          s * c * h) +
      d *
        (+t * l * f -
          t * a * p -
          s * o * f +
          n * o * p +
          s * a * h -
          n * l * h) +
      m *
        (-i * a * h - t * c * f + t * a * u + i * o * f - n * o * u + n * c * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      l = e[7],
      h = e[8],
      f = e[9],
      u = e[10],
      p = e[11],
      _ = e[12],
      g = e[13],
      d = e[14],
      m = e[15],
      y = f * d * l - g * u * l + g * c * p - a * d * p - f * c * m + a * u * m,
      v = _ * u * l - h * d * l - _ * c * p + o * d * p + h * c * m - o * u * m,
      x = h * g * l - _ * f * l + _ * a * p - o * g * p - h * a * m + o * f * m,
      S = _ * f * c - h * g * c - _ * a * u + o * g * u + h * a * d - o * f * d,
      b = t * y + n * v + i * x + s * S;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / b;
    return (
      (e[0] = y * T),
      (e[1] =
        (g * u * s -
          f * d * s -
          g * i * p +
          n * d * p +
          f * i * m -
          n * u * m) *
        T),
      (e[2] =
        (a * d * s -
          g * c * s +
          g * i * l -
          n * d * l -
          a * i * m +
          n * c * m) *
        T),
      (e[3] =
        (f * c * s -
          a * u * s -
          f * i * l +
          n * u * l +
          a * i * p -
          n * c * p) *
        T),
      (e[4] = v * T),
      (e[5] =
        (h * d * s -
          _ * u * s +
          _ * i * p -
          t * d * p -
          h * i * m +
          t * u * m) *
        T),
      (e[6] =
        (_ * c * s -
          o * d * s -
          _ * i * l +
          t * d * l +
          o * i * m -
          t * c * m) *
        T),
      (e[7] =
        (o * u * s -
          h * c * s +
          h * i * l -
          t * u * l -
          o * i * p +
          t * c * p) *
        T),
      (e[8] = x * T),
      (e[9] =
        (_ * f * s -
          h * g * s -
          _ * n * p +
          t * g * p +
          h * n * m -
          t * f * m) *
        T),
      (e[10] =
        (o * g * s -
          _ * a * s +
          _ * n * l -
          t * g * l -
          o * n * m +
          t * a * m) *
        T),
      (e[11] =
        (h * a * s -
          o * f * s -
          h * n * l +
          t * f * l +
          o * n * p -
          t * a * p) *
        T),
      (e[12] = S * T),
      (e[13] =
        (h * g * i -
          _ * f * i +
          _ * n * u -
          t * g * u -
          h * n * d +
          t * f * d) *
        T),
      (e[14] =
        (_ * a * i -
          o * g * i -
          _ * n * c +
          t * g * c +
          o * n * d -
          t * a * d) *
        T),
      (e[15] =
        (o * f * i -
          h * a * i +
          h * n * c -
          t * f * c -
          o * n * u +
          t * a * u) *
        T),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = 1 - n,
      o = e.x,
      a = e.y,
      c = e.z,
      l = s * o,
      h = s * a;
    return (
      this.set(
        l * o + n,
        l * a - i * c,
        l * c + i * a,
        0,
        l * a + i * c,
        h * a + n,
        h * c - i * o,
        0,
        l * c - i * a,
        h * c + i * o,
        s * c * c + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, s, o) {
    return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      c = t._w,
      l = s + s,
      h = o + o,
      f = a + a,
      u = s * l,
      p = s * h,
      _ = s * f,
      g = o * h,
      d = o * f,
      m = a * f,
      y = c * l,
      v = c * h,
      x = c * f,
      S = n.x,
      b = n.y,
      T = n.z;
    return (
      (i[0] = (1 - (g + m)) * S),
      (i[1] = (p + x) * S),
      (i[2] = (_ - v) * S),
      (i[3] = 0),
      (i[4] = (p - x) * b),
      (i[5] = (1 - (u + m)) * b),
      (i[6] = (d + y) * b),
      (i[7] = 0),
      (i[8] = (_ + v) * T),
      (i[9] = (d - y) * T),
      (i[10] = (1 - (u + g)) * T),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let s = Rr.set(i[0], i[1], i[2]).length();
    const o = Rr.set(i[4], i[5], i[6]).length(),
      a = Rr.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Tn.copy(this);
    const l = 1 / s,
      h = 1 / o,
      f = 1 / a;
    return (
      (Tn.elements[0] *= l),
      (Tn.elements[1] *= l),
      (Tn.elements[2] *= l),
      (Tn.elements[4] *= h),
      (Tn.elements[5] *= h),
      (Tn.elements[6] *= h),
      (Tn.elements[8] *= f),
      (Tn.elements[9] *= f),
      (Tn.elements[10] *= f),
      t.setFromRotationMatrix(Tn),
      (n.x = s),
      (n.y = o),
      (n.z = a),
      this
    );
  }
  makePerspective(e, t, n, i, s, o, a = ai) {
    const c = this.elements,
      l = (2 * s) / (t - e),
      h = (2 * s) / (n - i),
      f = (t + e) / (t - e),
      u = (n + i) / (n - i);
    let p, _;
    if (a === ai) (p = -(o + s) / (o - s)), (_ = (-2 * o * s) / (o - s));
    else if (a === ha) (p = -o / (o - s)), (_ = (-o * s) / (o - s));
    else
      throw new Error(
        'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a
      );
    return (
      (c[0] = l),
      (c[4] = 0),
      (c[8] = f),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = h),
      (c[9] = u),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = p),
      (c[14] = _),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, s, o, a = ai) {
    const c = this.elements,
      l = 1 / (t - e),
      h = 1 / (n - i),
      f = 1 / (o - s),
      u = (t + e) * l,
      p = (n + i) * h;
    let _, g;
    if (a === ai) (_ = (o + s) * f), (g = -2 * f);
    else if (a === ha) (_ = s * f), (g = -1 * f);
    else
      throw new Error(
        'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a
      );
    return (
      (c[0] = 2 * l),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = -u),
      (c[1] = 0),
      (c[5] = 2 * h),
      (c[9] = 0),
      (c[13] = -p),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = g),
      (c[14] = -_),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const Rr = new P(),
  Tn = new Ue(),
  Nv = new P(0, 0, 0),
  Fv = new P(1, 1, 1),
  yi = new P(),
  So = new P(),
  rn = new P(),
  Au = new Ue(),
  wu = new ki();
class Ma {
  constructor(e = 0, t = 0, n = 0, i = Ma.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      s = i[0],
      o = i[4],
      a = i[8],
      c = i[1],
      l = i[5],
      h = i[9],
      f = i[2],
      u = i[6],
      p = i[10];
    switch (t) {
      case 'XYZ':
        (this._y = Math.asin(Nt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(u, l)), (this._z = 0));
        break;
      case 'YXZ':
        (this._x = Math.asin(-Nt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(c, l)))
            : ((this._y = Math.atan2(-f, s)), (this._z = 0));
        break;
      case 'ZXY':
        (this._x = Math.asin(Nt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(-f, p)), (this._z = Math.atan2(-o, l)))
            : ((this._y = 0), (this._z = Math.atan2(c, s)));
        break;
      case 'ZYX':
        (this._y = Math.asin(-Nt(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(u, p)), (this._z = Math.atan2(c, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, l)));
        break;
      case 'YZX':
        (this._z = Math.asin(Nt(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-f, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, p)));
        break;
      case 'XZY':
        (this._z = Math.asin(-Nt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, p)), (this._y = 0));
        break;
      default:
        console.warn(
          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      Au.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Au, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return wu.setFromEuler(this), this.setFromQuaternion(wu, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ma.DEFAULT_ORDER = 'XYZ';
class Tp {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let kv = 0;
const Ru = new P(),
  Cr = new ki(),
  Zn = new Ue(),
  bo = new P(),
  ws = new P(),
  Bv = new P(),
  zv = new ki(),
  Cu = new P(1, 0, 0),
  Lu = new P(0, 1, 0),
  Pu = new P(0, 0, 1),
  Hv = { type: 'added' },
  Gv = { type: 'removed' };
class st extends _s {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: kv++ }),
      (this.uuid = Pn()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = st.DEFAULT_UP.clone());
    const e = new P(),
      t = new Ma(),
      n = new ki(),
      i = new P(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s),
      n._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Ue() },
        normalMatrix: { value: new Oe() }
      }),
      (this.matrix = new Ue()),
      (this.matrixWorld = new Ue()),
      (this.matrixAutoUpdate = st.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = st.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Tp()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Cr.setFromAxisAngle(e, t), this.quaternion.multiply(Cr), this;
  }
  rotateOnWorldAxis(e, t) {
    return Cr.setFromAxisAngle(e, t), this.quaternion.premultiply(Cr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Cu, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Lu, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Pu, e);
  }
  translateOnAxis(e, t) {
    return (
      Ru.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Ru.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Cu, e);
  }
  translateY(e) {
    return this.translateOnAxis(Lu, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Pu, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Zn.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? bo.copy(e) : bo.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      ws.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Zn.lookAt(ws, bo, this.up)
        : Zn.lookAt(bo, ws, this.up),
      this.quaternion.setFromRotationMatrix(Zn),
      i &&
        (Zn.extractRotation(i.matrixWorld),
        Cr.setFromRotationMatrix(Zn),
        this.quaternion.premultiply(Cr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Hv))
          : console.error(
              'THREE.Object3D.add: object not an instance of THREE.Object3D.',
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Gv)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Zn.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Zn.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Zn),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty('id', e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty('name', e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let i = 0, s = this.children.length; i < s; i++) {
      const o = this.children[i].getObjectsByProperty(e, t);
      o.length > 0 && (n = n.concat(o));
    }
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ws, e, Bv), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ws, zv, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 &&
        n !== null &&
        n.matrixWorldAutoUpdate === !0 &&
        n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++) {
        const a = i[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string',
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }),
      (n.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = 'InstancedMesh'),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function s(a, c) {
      return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const c = a.shapes;
        if (Array.isArray(c))
          for (let l = 0, h = c.length; l < h; l++) {
            const f = c[l];
            s(e.shapes, f);
          }
        else s(e.shapes, c);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let c = 0, l = this.material.length; c < l; c++)
          a.push(s(e.materials, this.material[c]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const c = this.animations[a];
        i.animations.push(s(e.animations, c));
      }
    }
    if (t) {
      const a = o(e.geometries),
        c = o(e.materials),
        l = o(e.textures),
        h = o(e.images),
        f = o(e.shapes),
        u = o(e.skeletons),
        p = o(e.animations),
        _ = o(e.nodes);
      a.length > 0 && (n.geometries = a),
        c.length > 0 && (n.materials = c),
        l.length > 0 && (n.textures = l),
        h.length > 0 && (n.images = h),
        f.length > 0 && (n.shapes = f),
        u.length > 0 && (n.skeletons = u),
        p.length > 0 && (n.animations = p),
        _.length > 0 && (n.nodes = _);
    }
    return (n.object = i), n;
    function o(a) {
      const c = [];
      for (const l in a) {
        const h = a[l];
        delete h.metadata, c.push(h);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
st.DEFAULT_UP = new P(0, 1, 0);
st.DEFAULT_MATRIX_AUTO_UPDATE = !0;
st.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const An = new P(),
  Jn = new P(),
  sc = new P(),
  Qn = new P(),
  Lr = new P(),
  Pr = new P(),
  Du = new P(),
  oc = new P(),
  ac = new P(),
  cc = new P();
let Eo = !1;
class Cn {
  constructor(e = new P(), t = new P(), n = new P()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), An.subVectors(e, t), i.cross(An);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, s) {
    An.subVectors(i, t), Jn.subVectors(n, t), sc.subVectors(e, t);
    const o = An.dot(An),
      a = An.dot(Jn),
      c = An.dot(sc),
      l = Jn.dot(Jn),
      h = Jn.dot(sc),
      f = o * l - a * a;
    if (f === 0) return s.set(-2, -1, -1);
    const u = 1 / f,
      p = (l * c - a * h) * u,
      _ = (o * h - a * c) * u;
    return s.set(1 - p - _, _, p);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, Qn),
      Qn.x >= 0 && Qn.y >= 0 && Qn.x + Qn.y <= 1
    );
  }
  static getUV(e, t, n, i, s, o, a, c) {
    return (
      Eo === !1 &&
        (console.warn(
          'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
        ),
        (Eo = !0)),
      this.getInterpolation(e, t, n, i, s, o, a, c)
    );
  }
  static getInterpolation(e, t, n, i, s, o, a, c) {
    return (
      this.getBarycoord(e, t, n, i, Qn),
      c.setScalar(0),
      c.addScaledVector(s, Qn.x),
      c.addScaledVector(o, Qn.y),
      c.addScaledVector(a, Qn.z),
      c
    );
  }
  static isFrontFacing(e, t, n, i) {
    return An.subVectors(n, t), Jn.subVectors(e, t), An.cross(Jn).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      An.subVectors(this.c, this.b),
      Jn.subVectors(this.a, this.b),
      An.cross(Jn).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Cn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Cn.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, s) {
    return (
      Eo === !1 &&
        (console.warn(
          'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().'
        ),
        (Eo = !0)),
      Cn.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    );
  }
  getInterpolation(e, t, n, i, s) {
    return Cn.getInterpolation(e, this.a, this.b, this.c, t, n, i, s);
  }
  containsPoint(e) {
    return Cn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Cn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      s = this.c;
    let o, a;
    Lr.subVectors(i, n), Pr.subVectors(s, n), oc.subVectors(e, n);
    const c = Lr.dot(oc),
      l = Pr.dot(oc);
    if (c <= 0 && l <= 0) return t.copy(n);
    ac.subVectors(e, i);
    const h = Lr.dot(ac),
      f = Pr.dot(ac);
    if (h >= 0 && f <= h) return t.copy(i);
    const u = c * f - h * l;
    if (u <= 0 && c >= 0 && h <= 0)
      return (o = c / (c - h)), t.copy(n).addScaledVector(Lr, o);
    cc.subVectors(e, s);
    const p = Lr.dot(cc),
      _ = Pr.dot(cc);
    if (_ >= 0 && p <= _) return t.copy(s);
    const g = p * l - c * _;
    if (g <= 0 && l >= 0 && _ <= 0)
      return (a = l / (l - _)), t.copy(n).addScaledVector(Pr, a);
    const d = h * _ - p * f;
    if (d <= 0 && f - h >= 0 && p - _ >= 0)
      return (
        Du.subVectors(s, i),
        (a = (f - h) / (f - h + (p - _))),
        t.copy(i).addScaledVector(Du, a)
      );
    const m = 1 / (d + g + u);
    return (
      (o = g * m),
      (a = u * m),
      t.copy(n).addScaledVector(Lr, o).addScaledVector(Pr, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Vv = 0;
class Hn extends _s {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: Vv++ }),
      (this.uuid = Pn()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = Jr),
      (this.side = ui),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = op),
      (this.blendDst = ap),
      (this.blendEquation = Vr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Jc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = tv),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Ka),
      (this.stencilZFail = Ka),
      (this.stencilZPass = Ka),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' }
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== '' && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Jr && (n.blending = this.blending),
      this.side !== ui && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(s) {
      const o = [];
      for (const a in s) {
        const c = s[a];
        delete c.metadata, o.push(c);
      }
      return o;
    }
    if (t) {
      const s = i(e.textures),
        o = i(e.images);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const Ap = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
  wn = { h: 0, s: 0, l: 0 },
  To = { h: 0, s: 0, l: 0 };
function lc(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? r + (e - r) * 6 * (2 / 3 - t)
      : r
  );
}
class Re {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == 'number'
        ? this.setHex(i)
        : typeof i == 'string' && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = qe) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Xt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = Xt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      Xt.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = Xt.workingColorSpace) {
    if (((e = Vl(e, 1)), (t = Nt(t, 0, 1)), (n = Nt(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        o = 2 * n - s;
      (this.r = lc(o, s, e + 1 / 3)),
        (this.g = lc(o, s, e)),
        (this.b = lc(o, s, e - 1 / 3));
    }
    return Xt.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = qe) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          'THREE.Color: Alpha component of ' + e + ' will be ignored.'
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = i[1],
        a = i[2];
      switch (o) {
        case 'rgb':
        case 'rgba':
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case 'hsl':
        case 'hsla':
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn('THREE.Color: Unknown color model ' + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn('THREE.Color: Invalid hex color ' + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = qe) {
    const n = Ap[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn('THREE.Color: Unknown color ' + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Qr(e.r)), (this.g = Qr(e.g)), (this.b = Qr(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Za(e.r)), (this.g = Za(e.g)), (this.b = Za(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = qe) {
    return (
      Xt.fromWorkingColorSpace(Ot.copy(this), e),
      Math.round(Nt(Ot.r * 255, 0, 255)) * 65536 +
        Math.round(Nt(Ot.g * 255, 0, 255)) * 256 +
        Math.round(Nt(Ot.b * 255, 0, 255))
    );
  }
  getHexString(e = qe) {
    return ('000000' + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Xt.workingColorSpace) {
    Xt.fromWorkingColorSpace(Ot.copy(this), t);
    const n = Ot.r,
      i = Ot.g,
      s = Ot.b,
      o = Math.max(n, i, s),
      a = Math.min(n, i, s);
    let c, l;
    const h = (a + o) / 2;
    if (a === o) (c = 0), (l = 0);
    else {
      const f = o - a;
      switch (((l = h <= 0.5 ? f / (o + a) : f / (2 - o - a)), o)) {
        case n:
          c = (i - s) / f + (i < s ? 6 : 0);
          break;
        case i:
          c = (s - n) / f + 2;
          break;
        case s:
          c = (n - i) / f + 4;
          break;
      }
      c /= 6;
    }
    return (e.h = c), (e.s = l), (e.l = h), e;
  }
  getRGB(e, t = Xt.workingColorSpace) {
    return (
      Xt.fromWorkingColorSpace(Ot.copy(this), t),
      (e.r = Ot.r),
      (e.g = Ot.g),
      (e.b = Ot.b),
      e
    );
  }
  getStyle(e = qe) {
    Xt.fromWorkingColorSpace(Ot.copy(this), e);
    const t = Ot.r,
      n = Ot.g,
      i = Ot.b;
    return e !== qe
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(wn),
      (wn.h += e),
      (wn.s += t),
      (wn.l += n),
      this.setHSL(wn.h, wn.s, wn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(wn), e.getHSL(To);
    const n = Gs(wn.h, To.h, t),
      i = Gs(wn.s, To.s, t),
      s = Gs(wn.l, To.l, t);
    return this.setHSL(n, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * i),
      (this.g = s[1] * t + s[4] * n + s[7] * i),
      (this.b = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ot = new Re();
Re.NAMES = Ap;
class rr extends Hn {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new Re(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = cp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const pt = new P(),
  Ao = new Ve();
class Lt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.'
      );
    (this.isBufferAttribute = !0),
      (this.name = ''),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = il),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = oi),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Ao.fromBufferAttribute(this, t),
          Ao.applyMatrix3(e),
          this.setXY(t, Ao.x, Ao.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        pt.fromBufferAttribute(this, t),
          pt.applyMatrix3(e),
          this.setXYZ(t, pt.x, pt.y, pt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      pt.fromBufferAttribute(this, t),
        pt.applyMatrix4(e),
        this.setXYZ(t, pt.x, pt.y, pt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      pt.fromBufferAttribute(this, t),
        pt.applyNormalMatrix(e),
        this.setXYZ(t, pt.x, pt.y, pt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      pt.fromBufferAttribute(this, t),
        pt.transformDirection(e),
        this.setXYZ(t, pt.x, pt.y, pt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Fn(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = Ye(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Ye(t, this.array)), (n = Ye(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ye(t, this.array)),
        (n = Ye(n, this.array)),
        (i = Ye(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ye(t, this.array)),
        (n = Ye(n, this.array)),
        (i = Ye(i, this.array)),
        (s = Ye(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return (
      this.name !== '' && (e.name = this.name),
      this.usage !== il && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class wp extends Lt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Rp extends Lt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class ci extends Lt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let Wv = 0;
const fn = new Ue(),
  hc = new st(),
  Dr = new P(),
  sn = new fi(),
  Rs = new fi(),
  Mt = new P();
class Dn extends _s {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: Wv++ }),
      (this.uuid = Pn()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Mp(e) ? Rp : wp)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new Oe().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return fn.makeRotationFromQuaternion(e), this.applyMatrix4(fn), this;
  }
  rotateX(e) {
    return fn.makeRotationX(e), this.applyMatrix4(fn), this;
  }
  rotateY(e) {
    return fn.makeRotationY(e), this.applyMatrix4(fn), this;
  }
  rotateZ(e) {
    return fn.makeRotationZ(e), this.applyMatrix4(fn), this;
  }
  translate(e, t, n) {
    return fn.makeTranslation(e, t, n), this.applyMatrix4(fn), this;
  }
  scale(e, t, n) {
    return fn.makeScale(e, t, n), this.applyMatrix4(fn), this;
  }
  lookAt(e) {
    return hc.lookAt(e), hc.updateMatrix(), this.applyMatrix4(hc.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Dr).negate(),
      this.translate(Dr.x, Dr.y, Dr.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute('position', new ci(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new fi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new P(-1 / 0, -1 / 0, -1 / 0),
          new P(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          sn.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Mt.addVectors(this.boundingBox.min, sn.min),
                this.boundingBox.expandByPoint(Mt),
                Mt.addVectors(this.boundingBox.max, sn.max),
                this.boundingBox.expandByPoint(Mt))
              : (this.boundingBox.expandByPoint(sn.min),
                this.boundingBox.expandByPoint(sn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new qn());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new P(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((sn.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Rs.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Mt.addVectors(sn.min, Rs.min),
                sn.expandByPoint(Mt),
                Mt.addVectors(sn.max, Rs.max),
                sn.expandByPoint(Mt))
              : (sn.expandByPoint(Rs.min), sn.expandByPoint(Rs.max));
        }
      sn.getCenter(n);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Mt.fromBufferAttribute(e, s),
          (i = Math.max(i, n.distanceToSquared(Mt)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            c = this.morphTargetsRelative;
          for (let l = 0, h = a.count; l < h; l++)
            Mt.fromBufferAttribute(a, l),
              c && (Dr.fromBufferAttribute(e, l), Mt.add(Dr)),
              (i = Math.max(i, n.distanceToSquared(Mt)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
      );
      return;
    }
    const n = e.array,
      i = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = i.length / 3;
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new Lt(new Float32Array(4 * a), 4));
    const c = this.getAttribute('tangent').array,
      l = [],
      h = [];
    for (let A = 0; A < a; A++) (l[A] = new P()), (h[A] = new P());
    const f = new P(),
      u = new P(),
      p = new P(),
      _ = new Ve(),
      g = new Ve(),
      d = new Ve(),
      m = new P(),
      y = new P();
    function v(A, X, Y) {
      f.fromArray(i, A * 3),
        u.fromArray(i, X * 3),
        p.fromArray(i, Y * 3),
        _.fromArray(o, A * 2),
        g.fromArray(o, X * 2),
        d.fromArray(o, Y * 2),
        u.sub(f),
        p.sub(f),
        g.sub(_),
        d.sub(_);
      const D = 1 / (g.x * d.y - d.x * g.y);
      isFinite(D) &&
        (m
          .copy(u)
          .multiplyScalar(d.y)
          .addScaledVector(p, -g.y)
          .multiplyScalar(D),
        y
          .copy(p)
          .multiplyScalar(g.x)
          .addScaledVector(u, -d.x)
          .multiplyScalar(D),
        l[A].add(m),
        l[X].add(m),
        l[Y].add(m),
        h[A].add(y),
        h[X].add(y),
        h[Y].add(y));
    }
    let x = this.groups;
    x.length === 0 && (x = [{ start: 0, count: n.length }]);
    for (let A = 0, X = x.length; A < X; ++A) {
      const Y = x[A],
        D = Y.start,
        F = Y.count;
      for (let N = D, K = D + F; N < K; N += 3) v(n[N + 0], n[N + 1], n[N + 2]);
    }
    const S = new P(),
      b = new P(),
      T = new P(),
      C = new P();
    function M(A) {
      T.fromArray(s, A * 3), C.copy(T);
      const X = l[A];
      S.copy(X),
        S.sub(T.multiplyScalar(T.dot(X))).normalize(),
        b.crossVectors(C, X);
      const D = b.dot(h[A]) < 0 ? -1 : 1;
      (c[A * 4] = S.x),
        (c[A * 4 + 1] = S.y),
        (c[A * 4 + 2] = S.z),
        (c[A * 4 + 3] = D);
    }
    for (let A = 0, X = x.length; A < X; ++A) {
      const Y = x[A],
        D = Y.start,
        F = Y.count;
      for (let N = D, K = D + F; N < K; N += 3)
        M(n[N + 0]), M(n[N + 1]), M(n[N + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute('position');
    if (t !== void 0) {
      let n = this.getAttribute('normal');
      if (n === void 0)
        (n = new Lt(new Float32Array(t.count * 3), 3)),
          this.setAttribute('normal', n);
      else for (let u = 0, p = n.count; u < p; u++) n.setXYZ(u, 0, 0, 0);
      const i = new P(),
        s = new P(),
        o = new P(),
        a = new P(),
        c = new P(),
        l = new P(),
        h = new P(),
        f = new P();
      if (e)
        for (let u = 0, p = e.count; u < p; u += 3) {
          const _ = e.getX(u + 0),
            g = e.getX(u + 1),
            d = e.getX(u + 2);
          i.fromBufferAttribute(t, _),
            s.fromBufferAttribute(t, g),
            o.fromBufferAttribute(t, d),
            h.subVectors(o, s),
            f.subVectors(i, s),
            h.cross(f),
            a.fromBufferAttribute(n, _),
            c.fromBufferAttribute(n, g),
            l.fromBufferAttribute(n, d),
            a.add(h),
            c.add(h),
            l.add(h),
            n.setXYZ(_, a.x, a.y, a.z),
            n.setXYZ(g, c.x, c.y, c.z),
            n.setXYZ(d, l.x, l.y, l.z);
        }
      else
        for (let u = 0, p = t.count; u < p; u += 3)
          i.fromBufferAttribute(t, u + 0),
            s.fromBufferAttribute(t, u + 1),
            o.fromBufferAttribute(t, u + 2),
            h.subVectors(o, s),
            f.subVectors(i, s),
            h.cross(f),
            n.setXYZ(u + 0, h.x, h.y, h.z),
            n.setXYZ(u + 1, h.x, h.y, h.z),
            n.setXYZ(u + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Mt.fromBufferAttribute(e, t),
        Mt.normalize(),
        e.setXYZ(t, Mt.x, Mt.y, Mt.z);
  }
  toNonIndexed() {
    function e(a, c) {
      const l = a.array,
        h = a.itemSize,
        f = a.normalized,
        u = new l.constructor(c.length * h);
      let p = 0,
        _ = 0;
      for (let g = 0, d = c.length; g < d; g++) {
        a.isInterleavedBufferAttribute
          ? (p = c[g] * a.data.stride + a.offset)
          : (p = c[g] * h);
        for (let m = 0; m < h; m++) u[_++] = l[p++];
      }
      return new Lt(u, h, f);
    }
    if (this.index === null)
      return (
        console.warn(
          'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
        ),
        this
      );
    const t = new Dn(),
      n = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const c = i[a],
        l = e(c, n);
      t.setAttribute(a, l);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const c = [],
        l = s[a];
      for (let h = 0, f = l.length; h < f; h++) {
        const u = l[h],
          p = e(u, n);
        c.push(p);
      }
      t.morphAttributes[a] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, c = o.length; a < c; a++) {
      const l = o[a];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== '' && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const c = this.parameters;
      for (const l in c) c[l] !== void 0 && (e[l] = c[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array)
      });
    const n = this.attributes;
    for (const c in n) {
      const l = n[c];
      e.data.attributes[c] = l.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const c in this.morphAttributes) {
      const l = this.morphAttributes[c],
        h = [];
      for (let f = 0, u = l.length; f < u; f++) {
        const p = l[f];
        h.push(p.toJSON(e.data));
      }
      h.length > 0 && ((i[c] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const l in i) {
      const h = i[l];
      this.setAttribute(l, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const h = [],
        f = s[l];
      for (let u = 0, p = f.length; u < p; u++) h.push(f[u].clone(t));
      this.morphAttributes[l] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, h = o.length; l < h; l++) {
      const f = o[l];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const c = e.boundingSphere;
    return (
      c !== null && (this.boundingSphere = c.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
const Iu = new Ue(),
  Xi = new xa(),
  wo = new qn(),
  Ou = new P(),
  Ir = new P(),
  Or = new P(),
  Ur = new P(),
  uc = new P(),
  Ro = new P(),
  Co = new Ve(),
  Lo = new Ve(),
  Po = new Ve(),
  Uu = new P(),
  Nu = new P(),
  Fu = new P(),
  Do = new P(),
  Io = new P();
class bn extends st {
  constructor(e = new Dn(), t = new rr()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      s = n.morphAttributes.position,
      o = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Ro.set(0, 0, 0);
      for (let c = 0, l = s.length; c < l; c++) {
        const h = a[c],
          f = s[c];
        h !== 0 &&
          (uc.fromBufferAttribute(f, e),
          o ? Ro.addScaledVector(uc, h) : Ro.addScaledVector(uc.sub(t), h));
      }
      t.add(Ro);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      wo.copy(n.boundingSphere),
      wo.applyMatrix4(s),
      Xi.copy(e.ray).recast(e.near),
      !(
        wo.containsPoint(Xi.origin) === !1 &&
        (Xi.intersectSphere(wo, Ou) === null ||
          Xi.origin.distanceToSquared(Ou) > (e.far - e.near) ** 2)
      ) &&
        (Iu.copy(s).invert(),
        Xi.copy(e.ray).applyMatrix4(Iu),
        !(n.boundingBox !== null && Xi.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, Xi)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      c = s.attributes.position,
      l = s.attributes.uv,
      h = s.attributes.uv1,
      f = s.attributes.normal,
      u = s.groups,
      p = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let _ = 0, g = u.length; _ < g; _++) {
          const d = u[_],
            m = o[d.materialIndex],
            y = Math.max(d.start, p.start),
            v = Math.min(
              a.count,
              Math.min(d.start + d.count, p.start + p.count)
            );
          for (let x = y, S = v; x < S; x += 3) {
            const b = a.getX(x),
              T = a.getX(x + 1),
              C = a.getX(x + 2);
            (i = Oo(this, m, e, n, l, h, f, b, T, C)),
              i &&
                ((i.faceIndex = Math.floor(x / 3)),
                (i.face.materialIndex = d.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, p.start),
          g = Math.min(a.count, p.start + p.count);
        for (let d = _, m = g; d < m; d += 3) {
          const y = a.getX(d),
            v = a.getX(d + 1),
            x = a.getX(d + 2);
          (i = Oo(this, o, e, n, l, h, f, y, v, x)),
            i && ((i.faceIndex = Math.floor(d / 3)), t.push(i));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, g = u.length; _ < g; _++) {
          const d = u[_],
            m = o[d.materialIndex],
            y = Math.max(d.start, p.start),
            v = Math.min(
              c.count,
              Math.min(d.start + d.count, p.start + p.count)
            );
          for (let x = y, S = v; x < S; x += 3) {
            const b = x,
              T = x + 1,
              C = x + 2;
            (i = Oo(this, m, e, n, l, h, f, b, T, C)),
              i &&
                ((i.faceIndex = Math.floor(x / 3)),
                (i.face.materialIndex = d.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, p.start),
          g = Math.min(c.count, p.start + p.count);
        for (let d = _, m = g; d < m; d += 3) {
          const y = d,
            v = d + 1,
            x = d + 2;
          (i = Oo(this, o, e, n, l, h, f, y, v, x)),
            i && ((i.faceIndex = Math.floor(d / 3)), t.push(i));
        }
      }
  }
}
function qv(r, e, t, n, i, s, o, a) {
  let c;
  if (
    (e.side === Jt
      ? (c = n.intersectTriangle(o, s, i, !0, a))
      : (c = n.intersectTriangle(i, s, o, e.side === ui, a)),
    c === null)
  )
    return null;
  Io.copy(a), Io.applyMatrix4(r.matrixWorld);
  const l = t.ray.origin.distanceTo(Io);
  return l < t.near || l > t.far
    ? null
    : { distance: l, point: Io.clone(), object: r };
}
function Oo(r, e, t, n, i, s, o, a, c, l) {
  r.getVertexPosition(a, Ir),
    r.getVertexPosition(c, Or),
    r.getVertexPosition(l, Ur);
  const h = qv(r, e, t, n, Ir, Or, Ur, Do);
  if (h) {
    i &&
      (Co.fromBufferAttribute(i, a),
      Lo.fromBufferAttribute(i, c),
      Po.fromBufferAttribute(i, l),
      (h.uv = Cn.getInterpolation(Do, Ir, Or, Ur, Co, Lo, Po, new Ve()))),
      s &&
        (Co.fromBufferAttribute(s, a),
        Lo.fromBufferAttribute(s, c),
        Po.fromBufferAttribute(s, l),
        (h.uv1 = Cn.getInterpolation(Do, Ir, Or, Ur, Co, Lo, Po, new Ve())),
        (h.uv2 = h.uv1)),
      o &&
        (Uu.fromBufferAttribute(o, a),
        Nu.fromBufferAttribute(o, c),
        Fu.fromBufferAttribute(o, l),
        (h.normal = Cn.getInterpolation(Do, Ir, Or, Ur, Uu, Nu, Fu, new P())),
        h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const f = { a, b: c, c: l, normal: new P(), materialIndex: 0 };
    Cn.getNormal(Ir, Or, Ur, f.normal), (h.face = f);
  }
  return h;
}
class io extends Dn {
  constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o
      });
    const a = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
    const c = [],
      l = [],
      h = [],
      f = [];
    let u = 0,
      p = 0;
    _('z', 'y', 'x', -1, -1, n, t, e, o, s, 0),
      _('z', 'y', 'x', 1, -1, n, t, -e, o, s, 1),
      _('x', 'z', 'y', 1, 1, e, n, t, i, o, 2),
      _('x', 'z', 'y', 1, -1, e, n, -t, i, o, 3),
      _('x', 'y', 'z', 1, -1, e, t, n, i, s, 4),
      _('x', 'y', 'z', -1, -1, e, t, -n, i, s, 5),
      this.setIndex(c),
      this.setAttribute('position', new ci(l, 3)),
      this.setAttribute('normal', new ci(h, 3)),
      this.setAttribute('uv', new ci(f, 2));
    function _(g, d, m, y, v, x, S, b, T, C, M) {
      const A = x / T,
        X = S / C,
        Y = x / 2,
        D = S / 2,
        F = b / 2,
        N = T + 1,
        K = C + 1;
      let z = 0,
        j = 0;
      const J = new P();
      for (let $ = 0; $ < K; $++) {
        const k = $ * X - D;
        for (let V = 0; V < N; V++) {
          const oe = V * A - Y;
          (J[g] = oe * y),
            (J[d] = k * v),
            (J[m] = F),
            l.push(J.x, J.y, J.z),
            (J[g] = 0),
            (J[d] = 0),
            (J[m] = b > 0 ? 1 : -1),
            h.push(J.x, J.y, J.z),
            f.push(V / T),
            f.push(1 - $ / C),
            (z += 1);
        }
      }
      for (let $ = 0; $ < C; $++)
        for (let k = 0; k < T; k++) {
          const V = u + k + N * $,
            oe = u + k + N * ($ + 1),
            re = u + (k + 1) + N * ($ + 1),
            le = u + (k + 1) + N * $;
          c.push(V, oe, le), c.push(oe, re, le), (j += 6);
        }
      a.addGroup(p, j, M), (p += j), (u += z);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new io(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function fs(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function Vt(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = fs(r[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function Xv(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function Cp(r) {
  return r.getRenderTarget() === null ? r.outputColorSpace : _t;
}
const jv = { clone: fs, merge: Vt };
var Yv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Kv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class vr extends Hn {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = Yv),
      (this.fragmentShader = Kv),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0]
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = fs(e.uniforms)),
      (this.uniformsGroups = Xv(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: 't', value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: 'c', value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: 'v2', value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: 'v3', value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: 'v4', value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: 'm3', value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: 'm4', value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Lp extends st {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new Ue()),
      (this.projectionMatrix = new Ue()),
      (this.projectionMatrixInverse = new Ue()),
      (this.coordinateSystem = ai);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Wt extends Lp {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = us * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Hs * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return us * 2 * Math.atan(Math.tan(Hs * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Hs * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = o.fullWidth,
        l = o.fullHeight;
      (s += (o.offsetX * i) / c),
        (t -= (o.offsetY * n) / l),
        (i *= o.width / c),
        (n *= o.height / l);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Nr = -90,
  Fr = 1;
class $v extends st {
  constructor(e, t, n) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = n),
      (this.coordinateSystem = null);
    const i = new Wt(Nr, Fr, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new Wt(Nr, Fr, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new Wt(Nr, Fr, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new Wt(Nr, Fr, e, t);
    (a.layers = this.layers), this.add(a);
    const c = new Wt(Nr, Fr, e, t);
    (c.layers = this.layers), this.add(c);
    const l = new Wt(Nr, Fr, e, t);
    (l.layers = this.layers), this.add(l);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, s, o, a, c] = t;
    for (const l of t) this.remove(l);
    if (e === ai)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1);
    else if (e === ha)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        c.up.set(0, -1, 0),
        c.lookAt(0, 0, -1);
    else
      throw new Error(
        'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
          e
      );
    for (const l of t) this.add(l), l.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [i, s, o, a, c, l] = this.children,
      h = e.getRenderTarget(),
      f = e.xr.enabled;
    e.xr.enabled = !1;
    const u = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, s),
      e.setRenderTarget(n, 2),
      e.render(t, o),
      e.setRenderTarget(n, 3),
      e.render(t, a),
      e.setRenderTarget(n, 4),
      e.render(t, c),
      (n.texture.generateMipmaps = u),
      e.setRenderTarget(n, 5),
      e.render(t, l),
      e.setRenderTarget(h),
      (e.xr.enabled = f),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Pp extends Ct {
  constructor(e, t, n, i, s, o, a, c, l, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : os),
      super(e, t, n, i, s, o, a, c, l, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Zv extends _r {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    t.encoding !== void 0 &&
      (Vs(
        'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.'
      ),
      (t.colorSpace = t.encoding === dr ? qe : pr)),
      (this.texture = new Pp(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : jt);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      },
      i = new io(5, 5, 5),
      s = new vr({
        name: 'CubemapFromEquirect',
        uniforms: fs(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Jt,
        blending: Di
      });
    s.uniforms.tEquirect.value = t;
    const o = new bn(i, s),
      a = t.minFilter;
    return (
      t.minFilter === gr && (t.minFilter = jt),
      new $v(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(s);
  }
}
const fc = new P(),
  Jv = new P(),
  Qv = new Oe();
class Zi {
  constructor(e = new P(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = fc.subVectors(n, t).cross(Jv.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(fc),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Qv.getNormalMatrix(e),
      i = this.coplanarPoint(fc).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ji = new qn(),
  Uo = new P();
class Wl {
  constructor(
    e = new Zi(),
    t = new Zi(),
    n = new Zi(),
    i = new Zi(),
    s = new Zi(),
    o = new Zi()
  ) {
    this.planes = [e, t, n, i, s, o];
  }
  set(e, t, n, i, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(n),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = ai) {
    const n = this.planes,
      i = e.elements,
      s = i[0],
      o = i[1],
      a = i[2],
      c = i[3],
      l = i[4],
      h = i[5],
      f = i[6],
      u = i[7],
      p = i[8],
      _ = i[9],
      g = i[10],
      d = i[11],
      m = i[12],
      y = i[13],
      v = i[14],
      x = i[15];
    if (
      (n[0].setComponents(c - s, u - l, d - p, x - m).normalize(),
      n[1].setComponents(c + s, u + l, d + p, x + m).normalize(),
      n[2].setComponents(c + o, u + h, d + _, x + y).normalize(),
      n[3].setComponents(c - o, u - h, d - _, x - y).normalize(),
      n[4].setComponents(c - a, u - f, d - g, x - v).normalize(),
      t === ai)
    )
      n[5].setComponents(c + a, u + f, d + g, x + v).normalize();
    else if (t === ha) n[5].setComponents(a, f, g, v).normalize();
    else
      throw new Error(
        'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        ji.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        ji.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ji);
  }
  intersectsSprite(e) {
    return (
      ji.center.set(0, 0, 0),
      (ji.radius = 0.7071067811865476),
      ji.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(ji)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((Uo.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Uo.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Uo.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Uo) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Dp() {
  let r = null,
    e = !1,
    t = null,
    n = null;
  function i(s, o) {
    t(s, o), (n = r.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = r.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      r = s;
    }
  };
}
function ey(r, e) {
  const t = e.isWebGL2,
    n = new WeakMap();
  function i(l, h) {
    const f = l.array,
      u = l.usage,
      p = r.createBuffer();
    r.bindBuffer(h, p), r.bufferData(h, f, u), l.onUploadCallback();
    let _;
    if (f instanceof Float32Array) _ = r.FLOAT;
    else if (f instanceof Uint16Array)
      if (l.isFloat16BufferAttribute)
        if (t) _ = r.HALF_FLOAT;
        else
          throw new Error(
            'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
          );
      else _ = r.UNSIGNED_SHORT;
    else if (f instanceof Int16Array) _ = r.SHORT;
    else if (f instanceof Uint32Array) _ = r.UNSIGNED_INT;
    else if (f instanceof Int32Array) _ = r.INT;
    else if (f instanceof Int8Array) _ = r.BYTE;
    else if (f instanceof Uint8Array) _ = r.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray) _ = r.UNSIGNED_BYTE;
    else
      throw new Error(
        'THREE.WebGLAttributes: Unsupported buffer data format: ' + f
      );
    return {
      buffer: p,
      type: _,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: l.version
    };
  }
  function s(l, h, f) {
    const u = h.array,
      p = h.updateRange;
    r.bindBuffer(f, l),
      p.count === -1
        ? r.bufferSubData(f, 0, u)
        : (t
            ? r.bufferSubData(
                f,
                p.offset * u.BYTES_PER_ELEMENT,
                u,
                p.offset,
                p.count
              )
            : r.bufferSubData(
                f,
                p.offset * u.BYTES_PER_ELEMENT,
                u.subarray(p.offset, p.offset + p.count)
              ),
          (p.count = -1)),
      h.onUploadCallback();
  }
  function o(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), n.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const h = n.get(l);
    h && (r.deleteBuffer(h.buffer), n.delete(l));
  }
  function c(l, h) {
    if (l.isGLBufferAttribute) {
      const u = n.get(l);
      (!u || u.version < l.version) &&
        n.set(l, {
          buffer: l.buffer,
          type: l.type,
          bytesPerElement: l.elementSize,
          version: l.version
        });
      return;
    }
    l.isInterleavedBufferAttribute && (l = l.data);
    const f = n.get(l);
    f === void 0
      ? n.set(l, i(l, h))
      : f.version < l.version && (s(f.buffer, l, h), (f.version = l.version));
  }
  return { get: o, remove: a, update: c };
}
class ql extends Dn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(n),
      c = Math.floor(i),
      l = a + 1,
      h = c + 1,
      f = e / a,
      u = t / c,
      p = [],
      _ = [],
      g = [],
      d = [];
    for (let m = 0; m < h; m++) {
      const y = m * u - o;
      for (let v = 0; v < l; v++) {
        const x = v * f - s;
        _.push(x, -y, 0), g.push(0, 0, 1), d.push(v / a), d.push(1 - m / c);
      }
    }
    for (let m = 0; m < c; m++)
      for (let y = 0; y < a; y++) {
        const v = y + l * m,
          x = y + l * (m + 1),
          S = y + 1 + l * (m + 1),
          b = y + 1 + l * m;
        p.push(v, x, b), p.push(x, S, b);
      }
    this.setIndex(p),
      this.setAttribute('position', new ci(_, 3)),
      this.setAttribute('normal', new ci(g, 3)),
      this.setAttribute('uv', new ci(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ql(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var ty = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  ny = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  iy = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  ry = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  sy = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  oy = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  ay = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  cy = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  ly = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  hy = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  uy = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  fy = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  dy = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  py = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  my = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  gy = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  _y = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  vy = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  yy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  xy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  My = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Sy = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  by = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Ey = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Ty = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Ay = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  wy = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Ry = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Cy = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  Ly = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Py = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  Dy = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  Iy = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  Oy = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Uy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Ny = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Fy = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  ky = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  By = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  zy = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Hy = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  Gy = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Vy = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Wy = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  qy = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Xy = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  jy = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  Yy = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  Ky = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  $y = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Zy = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  Jy = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Qy = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  ex = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  tx = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  nx = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  ix = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  rx = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  sx = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  ox = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  ax = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  cx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  lx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  hx = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  ux = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  fx = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  dx = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  px = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  mx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  gx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  _x = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  vx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  yx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  xx = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Mx = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Sx = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  bx = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  Ex = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  Tx = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  Ax = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  wx = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Rx = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  Cx = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Lx = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Px = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Dx = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  Ix = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  Ox = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  Ux = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Nx = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  Fx = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  kx = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  Bx = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  zx = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Hx = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  Gx = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Vx = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  Wx = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  qx = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  Xx = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  jx = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  Yx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Kx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  $x = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Zx = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Jx = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Qx = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  eM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  tM = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  nM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  iM = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  rM = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  sM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  oM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  aM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  cM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  lM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  hM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  uM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  fM = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  dM = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  pM = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  mM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  gM = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  _M = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  yM = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  xM = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  MM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  SM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  bM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  EM = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  TM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  AM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  wM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  RM = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  CM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  LM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  PM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Pe = {
    alphahash_fragment: ty,
    alphahash_pars_fragment: ny,
    alphamap_fragment: iy,
    alphamap_pars_fragment: ry,
    alphatest_fragment: sy,
    alphatest_pars_fragment: oy,
    aomap_fragment: ay,
    aomap_pars_fragment: cy,
    begin_vertex: ly,
    beginnormal_vertex: hy,
    bsdfs: uy,
    iridescence_fragment: fy,
    bumpmap_pars_fragment: dy,
    clipping_planes_fragment: py,
    clipping_planes_pars_fragment: my,
    clipping_planes_pars_vertex: gy,
    clipping_planes_vertex: _y,
    color_fragment: vy,
    color_pars_fragment: yy,
    color_pars_vertex: xy,
    color_vertex: My,
    common: Sy,
    cube_uv_reflection_fragment: by,
    defaultnormal_vertex: Ey,
    displacementmap_pars_vertex: Ty,
    displacementmap_vertex: Ay,
    emissivemap_fragment: wy,
    emissivemap_pars_fragment: Ry,
    colorspace_fragment: Cy,
    colorspace_pars_fragment: Ly,
    envmap_fragment: Py,
    envmap_common_pars_fragment: Dy,
    envmap_pars_fragment: Iy,
    envmap_pars_vertex: Oy,
    envmap_physical_pars_fragment: Xy,
    envmap_vertex: Uy,
    fog_vertex: Ny,
    fog_pars_vertex: Fy,
    fog_fragment: ky,
    fog_pars_fragment: By,
    gradientmap_pars_fragment: zy,
    lightmap_fragment: Hy,
    lightmap_pars_fragment: Gy,
    lights_lambert_fragment: Vy,
    lights_lambert_pars_fragment: Wy,
    lights_pars_begin: qy,
    lights_toon_fragment: jy,
    lights_toon_pars_fragment: Yy,
    lights_phong_fragment: Ky,
    lights_phong_pars_fragment: $y,
    lights_physical_fragment: Zy,
    lights_physical_pars_fragment: Jy,
    lights_fragment_begin: Qy,
    lights_fragment_maps: ex,
    lights_fragment_end: tx,
    logdepthbuf_fragment: nx,
    logdepthbuf_pars_fragment: ix,
    logdepthbuf_pars_vertex: rx,
    logdepthbuf_vertex: sx,
    map_fragment: ox,
    map_pars_fragment: ax,
    map_particle_fragment: cx,
    map_particle_pars_fragment: lx,
    metalnessmap_fragment: hx,
    metalnessmap_pars_fragment: ux,
    morphcolor_vertex: fx,
    morphnormal_vertex: dx,
    morphtarget_pars_vertex: px,
    morphtarget_vertex: mx,
    normal_fragment_begin: gx,
    normal_fragment_maps: _x,
    normal_pars_fragment: vx,
    normal_pars_vertex: yx,
    normal_vertex: xx,
    normalmap_pars_fragment: Mx,
    clearcoat_normal_fragment_begin: Sx,
    clearcoat_normal_fragment_maps: bx,
    clearcoat_pars_fragment: Ex,
    iridescence_pars_fragment: Tx,
    opaque_fragment: Ax,
    packing: wx,
    premultiplied_alpha_fragment: Rx,
    project_vertex: Cx,
    dithering_fragment: Lx,
    dithering_pars_fragment: Px,
    roughnessmap_fragment: Dx,
    roughnessmap_pars_fragment: Ix,
    shadowmap_pars_fragment: Ox,
    shadowmap_pars_vertex: Ux,
    shadowmap_vertex: Nx,
    shadowmask_pars_fragment: Fx,
    skinbase_vertex: kx,
    skinning_pars_vertex: Bx,
    skinning_vertex: zx,
    skinnormal_vertex: Hx,
    specularmap_fragment: Gx,
    specularmap_pars_fragment: Vx,
    tonemapping_fragment: Wx,
    tonemapping_pars_fragment: qx,
    transmission_fragment: Xx,
    transmission_pars_fragment: jx,
    uv_pars_fragment: Yx,
    uv_pars_vertex: Kx,
    uv_vertex: $x,
    worldpos_vertex: Zx,
    background_vert: Jx,
    background_frag: Qx,
    backgroundCube_vert: eM,
    backgroundCube_frag: tM,
    cube_vert: nM,
    cube_frag: iM,
    depth_vert: rM,
    depth_frag: sM,
    distanceRGBA_vert: oM,
    distanceRGBA_frag: aM,
    equirect_vert: cM,
    equirect_frag: lM,
    linedashed_vert: hM,
    linedashed_frag: uM,
    meshbasic_vert: fM,
    meshbasic_frag: dM,
    meshlambert_vert: pM,
    meshlambert_frag: mM,
    meshmatcap_vert: gM,
    meshmatcap_frag: _M,
    meshnormal_vert: vM,
    meshnormal_frag: yM,
    meshphong_vert: xM,
    meshphong_frag: MM,
    meshphysical_vert: SM,
    meshphysical_frag: bM,
    meshtoon_vert: EM,
    meshtoon_frag: TM,
    points_vert: AM,
    points_frag: wM,
    shadow_vert: RM,
    shadow_frag: CM,
    sprite_vert: LM,
    sprite_frag: PM
  },
  se = {
    common: {
      diffuse: { value: new Re(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Oe() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Oe() },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Oe() }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Oe() }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Oe() }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Oe() },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Oe() },
      normalScale: { value: new Ve(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Oe() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Oe() }
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Oe() }
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Oe() }
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Re(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new Re(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Oe() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Oe() }
    },
    sprite: {
      diffuse: { value: new Re(16777215) },
      opacity: { value: 1 },
      center: { value: new Ve(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Oe() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Oe() },
      alphaTest: { value: 0 }
    }
  },
  On = {
    basic: {
      uniforms: Vt([
        se.common,
        se.specularmap,
        se.envmap,
        se.aomap,
        se.lightmap,
        se.fog
      ]),
      vertexShader: Pe.meshbasic_vert,
      fragmentShader: Pe.meshbasic_frag
    },
    lambert: {
      uniforms: Vt([
        se.common,
        se.specularmap,
        se.envmap,
        se.aomap,
        se.lightmap,
        se.emissivemap,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        se.fog,
        se.lights,
        { emissive: { value: new Re(0) } }
      ]),
      vertexShader: Pe.meshlambert_vert,
      fragmentShader: Pe.meshlambert_frag
    },
    phong: {
      uniforms: Vt([
        se.common,
        se.specularmap,
        se.envmap,
        se.aomap,
        se.lightmap,
        se.emissivemap,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        se.fog,
        se.lights,
        {
          emissive: { value: new Re(0) },
          specular: { value: new Re(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: Pe.meshphong_vert,
      fragmentShader: Pe.meshphong_frag
    },
    standard: {
      uniforms: Vt([
        se.common,
        se.envmap,
        se.aomap,
        se.lightmap,
        se.emissivemap,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        se.roughnessmap,
        se.metalnessmap,
        se.fog,
        se.lights,
        {
          emissive: { value: new Re(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: Pe.meshphysical_vert,
      fragmentShader: Pe.meshphysical_frag
    },
    toon: {
      uniforms: Vt([
        se.common,
        se.aomap,
        se.lightmap,
        se.emissivemap,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        se.gradientmap,
        se.fog,
        se.lights,
        { emissive: { value: new Re(0) } }
      ]),
      vertexShader: Pe.meshtoon_vert,
      fragmentShader: Pe.meshtoon_frag
    },
    matcap: {
      uniforms: Vt([
        se.common,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        se.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: Pe.meshmatcap_vert,
      fragmentShader: Pe.meshmatcap_frag
    },
    points: {
      uniforms: Vt([se.points, se.fog]),
      vertexShader: Pe.points_vert,
      fragmentShader: Pe.points_frag
    },
    dashed: {
      uniforms: Vt([
        se.common,
        se.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
      ]),
      vertexShader: Pe.linedashed_vert,
      fragmentShader: Pe.linedashed_frag
    },
    depth: {
      uniforms: Vt([se.common, se.displacementmap]),
      vertexShader: Pe.depth_vert,
      fragmentShader: Pe.depth_frag
    },
    normal: {
      uniforms: Vt([
        se.common,
        se.bumpmap,
        se.normalmap,
        se.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: Pe.meshnormal_vert,
      fragmentShader: Pe.meshnormal_frag
    },
    sprite: {
      uniforms: Vt([se.sprite, se.fog]),
      vertexShader: Pe.sprite_vert,
      fragmentShader: Pe.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Oe() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 }
      },
      vertexShader: Pe.background_vert,
      fragmentShader: Pe.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 }
      },
      vertexShader: Pe.backgroundCube_vert,
      fragmentShader: Pe.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: Pe.cube_vert,
      fragmentShader: Pe.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Pe.equirect_vert,
      fragmentShader: Pe.equirect_frag
    },
    distanceRGBA: {
      uniforms: Vt([
        se.common,
        se.displacementmap,
        {
          referencePosition: { value: new P() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: Pe.distanceRGBA_vert,
      fragmentShader: Pe.distanceRGBA_frag
    },
    shadow: {
      uniforms: Vt([
        se.lights,
        se.fog,
        { color: { value: new Re(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: Pe.shadow_vert,
      fragmentShader: Pe.shadow_frag
    }
  };
On.physical = {
  uniforms: Vt([
    On.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Oe() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Oe() },
      clearcoatNormalScale: { value: new Ve(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Oe() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Oe() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Oe() },
      sheen: { value: 0 },
      sheenColor: { value: new Re(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Oe() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Oe() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Oe() },
      transmissionSamplerSize: { value: new Ve() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Oe() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Re(0) },
      specularColor: { value: new Re(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Oe() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Oe() },
      anisotropyVector: { value: new Ve() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Oe() }
    }
  ]),
  vertexShader: Pe.meshphysical_vert,
  fragmentShader: Pe.meshphysical_frag
};
const No = { r: 0, b: 0, g: 0 };
function DM(r, e, t, n, i, s, o) {
  const a = new Re(0);
  let c = s === !0 ? 0 : 1,
    l,
    h,
    f = null,
    u = 0,
    p = null;
  function _(d, m) {
    let y = !1,
      v = m.isScene === !0 ? m.background : null;
    v && v.isTexture && (v = (m.backgroundBlurriness > 0 ? t : e).get(v)),
      v === null ? g(a, c) : v && v.isColor && (g(v, 1), (y = !0));
    const x = r.xr.getEnvironmentBlendMode();
    x === 'additive'
      ? n.buffers.color.setClear(0, 0, 0, 1, o)
      : x === 'alpha-blend' && n.buffers.color.setClear(0, 0, 0, 0, o),
      (r.autoClear || y) &&
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
      v && (v.isCubeTexture || v.mapping === va)
        ? (h === void 0 &&
            ((h = new bn(
              new io(1, 1, 1),
              new vr({
                name: 'BackgroundCubeMaterial',
                uniforms: fs(On.backgroundCube.uniforms),
                vertexShader: On.backgroundCube.vertexShader,
                fragmentShader: On.backgroundCube.fragmentShader,
                side: Jt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
              })
            )),
            h.geometry.deleteAttribute('normal'),
            h.geometry.deleteAttribute('uv'),
            (h.onBeforeRender = function (S, b, T) {
              this.matrixWorld.copyPosition(T.matrixWorld);
            }),
            Object.defineProperty(h.material, 'envMap', {
              get: function () {
                return this.uniforms.envMap.value;
              }
            }),
            i.update(h)),
          (h.material.uniforms.envMap.value = v),
          (h.material.uniforms.flipEnvMap.value =
            v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            m.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (h.material.toneMapped = v.colorSpace !== qe),
          (f !== v || u !== v.version || p !== r.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (f = v),
            (u = v.version),
            (p = r.toneMapping)),
          h.layers.enableAll(),
          d.unshift(h, h.geometry, h.material, 0, 0, null))
        : v &&
          v.isTexture &&
          (l === void 0 &&
            ((l = new bn(
              new ql(2, 2),
              new vr({
                name: 'BackgroundMaterial',
                uniforms: fs(On.background.uniforms),
                vertexShader: On.background.vertexShader,
                fragmentShader: On.background.fragmentShader,
                side: ui,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
              })
            )),
            l.geometry.deleteAttribute('normal'),
            Object.defineProperty(l.material, 'map', {
              get: function () {
                return this.uniforms.t2D.value;
              }
            }),
            i.update(l)),
          (l.material.uniforms.t2D.value = v),
          (l.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (l.material.toneMapped = v.colorSpace !== qe),
          v.matrixAutoUpdate === !0 && v.updateMatrix(),
          l.material.uniforms.uvTransform.value.copy(v.matrix),
          (f !== v || u !== v.version || p !== r.toneMapping) &&
            ((l.material.needsUpdate = !0),
            (f = v),
            (u = v.version),
            (p = r.toneMapping)),
          l.layers.enableAll(),
          d.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function g(d, m) {
    d.getRGB(No, Cp(r)), n.buffers.color.setClear(No.r, No.g, No.b, m, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (d, m = 1) {
      a.set(d), (c = m), g(a, c);
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (d) {
      (c = d), g(a, c);
    },
    render: _
  };
}
function IM(r, e, t, n) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    s = n.isWebGL2 ? null : e.get('OES_vertex_array_object'),
    o = n.isWebGL2 || s !== null,
    a = {},
    c = d(null);
  let l = c,
    h = !1;
  function f(F, N, K, z, j) {
    let J = !1;
    if (o) {
      const $ = g(z, K, N);
      l !== $ && ((l = $), p(l.object)),
        (J = m(F, z, K, j)),
        J && y(F, z, K, j);
    } else {
      const $ = N.wireframe === !0;
      (l.geometry !== z.id || l.program !== K.id || l.wireframe !== $) &&
        ((l.geometry = z.id), (l.program = K.id), (l.wireframe = $), (J = !0));
    }
    j !== null && t.update(j, r.ELEMENT_ARRAY_BUFFER),
      (J || h) &&
        ((h = !1),
        C(F, N, K, z),
        j !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(j).buffer));
  }
  function u() {
    return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
  }
  function p(F) {
    return n.isWebGL2 ? r.bindVertexArray(F) : s.bindVertexArrayOES(F);
  }
  function _(F) {
    return n.isWebGL2 ? r.deleteVertexArray(F) : s.deleteVertexArrayOES(F);
  }
  function g(F, N, K) {
    const z = K.wireframe === !0;
    let j = a[F.id];
    j === void 0 && ((j = {}), (a[F.id] = j));
    let J = j[N.id];
    J === void 0 && ((J = {}), (j[N.id] = J));
    let $ = J[z];
    return $ === void 0 && (($ = d(u())), (J[z] = $)), $;
  }
  function d(F) {
    const N = [],
      K = [],
      z = [];
    for (let j = 0; j < i; j++) (N[j] = 0), (K[j] = 0), (z[j] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: N,
      enabledAttributes: K,
      attributeDivisors: z,
      object: F,
      attributes: {},
      index: null
    };
  }
  function m(F, N, K, z) {
    const j = l.attributes,
      J = N.attributes;
    let $ = 0;
    const k = K.getAttributes();
    for (const V in k)
      if (k[V].location >= 0) {
        const re = j[V];
        let le = J[V];
        if (
          (le === void 0 &&
            (V === 'instanceMatrix' &&
              F.instanceMatrix &&
              (le = F.instanceMatrix),
            V === 'instanceColor' && F.instanceColor && (le = F.instanceColor)),
          re === void 0 || re.attribute !== le || (le && re.data !== le.data))
        )
          return !0;
        $++;
      }
    return l.attributesNum !== $ || l.index !== z;
  }
  function y(F, N, K, z) {
    const j = {},
      J = N.attributes;
    let $ = 0;
    const k = K.getAttributes();
    for (const V in k)
      if (k[V].location >= 0) {
        let re = J[V];
        re === void 0 &&
          (V === 'instanceMatrix' &&
            F.instanceMatrix &&
            (re = F.instanceMatrix),
          V === 'instanceColor' && F.instanceColor && (re = F.instanceColor));
        const le = {};
        (le.attribute = re),
          re && re.data && (le.data = re.data),
          (j[V] = le),
          $++;
      }
    (l.attributes = j), (l.attributesNum = $), (l.index = z);
  }
  function v() {
    const F = l.newAttributes;
    for (let N = 0, K = F.length; N < K; N++) F[N] = 0;
  }
  function x(F) {
    S(F, 0);
  }
  function S(F, N) {
    const K = l.newAttributes,
      z = l.enabledAttributes,
      j = l.attributeDivisors;
    (K[F] = 1),
      z[F] === 0 && (r.enableVertexAttribArray(F), (z[F] = 1)),
      j[F] !== N &&
        ((n.isWebGL2 ? r : e.get('ANGLE_instanced_arrays'))[
          n.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
        ](F, N),
        (j[F] = N));
  }
  function b() {
    const F = l.newAttributes,
      N = l.enabledAttributes;
    for (let K = 0, z = N.length; K < z; K++)
      N[K] !== F[K] && (r.disableVertexAttribArray(K), (N[K] = 0));
  }
  function T(F, N, K, z, j, J, $) {
    $ === !0
      ? r.vertexAttribIPointer(F, N, K, j, J)
      : r.vertexAttribPointer(F, N, K, z, j, J);
  }
  function C(F, N, K, z) {
    if (
      n.isWebGL2 === !1 &&
      (F.isInstancedMesh || z.isInstancedBufferGeometry) &&
      e.get('ANGLE_instanced_arrays') === null
    )
      return;
    v();
    const j = z.attributes,
      J = K.getAttributes(),
      $ = N.defaultAttributeValues;
    for (const k in J) {
      const V = J[k];
      if (V.location >= 0) {
        let oe = j[k];
        if (
          (oe === void 0 &&
            (k === 'instanceMatrix' &&
              F.instanceMatrix &&
              (oe = F.instanceMatrix),
            k === 'instanceColor' && F.instanceColor && (oe = F.instanceColor)),
          oe !== void 0)
        ) {
          const re = oe.normalized,
            le = oe.itemSize,
            ve = t.get(oe);
          if (ve === void 0) continue;
          const Ae = ve.buffer,
            ye = ve.type,
            Xe = ve.bytesPerElement,
            qt =
              n.isWebGL2 === !0 &&
              (ye === r.INT || ye === r.UNSIGNED_INT || oe.gpuType === up);
          if (oe.isInterleavedBufferAttribute) {
            const De = oe.data,
              O = De.stride,
              Pt = oe.offset;
            if (De.isInstancedInterleavedBuffer) {
              for (let xe = 0; xe < V.locationSize; xe++)
                S(V.location + xe, De.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                z._maxInstanceCount === void 0 &&
                (z._maxInstanceCount = De.meshPerAttribute * De.count);
            } else
              for (let xe = 0; xe < V.locationSize; xe++) x(V.location + xe);
            r.bindBuffer(r.ARRAY_BUFFER, Ae);
            for (let xe = 0; xe < V.locationSize; xe++)
              T(
                V.location + xe,
                le / V.locationSize,
                ye,
                re,
                O * Xe,
                (Pt + (le / V.locationSize) * xe) * Xe,
                qt
              );
          } else {
            if (oe.isInstancedBufferAttribute) {
              for (let De = 0; De < V.locationSize; De++)
                S(V.location + De, oe.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                z._maxInstanceCount === void 0 &&
                (z._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let De = 0; De < V.locationSize; De++) x(V.location + De);
            r.bindBuffer(r.ARRAY_BUFFER, Ae);
            for (let De = 0; De < V.locationSize; De++)
              T(
                V.location + De,
                le / V.locationSize,
                ye,
                re,
                le * Xe,
                (le / V.locationSize) * De * Xe,
                qt
              );
          }
        } else if ($ !== void 0) {
          const re = $[k];
          if (re !== void 0)
            switch (re.length) {
              case 2:
                r.vertexAttrib2fv(V.location, re);
                break;
              case 3:
                r.vertexAttrib3fv(V.location, re);
                break;
              case 4:
                r.vertexAttrib4fv(V.location, re);
                break;
              default:
                r.vertexAttrib1fv(V.location, re);
            }
        }
      }
    }
    b();
  }
  function M() {
    Y();
    for (const F in a) {
      const N = a[F];
      for (const K in N) {
        const z = N[K];
        for (const j in z) _(z[j].object), delete z[j];
        delete N[K];
      }
      delete a[F];
    }
  }
  function A(F) {
    if (a[F.id] === void 0) return;
    const N = a[F.id];
    for (const K in N) {
      const z = N[K];
      for (const j in z) _(z[j].object), delete z[j];
      delete N[K];
    }
    delete a[F.id];
  }
  function X(F) {
    for (const N in a) {
      const K = a[N];
      if (K[F.id] === void 0) continue;
      const z = K[F.id];
      for (const j in z) _(z[j].object), delete z[j];
      delete K[F.id];
    }
  }
  function Y() {
    D(), (h = !0), l !== c && ((l = c), p(l.object));
  }
  function D() {
    (c.geometry = null), (c.program = null), (c.wireframe = !1);
  }
  return {
    setup: f,
    reset: Y,
    resetDefaultState: D,
    dispose: M,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: X,
    initAttributes: v,
    enableAttribute: x,
    disableUnusedAttributes: b
  };
}
function OM(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function o(l) {
    s = l;
  }
  function a(l, h) {
    r.drawArrays(s, l, h), t.update(h, s, 1);
  }
  function c(l, h, f) {
    if (f === 0) return;
    let u, p;
    if (i) (u = r), (p = 'drawArraysInstanced');
    else if (
      ((u = e.get('ANGLE_instanced_arrays')),
      (p = 'drawArraysInstancedANGLE'),
      u === null)
    ) {
      console.error(
        'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
      );
      return;
    }
    u[p](s, l, h, f), t.update(h, s, f);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = c);
}
function UM(r, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const T = e.get('EXT_texture_filter_anisotropic');
      n = r.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function s(T) {
    if (T === 'highp') {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision >
          0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision >
          0
      )
        return 'highp';
      T = 'mediump';
    }
    return T === 'mediump' &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision >
        0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision >
        0
      ? 'mediump'
      : 'lowp';
  }
  const o =
    typeof WebGL2RenderingContext < 'u' &&
    r.constructor.name === 'WebGL2RenderingContext';
  let a = t.precision !== void 0 ? t.precision : 'highp';
  const c = s(a);
  c !== a &&
    (console.warn(
      'THREE.WebGLRenderer:',
      a,
      'not supported, using',
      c,
      'instead.'
    ),
    (a = c));
  const l = o || e.has('WEBGL_draw_buffers'),
    h = t.logarithmicDepthBuffer === !0,
    f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    u = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = r.getParameter(r.MAX_TEXTURE_SIZE),
    _ = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    g = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    d = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    m = r.getParameter(r.MAX_VARYING_VECTORS),
    y = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    v = u > 0,
    x = o || e.has('OES_texture_float'),
    S = v && x,
    b = o ? r.getParameter(r.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: l,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: f,
    maxVertexTextures: u,
    maxTextureSize: p,
    maxCubemapSize: _,
    maxAttributes: g,
    maxVertexUniforms: d,
    maxVaryings: m,
    maxFragmentUniforms: y,
    vertexTextures: v,
    floatFragmentTextures: x,
    floatVertexTextures: S,
    maxSamples: b
  };
}
function NM(r) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    s = !1;
  const o = new Zi(),
    a = new Oe(),
    c = { value: null, needsUpdate: !1 };
  (this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (f, u) {
      const p = f.length !== 0 || u || n !== 0 || i;
      return (i = u), (n = f.length), p;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (f, u) {
      t = h(f, u, 0);
    }),
    (this.setState = function (f, u, p) {
      const _ = f.clippingPlanes,
        g = f.clipIntersection,
        d = f.clipShadows,
        m = r.get(f);
      if (!i || _ === null || _.length === 0 || (s && !d)) s ? h(null) : l();
      else {
        const y = s ? 0 : n,
          v = y * 4;
        let x = m.clippingState || null;
        (c.value = x), (x = h(_, u, v, p));
        for (let S = 0; S !== v; ++S) x[S] = t[S];
        (m.clippingState = x),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function l() {
    c.value !== t && ((c.value = t), (c.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function h(f, u, p, _) {
    const g = f !== null ? f.length : 0;
    let d = null;
    if (g !== 0) {
      if (((d = c.value), _ !== !0 || d === null)) {
        const m = p + g * 4,
          y = u.matrixWorldInverse;
        a.getNormalMatrix(y),
          (d === null || d.length < m) && (d = new Float32Array(m));
        for (let v = 0, x = p; v !== g; ++v, x += 4)
          o.copy(f[v]).applyMatrix4(y, a),
            o.normal.toArray(d, x),
            (d[x + 3] = o.constant);
      }
      (c.value = d), (c.needsUpdate = !0);
    }
    return (e.numPlanes = g), (e.numIntersection = 0), d;
  }
}
function FM(r) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Qc ? (o.mapping = os) : a === el && (o.mapping = as), o;
  }
  function n(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === Qc || a === el)
        if (e.has(o)) {
          const c = e.get(o).texture;
          return t(c, o.mapping);
        } else {
          const c = o.image;
          if (c && c.height > 0) {
            const l = new Zv(c.height / 2);
            return (
              l.fromEquirectangularTexture(r, o),
              e.set(o, l),
              o.addEventListener('dispose', i),
              t(l.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener('dispose', i);
    const c = e.get(a);
    c !== void 0 && (e.delete(a), c.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
class Xl extends Lp {
  constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = n - e,
      o = n + e,
      a = i + t,
      c = i - t;
    if (this.view !== null && this.view.enabled) {
      const l = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += l * this.view.offsetX),
        (o = s + l * this.view.width),
        (a -= h * this.view.offsetY),
        (c = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      c,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const jr = 4,
  ku = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Qi = 20,
  dc = new Xl(),
  Bu = new Re();
let pc = null;
const Ji = (1 + Math.sqrt(5)) / 2,
  kr = 1 / Ji,
  zu = [
    new P(1, 1, 1),
    new P(-1, 1, 1),
    new P(1, 1, -1),
    new P(-1, 1, -1),
    new P(0, Ji, kr),
    new P(0, Ji, -kr),
    new P(kr, 0, Ji),
    new P(-kr, 0, Ji),
    new P(Ji, kr, 0),
    new P(-Ji, kr, 0)
  ];
class Hu {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (pc = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Wu()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Vu()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(pc),
      (e.scissorTest = !1),
      Fo(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === os || e.mapping === as
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (pc = this._renderer.getRenderTarget());
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: jt,
        minFilter: jt,
        generateMipmaps: !1,
        type: Qs,
        format: yn,
        colorSpace: _t,
        depthBuffer: !1
      },
      i = Gu(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Gu(e, t, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas
      } = kM(s)),
        (this._blurMaterial = BM(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new bn(this._lodPlanes[0], e);
    this._renderer.compile(t, dc);
  }
  _sceneToCubeUV(e, t, n, i) {
    const a = new Wt(90, 1, t, n),
      c = [1, -1, 1, 1, 1, 1],
      l = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      f = h.autoClear,
      u = h.toneMapping;
    h.getClearColor(Bu), (h.toneMapping = Ii), (h.autoClear = !1);
    const p = new rr({
        name: 'PMREM.Background',
        side: Jt,
        depthWrite: !1,
        depthTest: !1
      }),
      _ = new bn(new io(), p);
    let g = !1;
    const d = e.background;
    d
      ? d.isColor && (p.color.copy(d), (e.background = null), (g = !0))
      : (p.color.copy(Bu), (g = !0));
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0
        ? (a.up.set(0, c[m], 0), a.lookAt(l[m], 0, 0))
        : y === 1
        ? (a.up.set(0, 0, c[m]), a.lookAt(0, l[m], 0))
        : (a.up.set(0, c[m], 0), a.lookAt(0, 0, l[m]));
      const v = this._cubeSize;
      Fo(i, y * v, m > 2 ? v : 0, v, v),
        h.setRenderTarget(i),
        g && h.render(_, a),
        h.render(e, a);
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (h.toneMapping = u),
      (h.autoClear = f),
      (e.background = d);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === os || e.mapping === as;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Wu()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Vu());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new bn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const c = this._cubeSize;
    Fo(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(o, dc);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        o = zu[(i - 1) % zu.length];
      this._blur(e, i - 1, i, s, o);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, n, i, 'latitudinal', s),
      this._halfBlur(o, e, n, n, i, 'longitudinal', s);
  }
  _halfBlur(e, t, n, i, s, o, a) {
    const c = this._renderer,
      l = this._blurMaterial;
    o !== 'latitudinal' &&
      o !== 'longitudinal' &&
      console.error(
        'blur direction must be either latitudinal or longitudinal!'
      );
    const h = 3,
      f = new bn(this._lodPlanes[i], l),
      u = l.uniforms,
      p = this._sizeLods[n] - 1,
      _ = isFinite(s) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * Qi - 1),
      g = s / _,
      d = isFinite(s) ? 1 + Math.floor(h * g) : Qi;
    d > Qi &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${d} samples when the maximum is set to ${Qi}`
      );
    const m = [];
    let y = 0;
    for (let T = 0; T < Qi; ++T) {
      const C = T / g,
        M = Math.exp((-C * C) / 2);
      m.push(M), T === 0 ? (y += M) : T < d && (y += 2 * M);
    }
    for (let T = 0; T < m.length; T++) m[T] = m[T] / y;
    (u.envMap.value = e.texture),
      (u.samples.value = d),
      (u.weights.value = m),
      (u.latitudinal.value = o === 'latitudinal'),
      a && (u.poleAxis.value = a);
    const { _lodMax: v } = this;
    (u.dTheta.value = _), (u.mipInt.value = v - n);
    const x = this._sizeLods[i],
      S = 3 * x * (i > v - jr ? i - v + jr : 0),
      b = 4 * (this._cubeSize - x);
    Fo(t, S, b, 3 * x, 2 * x), c.setRenderTarget(t), c.render(f, dc);
  }
}
function kM(r) {
  const e = [],
    t = [],
    n = [];
  let i = r;
  const s = r - jr + 1 + ku.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let c = 1 / a;
    o > r - jr ? (c = ku[o - r + jr - 1]) : o === 0 && (c = 0), n.push(c);
    const l = 1 / (a - 2),
      h = -l,
      f = 1 + l,
      u = [h, h, f, h, f, f, h, h, f, f, h, f],
      p = 6,
      _ = 6,
      g = 3,
      d = 2,
      m = 1,
      y = new Float32Array(g * _ * p),
      v = new Float32Array(d * _ * p),
      x = new Float32Array(m * _ * p);
    for (let b = 0; b < p; b++) {
      const T = ((b % 3) * 2) / 3 - 1,
        C = b > 2 ? 0 : -1,
        M = [
          T,
          C,
          0,
          T + 2 / 3,
          C,
          0,
          T + 2 / 3,
          C + 1,
          0,
          T,
          C,
          0,
          T + 2 / 3,
          C + 1,
          0,
          T,
          C + 1,
          0
        ];
      y.set(M, g * _ * b), v.set(u, d * _ * b);
      const A = [b, b, b, b, b, b];
      x.set(A, m * _ * b);
    }
    const S = new Dn();
    S.setAttribute('position', new Lt(y, g)),
      S.setAttribute('uv', new Lt(v, d)),
      S.setAttribute('faceIndex', new Lt(x, m)),
      e.push(S),
      i > jr && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Gu(r, e, t) {
  const n = new _r(r, e, t);
  return (
    (n.texture.mapping = va),
    (n.texture.name = 'PMREM.cubeUv'),
    (n.scissorTest = !0),
    n
  );
}
function Fo(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function BM(r, e, t) {
  const n = new Float32Array(Qi),
    i = new P(0, 1, 0);
  return new vr({
    name: 'SphericalGaussianBlur',
    defines: {
      n: Qi,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Di,
    depthTest: !1,
    depthWrite: !1
  });
}
function Vu() {
  return new vr({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Di,
    depthTest: !1,
    depthWrite: !1
  });
}
function Wu() {
  return new vr({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Di,
    depthTest: !1,
    depthWrite: !1
  });
}
function jl() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function zM(r) {
  let e = new WeakMap(),
    t = null;
  function n(a) {
    if (a && a.isTexture) {
      const c = a.mapping,
        l = c === Qc || c === el,
        h = c === os || c === as;
      if (l || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let f = e.get(a);
          return (
            t === null && (t = new Hu(r)),
            (f = l ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f)),
            e.set(a, f),
            f.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const f = a.image;
            if ((l && f && f.height > 0) || (h && f && i(f))) {
              t === null && (t = new Hu(r));
              const u = l ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, u), a.addEventListener('dispose', s), u.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function i(a) {
    let c = 0;
    const l = 6;
    for (let h = 0; h < l; h++) a[h] !== void 0 && c++;
    return c === l;
  }
  function s(a) {
    const c = a.target;
    c.removeEventListener('dispose', s);
    const l = e.get(c);
    l !== void 0 && (e.delete(c), l.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: o };
}
function HM(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case 'WEBGL_depth_texture':
        i =
          r.getExtension('WEBGL_depth_texture') ||
          r.getExtension('MOZ_WEBGL_depth_texture') ||
          r.getExtension('WEBKIT_WEBGL_depth_texture');
        break;
      case 'EXT_texture_filter_anisotropic':
        i =
          r.getExtension('EXT_texture_filter_anisotropic') ||
          r.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          r.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;
      case 'WEBGL_compressed_texture_s3tc':
        i =
          r.getExtension('WEBGL_compressed_texture_s3tc') ||
          r.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;
      case 'WEBGL_compressed_texture_pvrtc':
        i =
          r.getExtension('WEBGL_compressed_texture_pvrtc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;
      default:
        i = r.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? t('EXT_color_buffer_float')
        : (t('WEBGL_depth_texture'),
          t('OES_texture_float'),
          t('OES_texture_half_float'),
          t('OES_texture_half_float_linear'),
          t('OES_standard_derivatives'),
          t('OES_element_index_uint'),
          t('OES_vertex_array_object'),
          t('ANGLE_instanced_arrays')),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture');
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          console.warn(
            'THREE.WebGLRenderer: ' + n + ' extension not supported.'
          ),
        i
      );
    }
  };
}
function GM(r, e, t, n) {
  const i = {},
    s = new WeakMap();
  function o(f) {
    const u = f.target;
    u.index !== null && e.remove(u.index);
    for (const _ in u.attributes) e.remove(u.attributes[_]);
    for (const _ in u.morphAttributes) {
      const g = u.morphAttributes[_];
      for (let d = 0, m = g.length; d < m; d++) e.remove(g[d]);
    }
    u.removeEventListener('dispose', o), delete i[u.id];
    const p = s.get(u);
    p && (e.remove(p), s.delete(u)),
      n.releaseStatesOfGeometry(u),
      u.isInstancedBufferGeometry === !0 && delete u._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(f, u) {
    return (
      i[u.id] === !0 ||
        (u.addEventListener('dispose', o),
        (i[u.id] = !0),
        t.memory.geometries++),
      u
    );
  }
  function c(f) {
    const u = f.attributes;
    for (const _ in u) e.update(u[_], r.ARRAY_BUFFER);
    const p = f.morphAttributes;
    for (const _ in p) {
      const g = p[_];
      for (let d = 0, m = g.length; d < m; d++) e.update(g[d], r.ARRAY_BUFFER);
    }
  }
  function l(f) {
    const u = [],
      p = f.index,
      _ = f.attributes.position;
    let g = 0;
    if (p !== null) {
      const y = p.array;
      g = p.version;
      for (let v = 0, x = y.length; v < x; v += 3) {
        const S = y[v + 0],
          b = y[v + 1],
          T = y[v + 2];
        u.push(S, b, b, T, T, S);
      }
    } else if (_ !== void 0) {
      const y = _.array;
      g = _.version;
      for (let v = 0, x = y.length / 3 - 1; v < x; v += 3) {
        const S = v + 0,
          b = v + 1,
          T = v + 2;
        u.push(S, b, b, T, T, S);
      }
    } else return;
    const d = new (Mp(u) ? Rp : wp)(u, 1);
    d.version = g;
    const m = s.get(f);
    m && e.remove(m), s.set(f, d);
  }
  function h(f) {
    const u = s.get(f);
    if (u) {
      const p = f.index;
      p !== null && u.version < p.version && l(f);
    } else l(f);
    return s.get(f);
  }
  return { get: a, update: c, getWireframeAttribute: h };
}
function VM(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function o(u) {
    s = u;
  }
  let a, c;
  function l(u) {
    (a = u.type), (c = u.bytesPerElement);
  }
  function h(u, p) {
    r.drawElements(s, p, a, u * c), t.update(p, s, 1);
  }
  function f(u, p, _) {
    if (_ === 0) return;
    let g, d;
    if (i) (g = r), (d = 'drawElementsInstanced');
    else if (
      ((g = e.get('ANGLE_instanced_arrays')),
      (d = 'drawElementsInstancedANGLE'),
      g === null)
    ) {
      console.error(
        'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
      );
      return;
    }
    g[d](s, p, a, u * c, _), t.update(p, s, _);
  }
  (this.setMode = o),
    (this.setIndex = l),
    (this.render = h),
    (this.renderInstances = f);
}
function WM(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, o, a) {
    switch ((t.calls++, o)) {
      case r.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case r.LINES:
        t.lines += a * (s / 2);
        break;
      case r.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case r.LINE_LOOP:
        t.lines += a * s;
        break;
      case r.POINTS:
        t.points += a * s;
        break;
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', o);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function qM(r, e) {
  return r[0] - e[0];
}
function XM(r, e) {
  return Math.abs(e[1]) - Math.abs(r[1]);
}
function jM(r, e, t) {
  const n = {},
    i = new Float32Array(8),
    s = new WeakMap(),
    o = new Je(),
    a = [];
  for (let l = 0; l < 8; l++) a[l] = [l, 0];
  function c(l, h, f) {
    const u = l.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const _ =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        g = _ !== void 0 ? _.length : 0;
      let d = s.get(h);
      if (d === void 0 || d.count !== g) {
        let N = function () {
          D.dispose(), s.delete(h), h.removeEventListener('dispose', N);
        };
        var p = N;
        d !== void 0 && d.texture.dispose();
        const v = h.morphAttributes.position !== void 0,
          x = h.morphAttributes.normal !== void 0,
          S = h.morphAttributes.color !== void 0,
          b = h.morphAttributes.position || [],
          T = h.morphAttributes.normal || [],
          C = h.morphAttributes.color || [];
        let M = 0;
        v === !0 && (M = 1), x === !0 && (M = 2), S === !0 && (M = 3);
        let A = h.attributes.position.count * M,
          X = 1;
        A > e.maxTextureSize &&
          ((X = Math.ceil(A / e.maxTextureSize)), (A = e.maxTextureSize));
        const Y = new Float32Array(A * X * 4 * g),
          D = new Ep(Y, A, X, g);
        (D.type = oi), (D.needsUpdate = !0);
        const F = M * 4;
        for (let K = 0; K < g; K++) {
          const z = b[K],
            j = T[K],
            J = C[K],
            $ = A * X * 4 * K;
          for (let k = 0; k < z.count; k++) {
            const V = k * F;
            v === !0 &&
              (o.fromBufferAttribute(z, k),
              (Y[$ + V + 0] = o.x),
              (Y[$ + V + 1] = o.y),
              (Y[$ + V + 2] = o.z),
              (Y[$ + V + 3] = 0)),
              x === !0 &&
                (o.fromBufferAttribute(j, k),
                (Y[$ + V + 4] = o.x),
                (Y[$ + V + 5] = o.y),
                (Y[$ + V + 6] = o.z),
                (Y[$ + V + 7] = 0)),
              S === !0 &&
                (o.fromBufferAttribute(J, k),
                (Y[$ + V + 8] = o.x),
                (Y[$ + V + 9] = o.y),
                (Y[$ + V + 10] = o.z),
                (Y[$ + V + 11] = J.itemSize === 4 ? o.w : 1));
          }
        }
        (d = { count: g, texture: D, size: new Ve(A, X) }),
          s.set(h, d),
          h.addEventListener('dispose', N);
      }
      let m = 0;
      for (let v = 0; v < u.length; v++) m += u[v];
      const y = h.morphTargetsRelative ? 1 : 1 - m;
      f.getUniforms().setValue(r, 'morphTargetBaseInfluence', y),
        f.getUniforms().setValue(r, 'morphTargetInfluences', u),
        f.getUniforms().setValue(r, 'morphTargetsTexture', d.texture, t),
        f.getUniforms().setValue(r, 'morphTargetsTextureSize', d.size);
    } else {
      const _ = u === void 0 ? 0 : u.length;
      let g = n[h.id];
      if (g === void 0 || g.length !== _) {
        g = [];
        for (let x = 0; x < _; x++) g[x] = [x, 0];
        n[h.id] = g;
      }
      for (let x = 0; x < _; x++) {
        const S = g[x];
        (S[0] = x), (S[1] = u[x]);
      }
      g.sort(XM);
      for (let x = 0; x < 8; x++)
        x < _ && g[x][1]
          ? ((a[x][0] = g[x][0]), (a[x][1] = g[x][1]))
          : ((a[x][0] = Number.MAX_SAFE_INTEGER), (a[x][1] = 0));
      a.sort(qM);
      const d = h.morphAttributes.position,
        m = h.morphAttributes.normal;
      let y = 0;
      for (let x = 0; x < 8; x++) {
        const S = a[x],
          b = S[0],
          T = S[1];
        b !== Number.MAX_SAFE_INTEGER && T
          ? (d &&
              h.getAttribute('morphTarget' + x) !== d[b] &&
              h.setAttribute('morphTarget' + x, d[b]),
            m &&
              h.getAttribute('morphNormal' + x) !== m[b] &&
              h.setAttribute('morphNormal' + x, m[b]),
            (i[x] = T),
            (y += T))
          : (d &&
              h.hasAttribute('morphTarget' + x) === !0 &&
              h.deleteAttribute('morphTarget' + x),
            m &&
              h.hasAttribute('morphNormal' + x) === !0 &&
              h.deleteAttribute('morphNormal' + x),
            (i[x] = 0));
      }
      const v = h.morphTargetsRelative ? 1 : 1 - y;
      f.getUniforms().setValue(r, 'morphTargetBaseInfluence', v),
        f.getUniforms().setValue(r, 'morphTargetInfluences', i);
    }
  }
  return { update: c };
}
function YM(r, e, t, n) {
  let i = new WeakMap();
  function s(c) {
    const l = n.render.frame,
      h = c.geometry,
      f = e.get(c, h);
    if (
      (i.get(f) !== l && (e.update(f), i.set(f, l)),
      c.isInstancedMesh &&
        (c.hasEventListener('dispose', a) === !1 &&
          c.addEventListener('dispose', a),
        i.get(c) !== l &&
          (t.update(c.instanceMatrix, r.ARRAY_BUFFER),
          c.instanceColor !== null && t.update(c.instanceColor, r.ARRAY_BUFFER),
          i.set(c, l))),
      c.isSkinnedMesh)
    ) {
      const u = c.skeleton;
      i.get(u) !== l && (u.update(), i.set(u, l));
    }
    return f;
  }
  function o() {
    i = new WeakMap();
  }
  function a(c) {
    const l = c.target;
    l.removeEventListener('dispose', a),
      t.remove(l.instanceMatrix),
      l.instanceColor !== null && t.remove(l.instanceColor);
  }
  return { update: s, dispose: o };
}
const Ip = new Ct(),
  Op = new Ep(),
  Up = new Ov(),
  Np = new Pp(),
  qu = [],
  Xu = [],
  ju = new Float32Array(16),
  Yu = new Float32Array(9),
  Ku = new Float32Array(4);
function vs(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let s = qu[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (qu[i] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), r[o].toArray(s, a);
  }
  return s;
}
function yt(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function xt(r, e) {
  for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function Sa(r, e) {
  let t = Xu[e];
  t === void 0 && ((t = new Int32Array(e)), (Xu[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
  return t;
}
function KM(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function $M(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (yt(t, e)) return;
    r.uniform2fv(this.addr, e), xt(t, e);
  }
}
function ZM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (yt(t, e)) return;
    r.uniform3fv(this.addr, e), xt(t, e);
  }
}
function JM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (yt(t, e)) return;
    r.uniform4fv(this.addr, e), xt(t, e);
  }
}
function QM(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (yt(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), xt(t, e);
  } else {
    if (yt(t, n)) return;
    Ku.set(n), r.uniformMatrix2fv(this.addr, !1, Ku), xt(t, n);
  }
}
function eS(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (yt(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), xt(t, e);
  } else {
    if (yt(t, n)) return;
    Yu.set(n), r.uniformMatrix3fv(this.addr, !1, Yu), xt(t, n);
  }
}
function tS(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (yt(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), xt(t, e);
  } else {
    if (yt(t, n)) return;
    ju.set(n), r.uniformMatrix4fv(this.addr, !1, ju), xt(t, n);
  }
}
function nS(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function iS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (yt(t, e)) return;
    r.uniform2iv(this.addr, e), xt(t, e);
  }
}
function rS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (yt(t, e)) return;
    r.uniform3iv(this.addr, e), xt(t, e);
  }
}
function sS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (yt(t, e)) return;
    r.uniform4iv(this.addr, e), xt(t, e);
  }
}
function oS(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function aS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (yt(t, e)) return;
    r.uniform2uiv(this.addr, e), xt(t, e);
  }
}
function cS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (yt(t, e)) return;
    r.uniform3uiv(this.addr, e), xt(t, e);
  }
}
function lS(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (yt(t, e)) return;
    r.uniform4uiv(this.addr, e), xt(t, e);
  }
}
function hS(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2D(e || Ip, i);
}
function uS(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || Up, i);
}
function fS(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || Np, i);
}
function dS(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || Op, i);
}
function pS(r) {
  switch (r) {
    case 5126:
      return KM;
    case 35664:
      return $M;
    case 35665:
      return ZM;
    case 35666:
      return JM;
    case 35674:
      return QM;
    case 35675:
      return eS;
    case 35676:
      return tS;
    case 5124:
    case 35670:
      return nS;
    case 35667:
    case 35671:
      return iS;
    case 35668:
    case 35672:
      return rS;
    case 35669:
    case 35673:
      return sS;
    case 5125:
      return oS;
    case 36294:
      return aS;
    case 36295:
      return cS;
    case 36296:
      return lS;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return hS;
    case 35679:
    case 36299:
    case 36307:
      return uS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return fS;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return dS;
  }
}
function mS(r, e) {
  r.uniform1fv(this.addr, e);
}
function gS(r, e) {
  const t = vs(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function _S(r, e) {
  const t = vs(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function vS(r, e) {
  const t = vs(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function yS(r, e) {
  const t = vs(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function xS(r, e) {
  const t = vs(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function MS(r, e) {
  const t = vs(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function SS(r, e) {
  r.uniform1iv(this.addr, e);
}
function bS(r, e) {
  r.uniform2iv(this.addr, e);
}
function ES(r, e) {
  r.uniform3iv(this.addr, e);
}
function TS(r, e) {
  r.uniform4iv(this.addr, e);
}
function AS(r, e) {
  r.uniform1uiv(this.addr, e);
}
function wS(r, e) {
  r.uniform2uiv(this.addr, e);
}
function RS(r, e) {
  r.uniform3uiv(this.addr, e);
}
function CS(r, e) {
  r.uniform4uiv(this.addr, e);
}
function LS(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = Sa(t, i);
  yt(n, s) || (r.uniform1iv(this.addr, s), xt(n, s));
  for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || Ip, s[o]);
}
function PS(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = Sa(t, i);
  yt(n, s) || (r.uniform1iv(this.addr, s), xt(n, s));
  for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || Up, s[o]);
}
function DS(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = Sa(t, i);
  yt(n, s) || (r.uniform1iv(this.addr, s), xt(n, s));
  for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || Np, s[o]);
}
function IS(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = Sa(t, i);
  yt(n, s) || (r.uniform1iv(this.addr, s), xt(n, s));
  for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || Op, s[o]);
}
function OS(r) {
  switch (r) {
    case 5126:
      return mS;
    case 35664:
      return gS;
    case 35665:
      return _S;
    case 35666:
      return vS;
    case 35674:
      return yS;
    case 35675:
      return xS;
    case 35676:
      return MS;
    case 5124:
    case 35670:
      return SS;
    case 35667:
    case 35671:
      return bS;
    case 35668:
    case 35672:
      return ES;
    case 35669:
    case 35673:
      return TS;
    case 5125:
      return AS;
    case 36294:
      return wS;
    case 36295:
      return RS;
    case 36296:
      return CS;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return LS;
    case 35679:
    case 36299:
    case 36307:
      return PS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return DS;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return IS;
  }
}
class US {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = pS(t.type));
  }
}
class NS {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = OS(t.type));
  }
}
class FS {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const a = i[s];
      a.setValue(e, t[a.id], n);
    }
  }
}
const mc = /(\w+)(\])?(\[|\.)?/g;
function $u(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function kS(r, e, t) {
  const n = r.name,
    i = n.length;
  for (mc.lastIndex = 0; ; ) {
    const s = mc.exec(n),
      o = mc.lastIndex;
    let a = s[1];
    const c = s[2] === ']',
      l = s[3];
    if ((c && (a = a | 0), l === void 0 || (l === '[' && o + 2 === i))) {
      $u(t, l === void 0 ? new US(a, r, e) : new NS(a, r, e));
      break;
    } else {
      let f = t.map[a];
      f === void 0 && ((f = new FS(a)), $u(t, f)), (t = f);
    }
  }
}
class Jo {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const s = e.getActiveUniform(t, i),
        o = e.getUniformLocation(t, s.name);
      kS(s, o, this);
    }
  }
  setValue(e, t, n, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        c = n[a.id];
      c.needsUpdate !== !1 && a.setValue(e, c.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function Zu(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
let BS = 0;
function zS(r, e) {
  const t = r.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    const a = o + 1;
    n.push(`${a === e ? '>' : ' '} ${a}: ${t[o]}`);
  }
  return n.join(`
`);
}
function HS(r) {
  switch (r) {
    case _t:
      return ['Linear', '( value )'];
    case qe:
      return ['sRGB', '( value )'];
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space:', r),
        ['Linear', '( value )']
      );
  }
}
function Ju(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(e).trim();
  if (n && i === '') return '';
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      zS(r.getShaderSource(e), o)
    );
  } else return i;
}
function GS(r, e) {
  const t = HS(e);
  return 'vec4 ' + r + '( vec4 value ) { return LinearTo' + t[0] + t[1] + '; }';
}
function VS(r, e) {
  let t;
  switch (e) {
    case N0:
      t = 'Linear';
      break;
    case F0:
      t = 'Reinhard';
      break;
    case k0:
      t = 'OptimizedCineon';
      break;
    case B0:
      t = 'ACESFilmic';
      break;
    case z0:
      t = 'Custom';
      break;
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
        (t = 'Linear');
  }
  return (
    'vec3 ' + r + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
  );
}
function WS(r) {
  return [
    r.extensionDerivatives ||
    r.envMapCubeUVHeight ||
    r.bumpMap ||
    r.normalMapTangentSpace ||
    r.clearcoatNormalMap ||
    r.flatShading ||
    r.shaderID === 'physical'
      ? '#extension GL_OES_standard_derivatives : enable'
      : '',
    (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
    r.rendererExtensionFragDepth
      ? '#extension GL_EXT_frag_depth : enable'
      : '',
    r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
      ? '#extension GL_EXT_draw_buffers : require'
      : '',
    (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
    r.rendererExtensionShaderTextureLod
      ? '#extension GL_EXT_shader_texture_lod : enable'
      : ''
  ].filter(Fs).join(`
`);
}
function qS(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push('#define ' + t + ' ' + n);
  }
  return e.join(`
`);
}
function XS(r, e) {
  const t = {},
    n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i),
      o = s.name;
    let a = 1;
    s.type === r.FLOAT_MAT2 && (a = 2),
      s.type === r.FLOAT_MAT3 && (a = 3),
      s.type === r.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: r.getAttribLocation(e, o),
        locationSize: a
      });
  }
  return t;
}
function Fs(r) {
  return r !== '';
}
function Qu(r, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function ef(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const jS = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ol(r) {
  return r.replace(jS, KS);
}
const YS = new Map([
  ['encodings_fragment', 'colorspace_fragment'],
  ['encodings_pars_fragment', 'colorspace_pars_fragment'],
  ['output_fragment', 'opaque_fragment']
]);
function KS(r, e) {
  let t = Pe[e];
  if (t === void 0) {
    const n = YS.get(e);
    if (n !== void 0)
      (t = Pe[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n
        );
    else throw new Error('Can not resolve #include <' + e + '>');
  }
  return ol(t);
}
const $S =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function tf(r) {
  return r.replace($S, ZS);
}
function ZS(r, e, t, n) {
  let i = '';
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += n
      .replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function nf(r) {
  let e =
    'precision ' +
    r.precision +
    ` float;
precision ` +
    r.precision +
    ' int;';
  return (
    r.precision === 'highp'
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === 'mediump'
      ? (e += `
#define MEDIUM_PRECISION`)
      : r.precision === 'lowp' &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function JS(r) {
  let e = 'SHADOWMAP_TYPE_BASIC';
  return (
    r.shadowMapType === sp
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : r.shadowMapType === p0
      ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
      : r.shadowMapType === ni && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  );
}
function QS(r) {
  let e = 'ENVMAP_TYPE_CUBE';
  if (r.envMap)
    switch (r.envMapMode) {
      case os:
      case as:
        e = 'ENVMAP_TYPE_CUBE';
        break;
      case va:
        e = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  return e;
}
function eb(r) {
  let e = 'ENVMAP_MODE_REFLECTION';
  if (r.envMap)
    switch (r.envMapMode) {
      case as:
        e = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  return e;
}
function tb(r) {
  let e = 'ENVMAP_BLENDING_NONE';
  if (r.envMap)
    switch (r.combine) {
      case cp:
        e = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case O0:
        e = 'ENVMAP_BLENDING_MIX';
        break;
      case U0:
        e = 'ENVMAP_BLENDING_ADD';
        break;
    }
  return e;
}
function nb(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t
  };
}
function ib(r, e, t, n) {
  const i = r.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const c = JS(t),
    l = QS(t),
    h = eb(t),
    f = tb(t),
    u = nb(t),
    p = t.isWebGL2 ? '' : WS(t),
    _ = qS(s),
    g = i.createProgram();
  let d,
    m,
    y = t.glslVersion
      ? '#version ' +
        t.glslVersion +
        `
`
      : '';
  t.isRawShaderMaterial
    ? ((d = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _
      ].filter(Fs).join(`
`)),
      d.length > 0 &&
        (d += `
`),
      (m = [
        p,
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _
      ].filter(Fs).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((d = [
        nf(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
        t.instancing ? '#define USE_INSTANCING' : '',
        t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + h : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
        t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
        t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
        t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
        t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
        t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
        t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
        t.displacementMapUv
          ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv
          : '',
        t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
        t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
        t.anisotropyMapUv
          ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv
          : '',
        t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
        t.clearcoatNormalMapUv
          ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv
          : '',
        t.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
          : '',
        t.iridescenceMapUv
          ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv
          : '',
        t.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
          : '',
        t.sheenColorMapUv
          ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv
          : '',
        t.sheenRoughnessMapUv
          ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv
          : '',
        t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
        t.specularColorMapUv
          ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv
          : '',
        t.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
          : '',
        t.transmissionMapUv
          ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv
          : '',
        t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.skinning ? '#define USE_SKINNING' : '',
        t.morphTargets ? '#define USE_MORPHTARGETS' : '',
        t.morphNormals && t.flatShading === !1
          ? '#define USE_MORPHNORMALS'
          : '',
        t.morphColors && t.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
        t.morphTargetsCount > 0 && t.isWebGL2
          ? '#define MORPHTARGETS_TEXTURE'
          : '',
        t.morphTargetsCount > 0 && t.isWebGL2
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
          : '',
        t.morphTargetsCount > 0 && t.isWebGL2
          ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
          : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + c : '',
        t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? '#define USE_LOGDEPTHBUF_EXT'
          : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
        '	attribute vec3 morphTarget0;',
        '	attribute vec3 morphTarget1;',
        '	attribute vec3 morphTarget2;',
        '	attribute vec3 morphTarget3;',
        '	#ifdef USE_MORPHNORMALS',
        '		attribute vec3 morphNormal0;',
        '		attribute vec3 morphNormal1;',
        '		attribute vec3 morphNormal2;',
        '		attribute vec3 morphNormal3;',
        '	#else',
        '		attribute vec3 morphTarget4;',
        '		attribute vec3 morphTarget5;',
        '		attribute vec3 morphTarget6;',
        '		attribute vec3 morphTarget7;',
        '	#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`
      ].filter(Fs).join(`
`)),
      (m = [
        p,
        nf(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.matcap ? '#define USE_MATCAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + l : '',
        t.envMap ? '#define ' + h : '',
        t.envMap ? '#define ' + f : '',
        u ? '#define CUBEUV_TEXEL_WIDTH ' + u.texelWidth : '',
        u ? '#define CUBEUV_TEXEL_HEIGHT ' + u.texelHeight : '',
        u ? '#define CUBEUV_MAX_MIP ' + u.maxMip + '.0' : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoat ? '#define USE_CLEARCOAT' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescence ? '#define USE_IRIDESCENCE' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaTest ? '#define USE_ALPHATEST' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.sheen ? '#define USE_SHEEN' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors || t.instancingColor ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.gradientMap ? '#define USE_GRADIENTMAP' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + c : '',
        t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
        t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? '#define USE_LOGDEPTHBUF_EXT'
          : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        t.toneMapping !== Ii ? '#define TONE_MAPPING' : '',
        t.toneMapping !== Ii ? Pe.tonemapping_pars_fragment : '',
        t.toneMapping !== Ii ? VS('toneMapping', t.toneMapping) : '',
        t.dithering ? '#define DITHERING' : '',
        t.opaque ? '#define OPAQUE' : '',
        Pe.colorspace_pars_fragment,
        GS('linearToOutputTexel', t.outputColorSpace),
        t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
        `
`
      ].filter(Fs).join(`
`))),
    (o = ol(o)),
    (o = Qu(o, t)),
    (o = ef(o, t)),
    (a = ol(a)),
    (a = Qu(a, t)),
    (a = ef(a, t)),
    (o = tf(o)),
    (a = tf(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (d =
        [
          'precision mediump sampler2DArray;',
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture'
        ].join(`
`) +
        `
` +
        d),
      (m =
        [
          '#define varying in',
          t.glslVersion === Su
            ? ''
            : 'layout(location = 0) out highp vec4 pc_fragColor;',
          t.glslVersion === Su ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad'
        ].join(`
`) +
        `
` +
        m));
  const v = y + d + o,
    x = y + m + a,
    S = Zu(i, i.VERTEX_SHADER, v),
    b = Zu(i, i.FRAGMENT_SHADER, x);
  if (
    (i.attachShader(g, S),
    i.attachShader(g, b),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(g, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(g, 0, 'position'),
    i.linkProgram(g),
    r.debug.checkShaderErrors)
  ) {
    const M = i.getProgramInfoLog(g).trim(),
      A = i.getShaderInfoLog(S).trim(),
      X = i.getShaderInfoLog(b).trim();
    let Y = !0,
      D = !0;
    if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
      if (((Y = !1), typeof r.debug.onShaderError == 'function'))
        r.debug.onShaderError(i, g, S, b);
      else {
        const F = Ju(i, S, 'vertex'),
          N = Ju(i, b, 'fragment');
        console.error(
          'THREE.WebGLProgram: Shader Error ' +
            i.getError() +
            ' - VALIDATE_STATUS ' +
            i.getProgramParameter(g, i.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            M +
            `
` +
            F +
            `
` +
            N
        );
      }
    else
      M !== ''
        ? console.warn('THREE.WebGLProgram: Program Info Log:', M)
        : (A === '' || X === '') && (D = !1);
    D &&
      (this.diagnostics = {
        runnable: Y,
        programLog: M,
        vertexShader: { log: A, prefix: d },
        fragmentShader: { log: X, prefix: m }
      });
  }
  i.deleteShader(S), i.deleteShader(b);
  let T;
  this.getUniforms = function () {
    return T === void 0 && (T = new Jo(i, g)), T;
  };
  let C;
  return (
    (this.getAttributes = function () {
      return C === void 0 && (C = XS(i, g)), C;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(g),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = BS++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = S),
    (this.fragmentShader = b),
    this
  );
}
let rb = 0;
class sb {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(n),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new ob(e)), t.set(e, n)), n;
  }
}
class ob {
  constructor(e) {
    (this.id = rb++), (this.code = e), (this.usedTimes = 0);
  }
}
function ab(r, e, t, n, i, s, o) {
  const a = new Tp(),
    c = new sb(),
    l = [],
    h = i.isWebGL2,
    f = i.logarithmicDepthBuffer,
    u = i.vertexTextures;
  let p = i.precision;
  const _ = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  function g(M) {
    return M === 0 ? 'uv' : `uv${M}`;
  }
  function d(M, A, X, Y, D) {
    const F = Y.fog,
      N = D.geometry,
      K = M.isMeshStandardMaterial ? Y.environment : null,
      z = (M.isMeshStandardMaterial ? t : e).get(M.envMap || K),
      j = z && z.mapping === va ? z.image.height : null,
      J = _[M.type];
    M.precision !== null &&
      ((p = i.getMaxPrecision(M.precision)),
      p !== M.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          M.precision,
          'not supported, using',
          p,
          'instead.'
        ));
    const $ =
        N.morphAttributes.position ||
        N.morphAttributes.normal ||
        N.morphAttributes.color,
      k = $ !== void 0 ? $.length : 0;
    let V = 0;
    N.morphAttributes.position !== void 0 && (V = 1),
      N.morphAttributes.normal !== void 0 && (V = 2),
      N.morphAttributes.color !== void 0 && (V = 3);
    let oe, re, le, ve;
    if (J) {
      const et = On[J];
      (oe = et.vertexShader), (re = et.fragmentShader);
    } else
      (oe = M.vertexShader),
        (re = M.fragmentShader),
        c.update(M),
        (le = c.getVertexShaderID(M)),
        (ve = c.getFragmentShaderID(M));
    const Ae = r.getRenderTarget(),
      ye = D.isInstancedMesh === !0,
      Xe = !!M.map,
      qt = !!M.matcap,
      De = !!z,
      O = !!M.aoMap,
      Pt = !!M.lightMap,
      xe = !!M.bumpMap,
      Ce = !!M.normalMap,
      Te = !!M.displacementMap,
      tt = !!M.emissiveMap,
      Be = !!M.metalnessMap,
      Ie = !!M.roughnessMap,
      Ke = M.anisotropy > 0,
      At = M.clearcoat > 0,
      Dt = M.iridescence > 0,
      R = M.sheen > 0,
      E = M.transmission > 0,
      B = Ke && !!M.anisotropyMap,
      ee = At && !!M.clearcoatMap,
      Q = At && !!M.clearcoatNormalMap,
      te = At && !!M.clearcoatRoughnessMap,
      de = Dt && !!M.iridescenceMap,
      ne = Dt && !!M.iridescenceThicknessMap,
      G = R && !!M.sheenColorMap,
      ge = R && !!M.sheenRoughnessMap,
      pe = !!M.specularMap,
      me = !!M.specularColorMap,
      ue = !!M.specularIntensityMap,
      fe = E && !!M.transmissionMap,
      Ne = E && !!M.thicknessMap,
      Qe = !!M.gradientMap,
      L = !!M.alphaMap,
      ae = M.alphaTest > 0,
      H = !!M.alphaHash,
      ie = !!M.extensions,
      ce = !!N.attributes.uv1,
      We = !!N.attributes.uv2,
      nt = !!N.attributes.uv3;
    let ut = Ii;
    return (
      M.toneMapped &&
        (Ae === null || Ae.isXRRenderTarget === !0) &&
        (ut = r.toneMapping),
      {
        isWebGL2: h,
        shaderID: J,
        shaderType: M.type,
        shaderName: M.name,
        vertexShader: oe,
        fragmentShader: re,
        defines: M.defines,
        customVertexShaderID: le,
        customFragmentShaderID: ve,
        isRawShaderMaterial: M.isRawShaderMaterial === !0,
        glslVersion: M.glslVersion,
        precision: p,
        instancing: ye,
        instancingColor: ye && D.instanceColor !== null,
        supportsVertexTextures: u,
        outputColorSpace:
          Ae === null
            ? r.outputColorSpace
            : Ae.isXRRenderTarget === !0
            ? Ae.texture.colorSpace
            : _t,
        map: Xe,
        matcap: qt,
        envMap: De,
        envMapMode: De && z.mapping,
        envMapCubeUVHeight: j,
        aoMap: O,
        lightMap: Pt,
        bumpMap: xe,
        normalMap: Ce,
        displacementMap: u && Te,
        emissiveMap: tt,
        normalMapObjectSpace: Ce && M.normalMapType === ev,
        normalMapTangentSpace: Ce && M.normalMapType === yp,
        metalnessMap: Be,
        roughnessMap: Ie,
        anisotropy: Ke,
        anisotropyMap: B,
        clearcoat: At,
        clearcoatMap: ee,
        clearcoatNormalMap: Q,
        clearcoatRoughnessMap: te,
        iridescence: Dt,
        iridescenceMap: de,
        iridescenceThicknessMap: ne,
        sheen: R,
        sheenColorMap: G,
        sheenRoughnessMap: ge,
        specularMap: pe,
        specularColorMap: me,
        specularIntensityMap: ue,
        transmission: E,
        transmissionMap: fe,
        thicknessMap: Ne,
        gradientMap: Qe,
        opaque: M.transparent === !1 && M.blending === Jr,
        alphaMap: L,
        alphaTest: ae,
        alphaHash: H,
        combine: M.combine,
        mapUv: Xe && g(M.map.channel),
        aoMapUv: O && g(M.aoMap.channel),
        lightMapUv: Pt && g(M.lightMap.channel),
        bumpMapUv: xe && g(M.bumpMap.channel),
        normalMapUv: Ce && g(M.normalMap.channel),
        displacementMapUv: Te && g(M.displacementMap.channel),
        emissiveMapUv: tt && g(M.emissiveMap.channel),
        metalnessMapUv: Be && g(M.metalnessMap.channel),
        roughnessMapUv: Ie && g(M.roughnessMap.channel),
        anisotropyMapUv: B && g(M.anisotropyMap.channel),
        clearcoatMapUv: ee && g(M.clearcoatMap.channel),
        clearcoatNormalMapUv: Q && g(M.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: te && g(M.clearcoatRoughnessMap.channel),
        iridescenceMapUv: de && g(M.iridescenceMap.channel),
        iridescenceThicknessMapUv: ne && g(M.iridescenceThicknessMap.channel),
        sheenColorMapUv: G && g(M.sheenColorMap.channel),
        sheenRoughnessMapUv: ge && g(M.sheenRoughnessMap.channel),
        specularMapUv: pe && g(M.specularMap.channel),
        specularColorMapUv: me && g(M.specularColorMap.channel),
        specularIntensityMapUv: ue && g(M.specularIntensityMap.channel),
        transmissionMapUv: fe && g(M.transmissionMap.channel),
        thicknessMapUv: Ne && g(M.thicknessMap.channel),
        alphaMapUv: L && g(M.alphaMap.channel),
        vertexTangents: !!N.attributes.tangent && (Ce || Ke),
        vertexColors: M.vertexColors,
        vertexAlphas:
          M.vertexColors === !0 &&
          !!N.attributes.color &&
          N.attributes.color.itemSize === 4,
        vertexUv1s: ce,
        vertexUv2s: We,
        vertexUv3s: nt,
        pointsUvs: D.isPoints === !0 && !!N.attributes.uv && (Xe || L),
        fog: !!F,
        useFog: M.fog === !0,
        fogExp2: F && F.isFogExp2,
        flatShading: M.flatShading === !0,
        sizeAttenuation: M.sizeAttenuation === !0,
        logarithmicDepthBuffer: f,
        skinning: D.isSkinnedMesh === !0,
        morphTargets: N.morphAttributes.position !== void 0,
        morphNormals: N.morphAttributes.normal !== void 0,
        morphColors: N.morphAttributes.color !== void 0,
        morphTargetsCount: k,
        morphTextureStride: V,
        numDirLights: A.directional.length,
        numPointLights: A.point.length,
        numSpotLights: A.spot.length,
        numSpotLightMaps: A.spotLightMap.length,
        numRectAreaLights: A.rectArea.length,
        numHemiLights: A.hemi.length,
        numDirLightShadows: A.directionalShadowMap.length,
        numPointLightShadows: A.pointShadowMap.length,
        numSpotLightShadows: A.spotShadowMap.length,
        numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: M.dithering,
        shadowMapEnabled: r.shadowMap.enabled && X.length > 0,
        shadowMapType: r.shadowMap.type,
        toneMapping: ut,
        useLegacyLights: r._useLegacyLights,
        decodeVideoTexture:
          Xe && M.map.isVideoTexture === !0 && M.map.colorSpace === qe,
        premultipliedAlpha: M.premultipliedAlpha,
        doubleSided: M.side === Nn,
        flipSided: M.side === Jt,
        useDepthPacking: M.depthPacking >= 0,
        depthPacking: M.depthPacking || 0,
        index0AttributeName: M.index0AttributeName,
        extensionDerivatives: ie && M.extensions.derivatives === !0,
        extensionFragDepth: ie && M.extensions.fragDepth === !0,
        extensionDrawBuffers: ie && M.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: ie && M.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: h || n.has('EXT_frag_depth'),
        rendererExtensionDrawBuffers: h || n.has('WEBGL_draw_buffers'),
        rendererExtensionShaderTextureLod: h || n.has('EXT_shader_texture_lod'),
        customProgramCacheKey: M.customProgramCacheKey()
      }
    );
  }
  function m(M) {
    const A = [];
    if (
      (M.shaderID
        ? A.push(M.shaderID)
        : (A.push(M.customVertexShaderID), A.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const X in M.defines) A.push(X), A.push(M.defines[X]);
    return (
      M.isRawShaderMaterial === !1 &&
        (y(A, M), v(A, M), A.push(r.outputColorSpace)),
      A.push(M.customProgramCacheKey),
      A.join()
    );
  }
  function y(M, A) {
    M.push(A.precision),
      M.push(A.outputColorSpace),
      M.push(A.envMapMode),
      M.push(A.envMapCubeUVHeight),
      M.push(A.mapUv),
      M.push(A.alphaMapUv),
      M.push(A.lightMapUv),
      M.push(A.aoMapUv),
      M.push(A.bumpMapUv),
      M.push(A.normalMapUv),
      M.push(A.displacementMapUv),
      M.push(A.emissiveMapUv),
      M.push(A.metalnessMapUv),
      M.push(A.roughnessMapUv),
      M.push(A.anisotropyMapUv),
      M.push(A.clearcoatMapUv),
      M.push(A.clearcoatNormalMapUv),
      M.push(A.clearcoatRoughnessMapUv),
      M.push(A.iridescenceMapUv),
      M.push(A.iridescenceThicknessMapUv),
      M.push(A.sheenColorMapUv),
      M.push(A.sheenRoughnessMapUv),
      M.push(A.specularMapUv),
      M.push(A.specularColorMapUv),
      M.push(A.specularIntensityMapUv),
      M.push(A.transmissionMapUv),
      M.push(A.thicknessMapUv),
      M.push(A.combine),
      M.push(A.fogExp2),
      M.push(A.sizeAttenuation),
      M.push(A.morphTargetsCount),
      M.push(A.morphAttributeCount),
      M.push(A.numDirLights),
      M.push(A.numPointLights),
      M.push(A.numSpotLights),
      M.push(A.numSpotLightMaps),
      M.push(A.numHemiLights),
      M.push(A.numRectAreaLights),
      M.push(A.numDirLightShadows),
      M.push(A.numPointLightShadows),
      M.push(A.numSpotLightShadows),
      M.push(A.numSpotLightShadowsWithMaps),
      M.push(A.shadowMapType),
      M.push(A.toneMapping),
      M.push(A.numClippingPlanes),
      M.push(A.numClipIntersection),
      M.push(A.depthPacking);
  }
  function v(M, A) {
    a.disableAll(),
      A.isWebGL2 && a.enable(0),
      A.supportsVertexTextures && a.enable(1),
      A.instancing && a.enable(2),
      A.instancingColor && a.enable(3),
      A.matcap && a.enable(4),
      A.envMap && a.enable(5),
      A.normalMapObjectSpace && a.enable(6),
      A.normalMapTangentSpace && a.enable(7),
      A.clearcoat && a.enable(8),
      A.iridescence && a.enable(9),
      A.alphaTest && a.enable(10),
      A.vertexColors && a.enable(11),
      A.vertexAlphas && a.enable(12),
      A.vertexUv1s && a.enable(13),
      A.vertexUv2s && a.enable(14),
      A.vertexUv3s && a.enable(15),
      A.vertexTangents && a.enable(16),
      A.anisotropy && a.enable(17),
      M.push(a.mask),
      a.disableAll(),
      A.fog && a.enable(0),
      A.useFog && a.enable(1),
      A.flatShading && a.enable(2),
      A.logarithmicDepthBuffer && a.enable(3),
      A.skinning && a.enable(4),
      A.morphTargets && a.enable(5),
      A.morphNormals && a.enable(6),
      A.morphColors && a.enable(7),
      A.premultipliedAlpha && a.enable(8),
      A.shadowMapEnabled && a.enable(9),
      A.useLegacyLights && a.enable(10),
      A.doubleSided && a.enable(11),
      A.flipSided && a.enable(12),
      A.useDepthPacking && a.enable(13),
      A.dithering && a.enable(14),
      A.transmission && a.enable(15),
      A.sheen && a.enable(16),
      A.opaque && a.enable(17),
      A.pointsUvs && a.enable(18),
      A.decodeVideoTexture && a.enable(19),
      M.push(a.mask);
  }
  function x(M) {
    const A = _[M.type];
    let X;
    if (A) {
      const Y = On[A];
      X = jv.clone(Y.uniforms);
    } else X = M.uniforms;
    return X;
  }
  function S(M, A) {
    let X;
    for (let Y = 0, D = l.length; Y < D; Y++) {
      const F = l[Y];
      if (F.cacheKey === A) {
        (X = F), ++X.usedTimes;
        break;
      }
    }
    return X === void 0 && ((X = new ib(r, A, M, s)), l.push(X)), X;
  }
  function b(M) {
    if (--M.usedTimes === 0) {
      const A = l.indexOf(M);
      (l[A] = l[l.length - 1]), l.pop(), M.destroy();
    }
  }
  function T(M) {
    c.remove(M);
  }
  function C() {
    c.dispose();
  }
  return {
    getParameters: d,
    getProgramCacheKey: m,
    getUniforms: x,
    acquireProgram: S,
    releaseProgram: b,
    releaseShaderCache: T,
    programs: l,
    dispose: C
  };
}
function cb() {
  let r = new WeakMap();
  function e(s) {
    let o = r.get(s);
    return o === void 0 && ((o = {}), r.set(s, o)), o;
  }
  function t(s) {
    r.delete(s);
  }
  function n(s, o, a) {
    r.get(s)[o] = a;
  }
  function i() {
    r = new WeakMap();
  }
  return { get: e, remove: t, update: n, dispose: i };
}
function lb(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.material.id !== e.material.id
    ? r.material.id - e.material.id
    : r.z !== e.z
    ? r.z - e.z
    : r.id - e.id;
}
function rf(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.z !== e.z
    ? e.z - r.z
    : r.id - e.id;
}
function sf() {
  const r = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function o(f, u, p, _, g, d) {
    let m = r[e];
    return (
      m === void 0
        ? ((m = {
            id: f.id,
            object: f,
            geometry: u,
            material: p,
            groupOrder: _,
            renderOrder: f.renderOrder,
            z: g,
            group: d
          }),
          (r[e] = m))
        : ((m.id = f.id),
          (m.object = f),
          (m.geometry = u),
          (m.material = p),
          (m.groupOrder = _),
          (m.renderOrder = f.renderOrder),
          (m.z = g),
          (m.group = d)),
      e++,
      m
    );
  }
  function a(f, u, p, _, g, d) {
    const m = o(f, u, p, _, g, d);
    p.transmission > 0
      ? n.push(m)
      : p.transparent === !0
      ? i.push(m)
      : t.push(m);
  }
  function c(f, u, p, _, g, d) {
    const m = o(f, u, p, _, g, d);
    p.transmission > 0
      ? n.unshift(m)
      : p.transparent === !0
      ? i.unshift(m)
      : t.unshift(m);
  }
  function l(f, u) {
    t.length > 1 && t.sort(f || lb),
      n.length > 1 && n.sort(u || rf),
      i.length > 1 && i.sort(u || rf);
  }
  function h() {
    for (let f = e, u = r.length; f < u; f++) {
      const p = r[f];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: s,
    push: a,
    unshift: c,
    finish: h,
    sort: l
  };
}
function hb() {
  let r = new WeakMap();
  function e(n, i) {
    const s = r.get(n);
    let o;
    return (
      s === void 0
        ? ((o = new sf()), r.set(n, [o]))
        : i >= s.length
        ? ((o = new sf()), s.push(o))
        : (o = s[i]),
      o
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function ub() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = { direction: new P(), color: new Re() };
          break;
        case 'SpotLight':
          t = {
            position: new P(),
            direction: new P(),
            color: new Re(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case 'PointLight':
          t = { position: new P(), color: new Re(), distance: 0, decay: 0 };
          break;
        case 'HemisphereLight':
          t = { direction: new P(), skyColor: new Re(), groundColor: new Re() };
          break;
        case 'RectAreaLight':
          t = {
            color: new Re(),
            position: new P(),
            halfWidth: new P(),
            halfHeight: new P()
          };
          break;
      }
      return (r[e.id] = t), t;
    }
  };
}
function fb() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ve()
          };
          break;
        case 'SpotLight':
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ve()
          };
          break;
        case 'PointLight':
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ve(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return (r[e.id] = t), t;
    }
  };
}
let db = 0;
function pb(r, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (r.map ? 1 : 0)
  );
}
function mb(r, e) {
  const t = new ub(),
    n = fb(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0
    };
  for (let h = 0; h < 9; h++) i.probe.push(new P());
  const s = new P(),
    o = new Ue(),
    a = new Ue();
  function c(h, f) {
    let u = 0,
      p = 0,
      _ = 0;
    for (let X = 0; X < 9; X++) i.probe[X].set(0, 0, 0);
    let g = 0,
      d = 0,
      m = 0,
      y = 0,
      v = 0,
      x = 0,
      S = 0,
      b = 0,
      T = 0,
      C = 0;
    h.sort(pb);
    const M = f === !0 ? Math.PI : 1;
    for (let X = 0, Y = h.length; X < Y; X++) {
      const D = h[X],
        F = D.color,
        N = D.intensity,
        K = D.distance,
        z = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        (u += F.r * N * M), (p += F.g * N * M), (_ += F.b * N * M);
      else if (D.isLightProbe)
        for (let j = 0; j < 9; j++)
          i.probe[j].addScaledVector(D.sh.coefficients[j], N);
      else if (D.isDirectionalLight) {
        const j = t.get(D);
        if (
          (j.color.copy(D.color).multiplyScalar(D.intensity * M), D.castShadow)
        ) {
          const J = D.shadow,
            $ = n.get(D);
          ($.shadowBias = J.bias),
            ($.shadowNormalBias = J.normalBias),
            ($.shadowRadius = J.radius),
            ($.shadowMapSize = J.mapSize),
            (i.directionalShadow[g] = $),
            (i.directionalShadowMap[g] = z),
            (i.directionalShadowMatrix[g] = D.shadow.matrix),
            x++;
        }
        (i.directional[g] = j), g++;
      } else if (D.isSpotLight) {
        const j = t.get(D);
        j.position.setFromMatrixPosition(D.matrixWorld),
          j.color.copy(F).multiplyScalar(N * M),
          (j.distance = K),
          (j.coneCos = Math.cos(D.angle)),
          (j.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (j.decay = D.decay),
          (i.spot[m] = j);
        const J = D.shadow;
        if (
          (D.map &&
            ((i.spotLightMap[T] = D.map),
            T++,
            J.updateMatrices(D),
            D.castShadow && C++),
          (i.spotLightMatrix[m] = J.matrix),
          D.castShadow)
        ) {
          const $ = n.get(D);
          ($.shadowBias = J.bias),
            ($.shadowNormalBias = J.normalBias),
            ($.shadowRadius = J.radius),
            ($.shadowMapSize = J.mapSize),
            (i.spotShadow[m] = $),
            (i.spotShadowMap[m] = z),
            b++;
        }
        m++;
      } else if (D.isRectAreaLight) {
        const j = t.get(D);
        j.color.copy(F).multiplyScalar(N),
          j.halfWidth.set(D.width * 0.5, 0, 0),
          j.halfHeight.set(0, D.height * 0.5, 0),
          (i.rectArea[y] = j),
          y++;
      } else if (D.isPointLight) {
        const j = t.get(D);
        if (
          (j.color.copy(D.color).multiplyScalar(D.intensity * M),
          (j.distance = D.distance),
          (j.decay = D.decay),
          D.castShadow)
        ) {
          const J = D.shadow,
            $ = n.get(D);
          ($.shadowBias = J.bias),
            ($.shadowNormalBias = J.normalBias),
            ($.shadowRadius = J.radius),
            ($.shadowMapSize = J.mapSize),
            ($.shadowCameraNear = J.camera.near),
            ($.shadowCameraFar = J.camera.far),
            (i.pointShadow[d] = $),
            (i.pointShadowMap[d] = z),
            (i.pointShadowMatrix[d] = D.shadow.matrix),
            S++;
        }
        (i.point[d] = j), d++;
      } else if (D.isHemisphereLight) {
        const j = t.get(D);
        j.skyColor.copy(D.color).multiplyScalar(N * M),
          j.groundColor.copy(D.groundColor).multiplyScalar(N * M),
          (i.hemi[v] = j),
          v++;
      }
    }
    y > 0 &&
      (e.isWebGL2 || r.has('OES_texture_float_linear') === !0
        ? ((i.rectAreaLTC1 = se.LTC_FLOAT_1), (i.rectAreaLTC2 = se.LTC_FLOAT_2))
        : r.has('OES_texture_half_float_linear') === !0
        ? ((i.rectAreaLTC1 = se.LTC_HALF_1), (i.rectAreaLTC2 = se.LTC_HALF_2))
        : console.error(
            'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
          )),
      (i.ambient[0] = u),
      (i.ambient[1] = p),
      (i.ambient[2] = _);
    const A = i.hash;
    (A.directionalLength !== g ||
      A.pointLength !== d ||
      A.spotLength !== m ||
      A.rectAreaLength !== y ||
      A.hemiLength !== v ||
      A.numDirectionalShadows !== x ||
      A.numPointShadows !== S ||
      A.numSpotShadows !== b ||
      A.numSpotMaps !== T) &&
      ((i.directional.length = g),
      (i.spot.length = m),
      (i.rectArea.length = y),
      (i.point.length = d),
      (i.hemi.length = v),
      (i.directionalShadow.length = x),
      (i.directionalShadowMap.length = x),
      (i.pointShadow.length = S),
      (i.pointShadowMap.length = S),
      (i.spotShadow.length = b),
      (i.spotShadowMap.length = b),
      (i.directionalShadowMatrix.length = x),
      (i.pointShadowMatrix.length = S),
      (i.spotLightMatrix.length = b + T - C),
      (i.spotLightMap.length = T),
      (i.numSpotLightShadowsWithMaps = C),
      (A.directionalLength = g),
      (A.pointLength = d),
      (A.spotLength = m),
      (A.rectAreaLength = y),
      (A.hemiLength = v),
      (A.numDirectionalShadows = x),
      (A.numPointShadows = S),
      (A.numSpotShadows = b),
      (A.numSpotMaps = T),
      (i.version = db++));
  }
  function l(h, f) {
    let u = 0,
      p = 0,
      _ = 0,
      g = 0,
      d = 0;
    const m = f.matrixWorldInverse;
    for (let y = 0, v = h.length; y < v; y++) {
      const x = h[y];
      if (x.isDirectionalLight) {
        const S = i.directional[u];
        S.direction.setFromMatrixPosition(x.matrixWorld),
          s.setFromMatrixPosition(x.target.matrixWorld),
          S.direction.sub(s),
          S.direction.transformDirection(m),
          u++;
      } else if (x.isSpotLight) {
        const S = i.spot[_];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(m),
          S.direction.setFromMatrixPosition(x.matrixWorld),
          s.setFromMatrixPosition(x.target.matrixWorld),
          S.direction.sub(s),
          S.direction.transformDirection(m),
          _++;
      } else if (x.isRectAreaLight) {
        const S = i.rectArea[g];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(m),
          a.identity(),
          o.copy(x.matrixWorld),
          o.premultiply(m),
          a.extractRotation(o),
          S.halfWidth.set(x.width * 0.5, 0, 0),
          S.halfHeight.set(0, x.height * 0.5, 0),
          S.halfWidth.applyMatrix4(a),
          S.halfHeight.applyMatrix4(a),
          g++;
      } else if (x.isPointLight) {
        const S = i.point[p];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(m),
          p++;
      } else if (x.isHemisphereLight) {
        const S = i.hemi[d];
        S.direction.setFromMatrixPosition(x.matrixWorld),
          S.direction.transformDirection(m),
          d++;
      }
    }
  }
  return { setup: c, setupView: l, state: i };
}
function of(r, e) {
  const t = new mb(r, e),
    n = [],
    i = [];
  function s() {
    (n.length = 0), (i.length = 0);
  }
  function o(f) {
    n.push(f);
  }
  function a(f) {
    i.push(f);
  }
  function c(f) {
    t.setup(n, f);
  }
  function l(f) {
    t.setupView(n, f);
  }
  return {
    init: s,
    state: { lightsArray: n, shadowsArray: i, lights: t },
    setupLights: c,
    setupLightsView: l,
    pushLight: o,
    pushShadow: a
  };
}
function gb(r, e) {
  let t = new WeakMap();
  function n(s, o = 0) {
    const a = t.get(s);
    let c;
    return (
      a === void 0
        ? ((c = new of(r, e)), t.set(s, [c]))
        : o >= a.length
        ? ((c = new of(r, e)), a.push(c))
        : (c = a[o]),
      c
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
class _b extends Hn {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = J0),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class vb extends Hn {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const yb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  xb = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Mb(r, e, t) {
  let n = new Wl();
  const i = new Ve(),
    s = new Ve(),
    o = new Je(),
    a = new _b({ depthPacking: Q0 }),
    c = new vb(),
    l = {},
    h = t.maxTextureSize,
    f = { [ui]: Jt, [Jt]: ui, [Nn]: Nn },
    u = new vr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ve() },
        radius: { value: 4 }
      },
      vertexShader: yb,
      fragmentShader: xb
    }),
    p = u.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const _ = new Dn();
  _.setAttribute(
    'position',
    new Lt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const g = new bn(_, u),
    d = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = sp);
  let m = this.type;
  this.render = function (S, b, T) {
    if (
      d.enabled === !1 ||
      (d.autoUpdate === !1 && d.needsUpdate === !1) ||
      S.length === 0
    )
      return;
    const C = r.getRenderTarget(),
      M = r.getActiveCubeFace(),
      A = r.getActiveMipmapLevel(),
      X = r.state;
    X.setBlending(Di),
      X.buffers.color.setClear(1, 1, 1, 1),
      X.buffers.depth.setTest(!0),
      X.setScissorTest(!1);
    const Y = m !== ni && this.type === ni,
      D = m === ni && this.type !== ni;
    for (let F = 0, N = S.length; F < N; F++) {
      const K = S[F],
        z = K.shadow;
      if (z === void 0) {
        console.warn('THREE.WebGLShadowMap:', K, 'has no shadow.');
        continue;
      }
      if (z.autoUpdate === !1 && z.needsUpdate === !1) continue;
      i.copy(z.mapSize);
      const j = z.getFrameExtents();
      if (
        (i.multiply(j),
        s.copy(z.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((s.x = Math.floor(h / j.x)),
            (i.x = s.x * j.x),
            (z.mapSize.x = s.x)),
          i.y > h &&
            ((s.y = Math.floor(h / j.y)),
            (i.y = s.y * j.y),
            (z.mapSize.y = s.y))),
        z.map === null || Y === !0 || D === !0)
      ) {
        const $ = this.type !== ni ? { minFilter: Et, magFilter: Et } : {};
        z.map !== null && z.map.dispose(),
          (z.map = new _r(i.x, i.y, $)),
          (z.map.texture.name = K.name + '.shadowMap'),
          z.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(z.map), r.clear();
      const J = z.getViewportCount();
      for (let $ = 0; $ < J; $++) {
        const k = z.getViewport($);
        o.set(s.x * k.x, s.y * k.y, s.x * k.z, s.y * k.w),
          X.viewport(o),
          z.updateMatrices(K, $),
          (n = z.getFrustum()),
          x(b, T, z.camera, K, this.type);
      }
      z.isPointLightShadow !== !0 && this.type === ni && y(z, T),
        (z.needsUpdate = !1);
    }
    (m = this.type), (d.needsUpdate = !1), r.setRenderTarget(C, M, A);
  };
  function y(S, b) {
    const T = e.update(g);
    u.defines.VSM_SAMPLES !== S.blurSamples &&
      ((u.defines.VSM_SAMPLES = S.blurSamples),
      (p.defines.VSM_SAMPLES = S.blurSamples),
      (u.needsUpdate = !0),
      (p.needsUpdate = !0)),
      S.mapPass === null && (S.mapPass = new _r(i.x, i.y)),
      (u.uniforms.shadow_pass.value = S.map.texture),
      (u.uniforms.resolution.value = S.mapSize),
      (u.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.mapPass),
      r.clear(),
      r.renderBufferDirect(b, null, T, u, g, null),
      (p.uniforms.shadow_pass.value = S.mapPass.texture),
      (p.uniforms.resolution.value = S.mapSize),
      (p.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.map),
      r.clear(),
      r.renderBufferDirect(b, null, T, p, g, null);
  }
  function v(S, b, T, C) {
    let M = null;
    const A =
      T.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (A !== void 0) M = A;
    else if (
      ((M = T.isPointLight === !0 ? c : a),
      (r.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const X = M.uuid,
        Y = b.uuid;
      let D = l[X];
      D === void 0 && ((D = {}), (l[X] = D));
      let F = D[Y];
      F === void 0 && ((F = M.clone()), (D[Y] = F)), (M = F);
    }
    if (
      ((M.visible = b.visible),
      (M.wireframe = b.wireframe),
      C === ni
        ? (M.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (M.side = b.shadowSide !== null ? b.shadowSide : f[b.side]),
      (M.alphaMap = b.alphaMap),
      (M.alphaTest = b.alphaTest),
      (M.map = b.map),
      (M.clipShadows = b.clipShadows),
      (M.clippingPlanes = b.clippingPlanes),
      (M.clipIntersection = b.clipIntersection),
      (M.displacementMap = b.displacementMap),
      (M.displacementScale = b.displacementScale),
      (M.displacementBias = b.displacementBias),
      (M.wireframeLinewidth = b.wireframeLinewidth),
      (M.linewidth = b.linewidth),
      T.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const X = r.properties.get(M);
      X.light = T;
    }
    return M;
  }
  function x(S, b, T, C, M) {
    if (S.visible === !1) return;
    if (
      S.layers.test(b.layers) &&
      (S.isMesh || S.isLine || S.isPoints) &&
      (S.castShadow || (S.receiveShadow && M === ni)) &&
      (!S.frustumCulled || n.intersectsObject(S))
    ) {
      S.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, S.matrixWorld);
      const Y = e.update(S),
        D = S.material;
      if (Array.isArray(D)) {
        const F = Y.groups;
        for (let N = 0, K = F.length; N < K; N++) {
          const z = F[N],
            j = D[z.materialIndex];
          if (j && j.visible) {
            const J = v(S, j, C, M);
            r.renderBufferDirect(T, null, Y, J, S, z);
          }
        }
      } else if (D.visible) {
        const F = v(S, D, C, M);
        r.renderBufferDirect(T, null, Y, F, S, null);
      }
    }
    const X = S.children;
    for (let Y = 0, D = X.length; Y < D; Y++) x(X[Y], b, T, C, M);
  }
}
function Sb(r, e, t) {
  const n = t.isWebGL2;
  function i() {
    let L = !1;
    const ae = new Je();
    let H = null;
    const ie = new Je(0, 0, 0, 0);
    return {
      setMask: function (ce) {
        H !== ce && !L && (r.colorMask(ce, ce, ce, ce), (H = ce));
      },
      setLocked: function (ce) {
        L = ce;
      },
      setClear: function (ce, We, nt, ut, di) {
        di === !0 && ((ce *= ut), (We *= ut), (nt *= ut)),
          ae.set(ce, We, nt, ut),
          ie.equals(ae) === !1 && (r.clearColor(ce, We, nt, ut), ie.copy(ae));
      },
      reset: function () {
        (L = !1), (H = null), ie.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let L = !1,
      ae = null,
      H = null,
      ie = null;
    return {
      setTest: function (ce) {
        ce ? Ae(r.DEPTH_TEST) : ye(r.DEPTH_TEST);
      },
      setMask: function (ce) {
        ae !== ce && !L && (r.depthMask(ce), (ae = ce));
      },
      setFunc: function (ce) {
        if (H !== ce) {
          switch (ce) {
            case w0:
              r.depthFunc(r.NEVER);
              break;
            case R0:
              r.depthFunc(r.ALWAYS);
              break;
            case C0:
              r.depthFunc(r.LESS);
              break;
            case Jc:
              r.depthFunc(r.LEQUAL);
              break;
            case L0:
              r.depthFunc(r.EQUAL);
              break;
            case P0:
              r.depthFunc(r.GEQUAL);
              break;
            case D0:
              r.depthFunc(r.GREATER);
              break;
            case I0:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          H = ce;
        }
      },
      setLocked: function (ce) {
        L = ce;
      },
      setClear: function (ce) {
        ie !== ce && (r.clearDepth(ce), (ie = ce));
      },
      reset: function () {
        (L = !1), (ae = null), (H = null), (ie = null);
      }
    };
  }
  function o() {
    let L = !1,
      ae = null,
      H = null,
      ie = null,
      ce = null,
      We = null,
      nt = null,
      ut = null,
      di = null;
    return {
      setTest: function (et) {
        L || (et ? Ae(r.STENCIL_TEST) : ye(r.STENCIL_TEST));
      },
      setMask: function (et) {
        ae !== et && !L && (r.stencilMask(et), (ae = et));
      },
      setFunc: function (et, In, zt) {
        (H !== et || ie !== In || ce !== zt) &&
          (r.stencilFunc(et, In, zt), (H = et), (ie = In), (ce = zt));
      },
      setOp: function (et, In, zt) {
        (We !== et || nt !== In || ut !== zt) &&
          (r.stencilOp(et, In, zt), (We = et), (nt = In), (ut = zt));
      },
      setLocked: function (et) {
        L = et;
      },
      setClear: function (et) {
        di !== et && (r.clearStencil(et), (di = et));
      },
      reset: function () {
        (L = !1),
          (ae = null),
          (H = null),
          (ie = null),
          (ce = null),
          (We = null),
          (nt = null),
          (ut = null),
          (di = null);
      }
    };
  }
  const a = new i(),
    c = new s(),
    l = new o(),
    h = new WeakMap(),
    f = new WeakMap();
  let u = {},
    p = {},
    _ = new WeakMap(),
    g = [],
    d = null,
    m = !1,
    y = null,
    v = null,
    x = null,
    S = null,
    b = null,
    T = null,
    C = null,
    M = !1,
    A = null,
    X = null,
    Y = null,
    D = null,
    F = null;
  const N = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let K = !1,
    z = 0;
  const j = r.getParameter(r.VERSION);
  j.indexOf('WebGL') !== -1
    ? ((z = parseFloat(/^WebGL (\d)/.exec(j)[1])), (K = z >= 1))
    : j.indexOf('OpenGL ES') !== -1 &&
      ((z = parseFloat(/^OpenGL ES (\d)/.exec(j)[1])), (K = z >= 2));
  let J = null,
    $ = {};
  const k = r.getParameter(r.SCISSOR_BOX),
    V = r.getParameter(r.VIEWPORT),
    oe = new Je().fromArray(k),
    re = new Je().fromArray(V);
  function le(L, ae, H, ie) {
    const ce = new Uint8Array(4),
      We = r.createTexture();
    r.bindTexture(L, We),
      r.texParameteri(L, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(L, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let nt = 0; nt < H; nt++)
      n && (L === r.TEXTURE_3D || L === r.TEXTURE_2D_ARRAY)
        ? r.texImage3D(ae, 0, r.RGBA, 1, 1, ie, 0, r.RGBA, r.UNSIGNED_BYTE, ce)
        : r.texImage2D(
            ae + nt,
            0,
            r.RGBA,
            1,
            1,
            0,
            r.RGBA,
            r.UNSIGNED_BYTE,
            ce
          );
    return We;
  }
  const ve = {};
  (ve[r.TEXTURE_2D] = le(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (ve[r.TEXTURE_CUBE_MAP] = le(
      r.TEXTURE_CUBE_MAP,
      r.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    n &&
      ((ve[r.TEXTURE_2D_ARRAY] = le(
        r.TEXTURE_2D_ARRAY,
        r.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (ve[r.TEXTURE_3D] = le(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    c.setClear(1),
    l.setClear(0),
    Ae(r.DEPTH_TEST),
    c.setFunc(Jc),
    Te(!1),
    tt(Gh),
    Ae(r.CULL_FACE),
    xe(Di);
  function Ae(L) {
    u[L] !== !0 && (r.enable(L), (u[L] = !0));
  }
  function ye(L) {
    u[L] !== !1 && (r.disable(L), (u[L] = !1));
  }
  function Xe(L, ae) {
    return p[L] !== ae
      ? (r.bindFramebuffer(L, ae),
        (p[L] = ae),
        n &&
          (L === r.DRAW_FRAMEBUFFER && (p[r.FRAMEBUFFER] = ae),
          L === r.FRAMEBUFFER && (p[r.DRAW_FRAMEBUFFER] = ae)),
        !0)
      : !1;
  }
  function qt(L, ae) {
    let H = g,
      ie = !1;
    if (L)
      if (
        ((H = _.get(ae)),
        H === void 0 && ((H = []), _.set(ae, H)),
        L.isWebGLMultipleRenderTargets)
      ) {
        const ce = L.texture;
        if (H.length !== ce.length || H[0] !== r.COLOR_ATTACHMENT0) {
          for (let We = 0, nt = ce.length; We < nt; We++)
            H[We] = r.COLOR_ATTACHMENT0 + We;
          (H.length = ce.length), (ie = !0);
        }
      } else
        H[0] !== r.COLOR_ATTACHMENT0 &&
          ((H[0] = r.COLOR_ATTACHMENT0), (ie = !0));
    else H[0] !== r.BACK && ((H[0] = r.BACK), (ie = !0));
    ie &&
      (t.isWebGL2
        ? r.drawBuffers(H)
        : e.get('WEBGL_draw_buffers').drawBuffersWEBGL(H));
  }
  function De(L) {
    return d !== L ? (r.useProgram(L), (d = L), !0) : !1;
  }
  const O = {
    [Vr]: r.FUNC_ADD,
    [g0]: r.FUNC_SUBTRACT,
    [_0]: r.FUNC_REVERSE_SUBTRACT
  };
  if (n) (O[Xh] = r.MIN), (O[jh] = r.MAX);
  else {
    const L = e.get('EXT_blend_minmax');
    L !== null && ((O[Xh] = L.MIN_EXT), (O[jh] = L.MAX_EXT));
  }
  const Pt = {
    [v0]: r.ZERO,
    [y0]: r.ONE,
    [x0]: r.SRC_COLOR,
    [op]: r.SRC_ALPHA,
    [A0]: r.SRC_ALPHA_SATURATE,
    [E0]: r.DST_COLOR,
    [S0]: r.DST_ALPHA,
    [M0]: r.ONE_MINUS_SRC_COLOR,
    [ap]: r.ONE_MINUS_SRC_ALPHA,
    [T0]: r.ONE_MINUS_DST_COLOR,
    [b0]: r.ONE_MINUS_DST_ALPHA
  };
  function xe(L, ae, H, ie, ce, We, nt, ut) {
    if (L === Di) {
      m === !0 && (ye(r.BLEND), (m = !1));
      return;
    }
    if ((m === !1 && (Ae(r.BLEND), (m = !0)), L !== m0)) {
      if (L !== y || ut !== M) {
        if (
          ((v !== Vr || b !== Vr) &&
            (r.blendEquation(r.FUNC_ADD), (v = Vr), (b = Vr)),
          ut)
        )
          switch (L) {
            case Jr:
              r.blendFuncSeparate(
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Vh:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Wh:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case qh:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', L);
              break;
          }
        else
          switch (L) {
            case Jr:
              r.blendFuncSeparate(
                r.SRC_ALPHA,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Vh:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Wh:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case qh:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', L);
              break;
          }
        (x = null), (S = null), (T = null), (C = null), (y = L), (M = ut);
      }
      return;
    }
    (ce = ce || ae),
      (We = We || H),
      (nt = nt || ie),
      (ae !== v || ce !== b) &&
        (r.blendEquationSeparate(O[ae], O[ce]), (v = ae), (b = ce)),
      (H !== x || ie !== S || We !== T || nt !== C) &&
        (r.blendFuncSeparate(Pt[H], Pt[ie], Pt[We], Pt[nt]),
        (x = H),
        (S = ie),
        (T = We),
        (C = nt)),
      (y = L),
      (M = !1);
  }
  function Ce(L, ae) {
    L.side === Nn ? ye(r.CULL_FACE) : Ae(r.CULL_FACE);
    let H = L.side === Jt;
    ae && (H = !H),
      Te(H),
      L.blending === Jr && L.transparent === !1
        ? xe(Di)
        : xe(
            L.blending,
            L.blendEquation,
            L.blendSrc,
            L.blendDst,
            L.blendEquationAlpha,
            L.blendSrcAlpha,
            L.blendDstAlpha,
            L.premultipliedAlpha
          ),
      c.setFunc(L.depthFunc),
      c.setTest(L.depthTest),
      c.setMask(L.depthWrite),
      a.setMask(L.colorWrite);
    const ie = L.stencilWrite;
    l.setTest(ie),
      ie &&
        (l.setMask(L.stencilWriteMask),
        l.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask),
        l.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)),
      Ie(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits),
      L.alphaToCoverage === !0
        ? Ae(r.SAMPLE_ALPHA_TO_COVERAGE)
        : ye(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Te(L) {
    A !== L && (L ? r.frontFace(r.CW) : r.frontFace(r.CCW), (A = L));
  }
  function tt(L) {
    L !== f0
      ? (Ae(r.CULL_FACE),
        L !== X &&
          (L === Gh
            ? r.cullFace(r.BACK)
            : L === d0
            ? r.cullFace(r.FRONT)
            : r.cullFace(r.FRONT_AND_BACK)))
      : ye(r.CULL_FACE),
      (X = L);
  }
  function Be(L) {
    L !== Y && (K && r.lineWidth(L), (Y = L));
  }
  function Ie(L, ae, H) {
    L
      ? (Ae(r.POLYGON_OFFSET_FILL),
        (D !== ae || F !== H) && (r.polygonOffset(ae, H), (D = ae), (F = H)))
      : ye(r.POLYGON_OFFSET_FILL);
  }
  function Ke(L) {
    L ? Ae(r.SCISSOR_TEST) : ye(r.SCISSOR_TEST);
  }
  function At(L) {
    L === void 0 && (L = r.TEXTURE0 + N - 1),
      J !== L && (r.activeTexture(L), (J = L));
  }
  function Dt(L, ae, H) {
    H === void 0 && (J === null ? (H = r.TEXTURE0 + N - 1) : (H = J));
    let ie = $[H];
    ie === void 0 && ((ie = { type: void 0, texture: void 0 }), ($[H] = ie)),
      (ie.type !== L || ie.texture !== ae) &&
        (J !== H && (r.activeTexture(H), (J = H)),
        r.bindTexture(L, ae || ve[L]),
        (ie.type = L),
        (ie.texture = ae));
  }
  function R() {
    const L = $[J];
    L !== void 0 &&
      L.type !== void 0 &&
      (r.bindTexture(L.type, null), (L.type = void 0), (L.texture = void 0));
  }
  function E() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function B() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function ee() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function Q() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function te() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function de() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function ne() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function G() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function ge() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function pe() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (L) {
      console.error('THREE.WebGLState:', L);
    }
  }
  function me(L) {
    oe.equals(L) === !1 && (r.scissor(L.x, L.y, L.z, L.w), oe.copy(L));
  }
  function ue(L) {
    re.equals(L) === !1 && (r.viewport(L.x, L.y, L.z, L.w), re.copy(L));
  }
  function fe(L, ae) {
    let H = f.get(ae);
    H === void 0 && ((H = new WeakMap()), f.set(ae, H));
    let ie = H.get(L);
    ie === void 0 && ((ie = r.getUniformBlockIndex(ae, L.name)), H.set(L, ie));
  }
  function Ne(L, ae) {
    const ie = f.get(ae).get(L);
    h.get(ae) !== ie &&
      (r.uniformBlockBinding(ae, ie, L.__bindingPointIndex), h.set(ae, ie));
  }
  function Qe() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      n === !0 &&
        (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null)),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (u = {}),
      (J = null),
      ($ = {}),
      (p = {}),
      (_ = new WeakMap()),
      (g = []),
      (d = null),
      (m = !1),
      (y = null),
      (v = null),
      (x = null),
      (S = null),
      (b = null),
      (T = null),
      (C = null),
      (M = !1),
      (A = null),
      (X = null),
      (Y = null),
      (D = null),
      (F = null),
      oe.set(0, 0, r.canvas.width, r.canvas.height),
      re.set(0, 0, r.canvas.width, r.canvas.height),
      a.reset(),
      c.reset(),
      l.reset();
  }
  return {
    buffers: { color: a, depth: c, stencil: l },
    enable: Ae,
    disable: ye,
    bindFramebuffer: Xe,
    drawBuffers: qt,
    useProgram: De,
    setBlending: xe,
    setMaterial: Ce,
    setFlipSided: Te,
    setCullFace: tt,
    setLineWidth: Be,
    setPolygonOffset: Ie,
    setScissorTest: Ke,
    activeTexture: At,
    bindTexture: Dt,
    unbindTexture: R,
    compressedTexImage2D: E,
    compressedTexImage3D: B,
    texImage2D: ge,
    texImage3D: pe,
    updateUBOMapping: fe,
    uniformBlockBinding: Ne,
    texStorage2D: ne,
    texStorage3D: G,
    texSubImage2D: ee,
    texSubImage3D: Q,
    compressedTexSubImage2D: te,
    compressedTexSubImage3D: de,
    scissor: me,
    viewport: ue,
    reset: Qe
  };
}
function bb(r, e, t, n, i, s, o) {
  const a = i.isWebGL2,
    c = i.maxTextures,
    l = i.maxCubemapSize,
    h = i.maxTextureSize,
    f = i.maxSamples,
    u = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    p =
      typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    _ = new WeakMap();
  let g;
  const d = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < 'u' &&
      new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch {}
  function y(R, E) {
    return m ? new OffscreenCanvas(R, E) : to('canvas');
  }
  function v(R, E, B, ee) {
    let Q = 1;
    if (
      ((R.width > ee || R.height > ee) &&
        (Q = ee / Math.max(R.width, R.height)),
      Q < 1 || E === !0)
    )
      if (
        (typeof HTMLImageElement < 'u' && R instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && R instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && R instanceof ImageBitmap)
      ) {
        const te = E ? ua : Math.floor,
          de = te(Q * R.width),
          ne = te(Q * R.height);
        g === void 0 && (g = y(de, ne));
        const G = B ? y(de, ne) : g;
        return (
          (G.width = de),
          (G.height = ne),
          G.getContext('2d').drawImage(R, 0, 0, de, ne),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              R.width +
              'x' +
              R.height +
              ') to (' +
              de +
              'x' +
              ne +
              ').'
          ),
          G
        );
      } else
        return (
          'data' in R &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                R.width +
                'x' +
                R.height +
                ').'
            ),
          R
        );
    return R;
  }
  function x(R) {
    return sl(R.width) && sl(R.height);
  }
  function S(R) {
    return a
      ? !1
      : R.wrapS !== vn ||
          R.wrapT !== vn ||
          (R.minFilter !== Et && R.minFilter !== jt);
  }
  function b(R, E) {
    return R.generateMipmaps && E && R.minFilter !== Et && R.minFilter !== jt;
  }
  function T(R) {
    r.generateMipmap(R);
  }
  function C(R, E, B, ee, Q = !1) {
    if (a === !1) return E;
    if (R !== null) {
      if (r[R] !== void 0) return r[R];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          R +
          "'"
      );
    }
    let te = E;
    return (
      E === r.RED &&
        (B === r.FLOAT && (te = r.R32F),
        B === r.HALF_FLOAT && (te = r.R16F),
        B === r.UNSIGNED_BYTE && (te = r.R8)),
      E === r.RED_INTEGER &&
        (B === r.UNSIGNED_BYTE && (te = r.R8UI),
        B === r.UNSIGNED_SHORT && (te = r.R16UI),
        B === r.UNSIGNED_INT && (te = r.R32UI),
        B === r.BYTE && (te = r.R8I),
        B === r.SHORT && (te = r.R16I),
        B === r.INT && (te = r.R32I)),
      E === r.RG &&
        (B === r.FLOAT && (te = r.RG32F),
        B === r.HALF_FLOAT && (te = r.RG16F),
        B === r.UNSIGNED_BYTE && (te = r.RG8)),
      E === r.RGBA &&
        (B === r.FLOAT && (te = r.RGBA32F),
        B === r.HALF_FLOAT && (te = r.RGBA16F),
        B === r.UNSIGNED_BYTE &&
          (te = ee === qe && Q === !1 ? r.SRGB8_ALPHA8 : r.RGBA8),
        B === r.UNSIGNED_SHORT_4_4_4_4 && (te = r.RGBA4),
        B === r.UNSIGNED_SHORT_5_5_5_1 && (te = r.RGB5_A1)),
      (te === r.R16F ||
        te === r.R32F ||
        te === r.RG16F ||
        te === r.RG32F ||
        te === r.RGBA16F ||
        te === r.RGBA32F) &&
        e.get('EXT_color_buffer_float'),
      te
    );
  }
  function M(R, E, B) {
    return b(R, B) === !0 ||
      (R.isFramebufferTexture && R.minFilter !== Et && R.minFilter !== jt)
      ? Math.log2(Math.max(E.width, E.height)) + 1
      : R.mipmaps !== void 0 && R.mipmaps.length > 0
      ? R.mipmaps.length
      : R.isCompressedTexture && Array.isArray(R.image)
      ? E.mipmaps.length
      : 1;
  }
  function A(R) {
    return R === Et || R === tl || R === Zo ? r.NEAREST : r.LINEAR;
  }
  function X(R) {
    const E = R.target;
    E.removeEventListener('dispose', X), D(E), E.isVideoTexture && _.delete(E);
  }
  function Y(R) {
    const E = R.target;
    E.removeEventListener('dispose', Y), N(E);
  }
  function D(R) {
    const E = n.get(R);
    if (E.__webglInit === void 0) return;
    const B = R.source,
      ee = d.get(B);
    if (ee) {
      const Q = ee[E.__cacheKey];
      Q.usedTimes--,
        Q.usedTimes === 0 && F(R),
        Object.keys(ee).length === 0 && d.delete(B);
    }
    n.remove(R);
  }
  function F(R) {
    const E = n.get(R);
    r.deleteTexture(E.__webglTexture);
    const B = R.source,
      ee = d.get(B);
    delete ee[E.__cacheKey], o.memory.textures--;
  }
  function N(R) {
    const E = R.texture,
      B = n.get(R),
      ee = n.get(E);
    if (
      (ee.__webglTexture !== void 0 &&
        (r.deleteTexture(ee.__webglTexture), o.memory.textures--),
      R.depthTexture && R.depthTexture.dispose(),
      R.isWebGLCubeRenderTarget)
    )
      for (let Q = 0; Q < 6; Q++) {
        if (Array.isArray(B.__webglFramebuffer[Q]))
          for (let te = 0; te < B.__webglFramebuffer[Q].length; te++)
            r.deleteFramebuffer(B.__webglFramebuffer[Q][te]);
        else r.deleteFramebuffer(B.__webglFramebuffer[Q]);
        B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer[Q]);
      }
    else {
      if (Array.isArray(B.__webglFramebuffer))
        for (let Q = 0; Q < B.__webglFramebuffer.length; Q++)
          r.deleteFramebuffer(B.__webglFramebuffer[Q]);
      else r.deleteFramebuffer(B.__webglFramebuffer);
      if (
        (B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer),
        B.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer(B.__webglMultisampledFramebuffer),
        B.__webglColorRenderbuffer)
      )
        for (let Q = 0; Q < B.__webglColorRenderbuffer.length; Q++)
          B.__webglColorRenderbuffer[Q] &&
            r.deleteRenderbuffer(B.__webglColorRenderbuffer[Q]);
      B.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer(B.__webglDepthRenderbuffer);
    }
    if (R.isWebGLMultipleRenderTargets)
      for (let Q = 0, te = E.length; Q < te; Q++) {
        const de = n.get(E[Q]);
        de.__webglTexture &&
          (r.deleteTexture(de.__webglTexture), o.memory.textures--),
          n.remove(E[Q]);
      }
    n.remove(E), n.remove(R);
  }
  let K = 0;
  function z() {
    K = 0;
  }
  function j() {
    const R = K;
    return (
      R >= c &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            R +
            ' texture units while this GPU supports only ' +
            c
        ),
      (K += 1),
      R
    );
  }
  function J(R) {
    const E = [];
    return (
      E.push(R.wrapS),
      E.push(R.wrapT),
      E.push(R.wrapR || 0),
      E.push(R.magFilter),
      E.push(R.minFilter),
      E.push(R.anisotropy),
      E.push(R.internalFormat),
      E.push(R.format),
      E.push(R.type),
      E.push(R.generateMipmaps),
      E.push(R.premultiplyAlpha),
      E.push(R.flipY),
      E.push(R.unpackAlignment),
      E.push(R.colorSpace),
      E.join()
    );
  }
  function $(R, E) {
    const B = n.get(R);
    if (
      (R.isVideoTexture && At(R),
      R.isRenderTargetTexture === !1 &&
        R.version > 0 &&
        B.__version !== R.version)
    ) {
      const ee = R.image;
      if (ee === null)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but no image data found.'
        );
      else if (ee.complete === !1)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
        );
      else {
        Xe(B, R, E);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, B.__webglTexture, r.TEXTURE0 + E);
  }
  function k(R, E) {
    const B = n.get(R);
    if (R.version > 0 && B.__version !== R.version) {
      Xe(B, R, E);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, B.__webglTexture, r.TEXTURE0 + E);
  }
  function V(R, E) {
    const B = n.get(R);
    if (R.version > 0 && B.__version !== R.version) {
      Xe(B, R, E);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, B.__webglTexture, r.TEXTURE0 + E);
  }
  function oe(R, E) {
    const B = n.get(R);
    if (R.version > 0 && B.__version !== R.version) {
      qt(B, R, E);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, B.__webglTexture, r.TEXTURE0 + E);
  }
  const re = { [cs]: r.REPEAT, [vn]: r.CLAMP_TO_EDGE, [la]: r.MIRRORED_REPEAT },
    le = {
      [Et]: r.NEAREST,
      [tl]: r.NEAREST_MIPMAP_NEAREST,
      [Zo]: r.NEAREST_MIPMAP_LINEAR,
      [jt]: r.LINEAR,
      [hp]: r.LINEAR_MIPMAP_NEAREST,
      [gr]: r.LINEAR_MIPMAP_LINEAR
    },
    ve = {
      [nv]: r.NEVER,
      [lv]: r.ALWAYS,
      [iv]: r.LESS,
      [sv]: r.LEQUAL,
      [rv]: r.EQUAL,
      [cv]: r.GEQUAL,
      [ov]: r.GREATER,
      [av]: r.NOTEQUAL
    };
  function Ae(R, E, B) {
    if (
      (B
        ? (r.texParameteri(R, r.TEXTURE_WRAP_S, re[E.wrapS]),
          r.texParameteri(R, r.TEXTURE_WRAP_T, re[E.wrapT]),
          (R === r.TEXTURE_3D || R === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(R, r.TEXTURE_WRAP_R, re[E.wrapR]),
          r.texParameteri(R, r.TEXTURE_MAG_FILTER, le[E.magFilter]),
          r.texParameteri(R, r.TEXTURE_MIN_FILTER, le[E.minFilter]))
        : (r.texParameteri(R, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
          r.texParameteri(R, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
          (R === r.TEXTURE_3D || R === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(R, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE),
          (E.wrapS !== vn || E.wrapT !== vn) &&
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
            ),
          r.texParameteri(R, r.TEXTURE_MAG_FILTER, A(E.magFilter)),
          r.texParameteri(R, r.TEXTURE_MIN_FILTER, A(E.minFilter)),
          E.minFilter !== Et &&
            E.minFilter !== jt &&
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
            )),
      E.compareFunction &&
        (r.texParameteri(R, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(R, r.TEXTURE_COMPARE_FUNC, ve[E.compareFunction])),
      e.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      const ee = e.get('EXT_texture_filter_anisotropic');
      if (
        E.magFilter === Et ||
        (E.minFilter !== Zo && E.minFilter !== gr) ||
        (E.type === oi && e.has('OES_texture_float_linear') === !1) ||
        (a === !1 &&
          E.type === Qs &&
          e.has('OES_texture_half_float_linear') === !1)
      )
        return;
      (E.anisotropy > 1 || n.get(E).__currentAnisotropy) &&
        (r.texParameterf(
          R,
          ee.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(E.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(E).__currentAnisotropy = E.anisotropy));
    }
  }
  function ye(R, E) {
    let B = !1;
    R.__webglInit === void 0 &&
      ((R.__webglInit = !0), E.addEventListener('dispose', X));
    const ee = E.source;
    let Q = d.get(ee);
    Q === void 0 && ((Q = {}), d.set(ee, Q));
    const te = J(E);
    if (te !== R.__cacheKey) {
      Q[te] === void 0 &&
        ((Q[te] = { texture: r.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (B = !0)),
        Q[te].usedTimes++;
      const de = Q[R.__cacheKey];
      de !== void 0 &&
        (Q[R.__cacheKey].usedTimes--, de.usedTimes === 0 && F(E)),
        (R.__cacheKey = te),
        (R.__webglTexture = Q[te].texture);
    }
    return B;
  }
  function Xe(R, E, B) {
    let ee = r.TEXTURE_2D;
    (E.isDataArrayTexture || E.isCompressedArrayTexture) &&
      (ee = r.TEXTURE_2D_ARRAY),
      E.isData3DTexture && (ee = r.TEXTURE_3D);
    const Q = ye(R, E),
      te = E.source;
    t.bindTexture(ee, R.__webglTexture, r.TEXTURE0 + B);
    const de = n.get(te);
    if (te.version !== de.__version || Q === !0) {
      t.activeTexture(r.TEXTURE0 + B),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const ne = S(E) && x(E.image) === !1;
      let G = v(E.image, ne, !1, h);
      G = Dt(E, G);
      const ge = x(G) || a,
        pe = s.convert(E.format, E.colorSpace);
      let me = s.convert(E.type),
        ue = C(E.internalFormat, pe, me, E.colorSpace, E.isVideoTexture);
      Ae(ee, E, ge);
      let fe;
      const Ne = E.mipmaps,
        Qe = a && E.isVideoTexture !== !0,
        L = de.__version === void 0 || Q === !0,
        ae = M(E, G, ge);
      if (E.isDepthTexture)
        (ue = r.DEPTH_COMPONENT),
          a
            ? E.type === oi
              ? (ue = r.DEPTH_COMPONENT32F)
              : E.type === Ci
              ? (ue = r.DEPTH_COMPONENT24)
              : E.type === ur
              ? (ue = r.DEPTH24_STENCIL8)
              : (ue = r.DEPTH_COMPONENT16)
            : E.type === oi &&
              console.error(
                'WebGLRenderer: Floating point depth texture requires WebGL2.'
              ),
          E.format === fr &&
            ue === r.DEPTH_COMPONENT &&
            E.type !== Gl &&
            E.type !== Ci &&
            (console.warn(
              'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
            ),
            (E.type = Ci),
            (me = s.convert(E.type))),
          E.format === ls &&
            ue === r.DEPTH_COMPONENT &&
            ((ue = r.DEPTH_STENCIL),
            E.type !== ur &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
              ),
              (E.type = ur),
              (me = s.convert(E.type)))),
          L &&
            (Qe
              ? t.texStorage2D(r.TEXTURE_2D, 1, ue, G.width, G.height)
              : t.texImage2D(
                  r.TEXTURE_2D,
                  0,
                  ue,
                  G.width,
                  G.height,
                  0,
                  pe,
                  me,
                  null
                ));
      else if (E.isDataTexture)
        if (Ne.length > 0 && ge) {
          Qe &&
            L &&
            t.texStorage2D(r.TEXTURE_2D, ae, ue, Ne[0].width, Ne[0].height);
          for (let H = 0, ie = Ne.length; H < ie; H++)
            (fe = Ne[H]),
              Qe
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    H,
                    0,
                    0,
                    fe.width,
                    fe.height,
                    pe,
                    me,
                    fe.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    H,
                    ue,
                    fe.width,
                    fe.height,
                    0,
                    pe,
                    me,
                    fe.data
                  );
          E.generateMipmaps = !1;
        } else
          Qe
            ? (L && t.texStorage2D(r.TEXTURE_2D, ae, ue, G.width, G.height),
              t.texSubImage2D(
                r.TEXTURE_2D,
                0,
                0,
                0,
                G.width,
                G.height,
                pe,
                me,
                G.data
              ))
            : t.texImage2D(
                r.TEXTURE_2D,
                0,
                ue,
                G.width,
                G.height,
                0,
                pe,
                me,
                G.data
              );
      else if (E.isCompressedTexture)
        if (E.isCompressedArrayTexture) {
          Qe &&
            L &&
            t.texStorage3D(
              r.TEXTURE_2D_ARRAY,
              ae,
              ue,
              Ne[0].width,
              Ne[0].height,
              G.depth
            );
          for (let H = 0, ie = Ne.length; H < ie; H++)
            (fe = Ne[H]),
              E.format !== yn
                ? pe !== null
                  ? Qe
                    ? t.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        H,
                        0,
                        0,
                        0,
                        fe.width,
                        fe.height,
                        G.depth,
                        pe,
                        fe.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        r.TEXTURE_2D_ARRAY,
                        H,
                        ue,
                        fe.width,
                        fe.height,
                        G.depth,
                        0,
                        fe.data,
                        0,
                        0
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                    )
                : Qe
                ? t.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    H,
                    0,
                    0,
                    0,
                    fe.width,
                    fe.height,
                    G.depth,
                    pe,
                    me,
                    fe.data
                  )
                : t.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    H,
                    ue,
                    fe.width,
                    fe.height,
                    G.depth,
                    0,
                    pe,
                    me,
                    fe.data
                  );
        } else {
          Qe &&
            L &&
            t.texStorage2D(r.TEXTURE_2D, ae, ue, Ne[0].width, Ne[0].height);
          for (let H = 0, ie = Ne.length; H < ie; H++)
            (fe = Ne[H]),
              E.format !== yn
                ? pe !== null
                  ? Qe
                    ? t.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        H,
                        0,
                        0,
                        fe.width,
                        fe.height,
                        pe,
                        fe.data
                      )
                    : t.compressedTexImage2D(
                        r.TEXTURE_2D,
                        H,
                        ue,
                        fe.width,
                        fe.height,
                        0,
                        fe.data
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                    )
                : Qe
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    H,
                    0,
                    0,
                    fe.width,
                    fe.height,
                    pe,
                    me,
                    fe.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    H,
                    ue,
                    fe.width,
                    fe.height,
                    0,
                    pe,
                    me,
                    fe.data
                  );
        }
      else if (E.isDataArrayTexture)
        Qe
          ? (L &&
              t.texStorage3D(
                r.TEXTURE_2D_ARRAY,
                ae,
                ue,
                G.width,
                G.height,
                G.depth
              ),
            t.texSubImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              G.width,
              G.height,
              G.depth,
              pe,
              me,
              G.data
            ))
          : t.texImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              ue,
              G.width,
              G.height,
              G.depth,
              0,
              pe,
              me,
              G.data
            );
      else if (E.isData3DTexture)
        Qe
          ? (L &&
              t.texStorage3D(r.TEXTURE_3D, ae, ue, G.width, G.height, G.depth),
            t.texSubImage3D(
              r.TEXTURE_3D,
              0,
              0,
              0,
              0,
              G.width,
              G.height,
              G.depth,
              pe,
              me,
              G.data
            ))
          : t.texImage3D(
              r.TEXTURE_3D,
              0,
              ue,
              G.width,
              G.height,
              G.depth,
              0,
              pe,
              me,
              G.data
            );
      else if (E.isFramebufferTexture) {
        if (L)
          if (Qe) t.texStorage2D(r.TEXTURE_2D, ae, ue, G.width, G.height);
          else {
            let H = G.width,
              ie = G.height;
            for (let ce = 0; ce < ae; ce++)
              t.texImage2D(r.TEXTURE_2D, ce, ue, H, ie, 0, pe, me, null),
                (H >>= 1),
                (ie >>= 1);
          }
      } else if (Ne.length > 0 && ge) {
        Qe &&
          L &&
          t.texStorage2D(r.TEXTURE_2D, ae, ue, Ne[0].width, Ne[0].height);
        for (let H = 0, ie = Ne.length; H < ie; H++)
          (fe = Ne[H]),
            Qe
              ? t.texSubImage2D(r.TEXTURE_2D, H, 0, 0, pe, me, fe)
              : t.texImage2D(r.TEXTURE_2D, H, ue, pe, me, fe);
        E.generateMipmaps = !1;
      } else
        Qe
          ? (L && t.texStorage2D(r.TEXTURE_2D, ae, ue, G.width, G.height),
            t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, pe, me, G))
          : t.texImage2D(r.TEXTURE_2D, 0, ue, pe, me, G);
      b(E, ge) && T(ee),
        (de.__version = te.version),
        E.onUpdate && E.onUpdate(E);
    }
    R.__version = E.version;
  }
  function qt(R, E, B) {
    if (E.image.length !== 6) return;
    const ee = ye(R, E),
      Q = E.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, R.__webglTexture, r.TEXTURE0 + B);
    const te = n.get(Q);
    if (Q.version !== te.__version || ee === !0) {
      t.activeTexture(r.TEXTURE0 + B),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const de = E.isCompressedTexture || E.image[0].isCompressedTexture,
        ne = E.image[0] && E.image[0].isDataTexture,
        G = [];
      for (let H = 0; H < 6; H++)
        !de && !ne
          ? (G[H] = v(E.image[H], !1, !0, l))
          : (G[H] = ne ? E.image[H].image : E.image[H]),
          (G[H] = Dt(E, G[H]));
      const ge = G[0],
        pe = x(ge) || a,
        me = s.convert(E.format, E.colorSpace),
        ue = s.convert(E.type),
        fe = C(E.internalFormat, me, ue, E.colorSpace),
        Ne = a && E.isVideoTexture !== !0,
        Qe = te.__version === void 0 || ee === !0;
      let L = M(E, ge, pe);
      Ae(r.TEXTURE_CUBE_MAP, E, pe);
      let ae;
      if (de) {
        Ne &&
          Qe &&
          t.texStorage2D(r.TEXTURE_CUBE_MAP, L, fe, ge.width, ge.height);
        for (let H = 0; H < 6; H++) {
          ae = G[H].mipmaps;
          for (let ie = 0; ie < ae.length; ie++) {
            const ce = ae[ie];
            E.format !== yn
              ? me !== null
                ? Ne
                  ? t.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                      ie,
                      0,
                      0,
                      ce.width,
                      ce.height,
                      me,
                      ce.data
                    )
                  : t.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                      ie,
                      fe,
                      ce.width,
                      ce.height,
                      0,
                      ce.data
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                  )
              : Ne
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  ie,
                  0,
                  0,
                  ce.width,
                  ce.height,
                  me,
                  ue,
                  ce.data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  ie,
                  fe,
                  ce.width,
                  ce.height,
                  0,
                  me,
                  ue,
                  ce.data
                );
          }
        }
      } else {
        (ae = E.mipmaps),
          Ne &&
            Qe &&
            (ae.length > 0 && L++,
            t.texStorage2D(r.TEXTURE_CUBE_MAP, L, fe, G[0].width, G[0].height));
        for (let H = 0; H < 6; H++)
          if (ne) {
            Ne
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  0,
                  0,
                  0,
                  G[H].width,
                  G[H].height,
                  me,
                  ue,
                  G[H].data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  0,
                  fe,
                  G[H].width,
                  G[H].height,
                  0,
                  me,
                  ue,
                  G[H].data
                );
            for (let ie = 0; ie < ae.length; ie++) {
              const We = ae[ie].image[H].image;
              Ne
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                    ie + 1,
                    0,
                    0,
                    We.width,
                    We.height,
                    me,
                    ue,
                    We.data
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                    ie + 1,
                    fe,
                    We.width,
                    We.height,
                    0,
                    me,
                    ue,
                    We.data
                  );
            }
          } else {
            Ne
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  0,
                  0,
                  0,
                  me,
                  ue,
                  G[H]
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  0,
                  fe,
                  me,
                  ue,
                  G[H]
                );
            for (let ie = 0; ie < ae.length; ie++) {
              const ce = ae[ie];
              Ne
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                    ie + 1,
                    0,
                    0,
                    me,
                    ue,
                    ce.image[H]
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                    ie + 1,
                    fe,
                    me,
                    ue,
                    ce.image[H]
                  );
            }
          }
      }
      b(E, pe) && T(r.TEXTURE_CUBE_MAP),
        (te.__version = Q.version),
        E.onUpdate && E.onUpdate(E);
    }
    R.__version = E.version;
  }
  function De(R, E, B, ee, Q, te) {
    const de = s.convert(B.format, B.colorSpace),
      ne = s.convert(B.type),
      G = C(B.internalFormat, de, ne, B.colorSpace);
    if (!n.get(E).__hasExternalTextures) {
      const pe = Math.max(1, E.width >> te),
        me = Math.max(1, E.height >> te);
      Q === r.TEXTURE_3D || Q === r.TEXTURE_2D_ARRAY
        ? t.texImage3D(Q, te, G, pe, me, E.depth, 0, de, ne, null)
        : t.texImage2D(Q, te, G, pe, me, 0, de, ne, null);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, R),
      Ke(E)
        ? u.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            ee,
            Q,
            n.get(B).__webglTexture,
            0,
            Ie(E)
          )
        : (Q === r.TEXTURE_2D ||
            (Q >= r.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Q <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            ee,
            Q,
            n.get(B).__webglTexture,
            te
          ),
      t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function O(R, E, B) {
    if (
      (r.bindRenderbuffer(r.RENDERBUFFER, R), E.depthBuffer && !E.stencilBuffer)
    ) {
      let ee = r.DEPTH_COMPONENT16;
      if (B || Ke(E)) {
        const Q = E.depthTexture;
        Q &&
          Q.isDepthTexture &&
          (Q.type === oi
            ? (ee = r.DEPTH_COMPONENT32F)
            : Q.type === Ci && (ee = r.DEPTH_COMPONENT24));
        const te = Ie(E);
        Ke(E)
          ? u.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              te,
              ee,
              E.width,
              E.height
            )
          : r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              te,
              ee,
              E.width,
              E.height
            );
      } else r.renderbufferStorage(r.RENDERBUFFER, ee, E.width, E.height);
      r.framebufferRenderbuffer(
        r.FRAMEBUFFER,
        r.DEPTH_ATTACHMENT,
        r.RENDERBUFFER,
        R
      );
    } else if (E.depthBuffer && E.stencilBuffer) {
      const ee = Ie(E);
      B && Ke(E) === !1
        ? r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            ee,
            r.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : Ke(E)
        ? u.renderbufferStorageMultisampleEXT(
            r.RENDERBUFFER,
            ee,
            r.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : r.renderbufferStorage(
            r.RENDERBUFFER,
            r.DEPTH_STENCIL,
            E.width,
            E.height
          ),
        r.framebufferRenderbuffer(
          r.FRAMEBUFFER,
          r.DEPTH_STENCIL_ATTACHMENT,
          r.RENDERBUFFER,
          R
        );
    } else {
      const ee =
        E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
      for (let Q = 0; Q < ee.length; Q++) {
        const te = ee[Q],
          de = s.convert(te.format, te.colorSpace),
          ne = s.convert(te.type),
          G = C(te.internalFormat, de, ne, te.colorSpace),
          ge = Ie(E);
        B && Ke(E) === !1
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              ge,
              G,
              E.width,
              E.height
            )
          : Ke(E)
          ? u.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              ge,
              G,
              E.width,
              E.height
            )
          : r.renderbufferStorage(r.RENDERBUFFER, G, E.width, E.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function Pt(R, E) {
    if (E && E.isWebGLCubeRenderTarget)
      throw new Error(
        'Depth Texture with cube render targets is not supported'
      );
    if (
      (t.bindFramebuffer(r.FRAMEBUFFER, R),
      !(E.depthTexture && E.depthTexture.isDepthTexture))
    )
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
      );
    (!n.get(E.depthTexture).__webglTexture ||
      E.depthTexture.image.width !== E.width ||
      E.depthTexture.image.height !== E.height) &&
      ((E.depthTexture.image.width = E.width),
      (E.depthTexture.image.height = E.height),
      (E.depthTexture.needsUpdate = !0)),
      $(E.depthTexture, 0);
    const ee = n.get(E.depthTexture).__webglTexture,
      Q = Ie(E);
    if (E.depthTexture.format === fr)
      Ke(E)
        ? u.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ee,
            0,
            Q
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ee,
            0
          );
    else if (E.depthTexture.format === ls)
      Ke(E)
        ? u.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ee,
            0,
            Q
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ee,
            0
          );
    else throw new Error('Unknown depthTexture format');
  }
  function xe(R) {
    const E = n.get(R),
      B = R.isWebGLCubeRenderTarget === !0;
    if (R.depthTexture && !E.__autoAllocateDepthBuffer) {
      if (B)
        throw new Error(
          'target.depthTexture not supported in Cube render targets'
        );
      Pt(E.__webglFramebuffer, R);
    } else if (B) {
      E.__webglDepthbuffer = [];
      for (let ee = 0; ee < 6; ee++)
        t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer[ee]),
          (E.__webglDepthbuffer[ee] = r.createRenderbuffer()),
          O(E.__webglDepthbuffer[ee], R, !1);
    } else
      t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer),
        (E.__webglDepthbuffer = r.createRenderbuffer()),
        O(E.__webglDepthbuffer, R, !1);
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Ce(R, E, B) {
    const ee = n.get(R);
    E !== void 0 &&
      De(
        ee.__webglFramebuffer,
        R,
        R.texture,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D,
        0
      ),
      B !== void 0 && xe(R);
  }
  function Te(R) {
    const E = R.texture,
      B = n.get(R),
      ee = n.get(E);
    R.addEventListener('dispose', Y),
      R.isWebGLMultipleRenderTargets !== !0 &&
        (ee.__webglTexture === void 0 &&
          (ee.__webglTexture = r.createTexture()),
        (ee.__version = E.version),
        o.memory.textures++);
    const Q = R.isWebGLCubeRenderTarget === !0,
      te = R.isWebGLMultipleRenderTargets === !0,
      de = x(R) || a;
    if (Q) {
      B.__webglFramebuffer = [];
      for (let ne = 0; ne < 6; ne++)
        if (a && E.mipmaps && E.mipmaps.length > 0) {
          B.__webglFramebuffer[ne] = [];
          for (let G = 0; G < E.mipmaps.length; G++)
            B.__webglFramebuffer[ne][G] = r.createFramebuffer();
        } else B.__webglFramebuffer[ne] = r.createFramebuffer();
    } else {
      if (a && E.mipmaps && E.mipmaps.length > 0) {
        B.__webglFramebuffer = [];
        for (let ne = 0; ne < E.mipmaps.length; ne++)
          B.__webglFramebuffer[ne] = r.createFramebuffer();
      } else B.__webglFramebuffer = r.createFramebuffer();
      if (te)
        if (i.drawBuffers) {
          const ne = R.texture;
          for (let G = 0, ge = ne.length; G < ge; G++) {
            const pe = n.get(ne[G]);
            pe.__webglTexture === void 0 &&
              ((pe.__webglTexture = r.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
          );
      if (a && R.samples > 0 && Ke(R) === !1) {
        const ne = te ? E : [E];
        (B.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (B.__webglColorRenderbuffer = []),
          t.bindFramebuffer(r.FRAMEBUFFER, B.__webglMultisampledFramebuffer);
        for (let G = 0; G < ne.length; G++) {
          const ge = ne[G];
          (B.__webglColorRenderbuffer[G] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, B.__webglColorRenderbuffer[G]);
          const pe = s.convert(ge.format, ge.colorSpace),
            me = s.convert(ge.type),
            ue = C(
              ge.internalFormat,
              pe,
              me,
              ge.colorSpace,
              R.isXRRenderTarget === !0
            ),
            fe = Ie(R);
          r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            fe,
            ue,
            R.width,
            R.height
          ),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + G,
              r.RENDERBUFFER,
              B.__webglColorRenderbuffer[G]
            );
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          R.depthBuffer &&
            ((B.__webglDepthRenderbuffer = r.createRenderbuffer()),
            O(B.__webglDepthRenderbuffer, R, !0)),
          t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (Q) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, ee.__webglTexture),
        Ae(r.TEXTURE_CUBE_MAP, E, de);
      for (let ne = 0; ne < 6; ne++)
        if (a && E.mipmaps && E.mipmaps.length > 0)
          for (let G = 0; G < E.mipmaps.length; G++)
            De(
              B.__webglFramebuffer[ne][G],
              R,
              E,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_CUBE_MAP_POSITIVE_X + ne,
              G
            );
        else
          De(
            B.__webglFramebuffer[ne],
            R,
            E,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_CUBE_MAP_POSITIVE_X + ne,
            0
          );
      b(E, de) && T(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (te) {
      const ne = R.texture;
      for (let G = 0, ge = ne.length; G < ge; G++) {
        const pe = ne[G],
          me = n.get(pe);
        t.bindTexture(r.TEXTURE_2D, me.__webglTexture),
          Ae(r.TEXTURE_2D, pe, de),
          De(
            B.__webglFramebuffer,
            R,
            pe,
            r.COLOR_ATTACHMENT0 + G,
            r.TEXTURE_2D,
            0
          ),
          b(pe, de) && T(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ne = r.TEXTURE_2D;
      if (
        ((R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) &&
          (a
            ? (ne = R.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY)
            : console.error(
                'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
              )),
        t.bindTexture(ne, ee.__webglTexture),
        Ae(ne, E, de),
        a && E.mipmaps && E.mipmaps.length > 0)
      )
        for (let G = 0; G < E.mipmaps.length; G++)
          De(B.__webglFramebuffer[G], R, E, r.COLOR_ATTACHMENT0, ne, G);
      else De(B.__webglFramebuffer, R, E, r.COLOR_ATTACHMENT0, ne, 0);
      b(E, de) && T(ne), t.unbindTexture();
    }
    R.depthBuffer && xe(R);
  }
  function tt(R) {
    const E = x(R) || a,
      B = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
    for (let ee = 0, Q = B.length; ee < Q; ee++) {
      const te = B[ee];
      if (b(te, E)) {
        const de = R.isWebGLCubeRenderTarget
            ? r.TEXTURE_CUBE_MAP
            : r.TEXTURE_2D,
          ne = n.get(te).__webglTexture;
        t.bindTexture(de, ne), T(de), t.unbindTexture();
      }
    }
  }
  function Be(R) {
    if (a && R.samples > 0 && Ke(R) === !1) {
      const E = R.isWebGLMultipleRenderTargets ? R.texture : [R.texture],
        B = R.width,
        ee = R.height;
      let Q = r.COLOR_BUFFER_BIT;
      const te = [],
        de = R.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        ne = n.get(R),
        G = R.isWebGLMultipleRenderTargets === !0;
      if (G)
        for (let ge = 0; ge < E.length; ge++)
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(r.READ_FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ne.__webglFramebuffer);
      for (let ge = 0; ge < E.length; ge++) {
        te.push(r.COLOR_ATTACHMENT0 + ge), R.depthBuffer && te.push(de);
        const pe =
          ne.__ignoreDepthValues !== void 0 ? ne.__ignoreDepthValues : !1;
        if (
          (pe === !1 &&
            (R.depthBuffer && (Q |= r.DEPTH_BUFFER_BIT),
            R.stencilBuffer && (Q |= r.STENCIL_BUFFER_BIT)),
          G &&
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              ne.__webglColorRenderbuffer[ge]
            ),
          pe === !0 &&
            (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [de]),
            r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [de])),
          G)
        ) {
          const me = n.get(E[ge]).__webglTexture;
          r.framebufferTexture2D(
            r.DRAW_FRAMEBUFFER,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_2D,
            me,
            0
          );
        }
        r.blitFramebuffer(0, 0, B, ee, 0, 0, B, ee, Q, r.NEAREST),
          p && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, te);
      }
      if (
        (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        G)
      )
        for (let ge = 0; ge < E.length; ge++) {
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.RENDERBUFFER,
              ne.__webglColorRenderbuffer[ge]
            );
          const pe = n.get(E[ge]).__webglTexture;
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.TEXTURE_2D,
              pe,
              0
            );
        }
      t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ne.__webglMultisampledFramebuffer);
    }
  }
  function Ie(R) {
    return Math.min(f, R.samples);
  }
  function Ke(R) {
    const E = n.get(R);
    return (
      a &&
      R.samples > 0 &&
      e.has('WEBGL_multisampled_render_to_texture') === !0 &&
      E.__useRenderToTexture !== !1
    );
  }
  function At(R) {
    const E = o.render.frame;
    _.get(R) !== E && (_.set(R, E), R.update());
  }
  function Dt(R, E) {
    const B = R.colorSpace,
      ee = R.format,
      Q = R.type;
    return (
      R.isCompressedTexture === !0 ||
        R.isVideoTexture === !0 ||
        R.format === rl ||
        (B !== _t &&
          B !== pr &&
          (B === qe || B === ya
            ? a === !1
              ? e.has('EXT_sRGB') === !0 && ee === yn
                ? ((R.format = rl),
                  (R.minFilter = jt),
                  (R.generateMipmaps = !1))
                : (E = Sp.sRGBToLinear(E))
              : (ee !== yn || Q !== Oi) &&
                console.warn(
                  'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                )
            : console.error(
                'THREE.WebGLTextures: Unsupported texture color space:',
                B
              ))),
      E
    );
  }
  (this.allocateTextureUnit = j),
    (this.resetTextureUnits = z),
    (this.setTexture2D = $),
    (this.setTexture2DArray = k),
    (this.setTexture3D = V),
    (this.setTextureCube = oe),
    (this.rebindTextures = Ce),
    (this.setupRenderTarget = Te),
    (this.updateRenderTargetMipmap = tt),
    (this.updateMultisampleRenderTarget = Be),
    (this.setupDepthRenderbuffer = xe),
    (this.setupFrameBufferTexture = De),
    (this.useMultisampledRTT = Ke);
}
const Eb = 0,
  vt = 1;
function Tb(r, e, t) {
  const n = t.isWebGL2;
  function i(s, o = pr) {
    let a;
    const c = o === qe || o === ya ? vt : Eb;
    if (s === Oi) return r.UNSIGNED_BYTE;
    if (s === fp) return r.UNSIGNED_SHORT_4_4_4_4;
    if (s === dp) return r.UNSIGNED_SHORT_5_5_5_1;
    if (s === H0) return r.BYTE;
    if (s === G0) return r.SHORT;
    if (s === Gl) return r.UNSIGNED_SHORT;
    if (s === up) return r.INT;
    if (s === Ci) return r.UNSIGNED_INT;
    if (s === oi) return r.FLOAT;
    if (s === Qs)
      return n
        ? r.HALF_FLOAT
        : ((a = e.get('OES_texture_half_float')),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === V0) return r.ALPHA;
    if (s === yn) return r.RGBA;
    if (s === W0) return r.LUMINANCE;
    if (s === q0) return r.LUMINANCE_ALPHA;
    if (s === fr) return r.DEPTH_COMPONENT;
    if (s === ls) return r.DEPTH_STENCIL;
    if (s === rl)
      return (a = e.get('EXT_sRGB')), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === X0) return r.RED;
    if (s === pp) return r.RED_INTEGER;
    if (s === j0) return r.RG;
    if (s === mp) return r.RG_INTEGER;
    if (s === gp) return r.RGBA_INTEGER;
    if (s === Va || s === Wa || s === qa || s === Xa)
      if (c === vt)
        if (((a = e.get('WEBGL_compressed_texture_s3tc_srgb')), a !== null)) {
          if (s === Va) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Wa) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === qa) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Xa) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get('WEBGL_compressed_texture_s3tc')), a !== null)) {
        if (s === Va) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Wa) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === qa) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Xa) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Yh || s === Kh || s === $h || s === Zh)
      if (((a = e.get('WEBGL_compressed_texture_pvrtc')), a !== null)) {
        if (s === Yh) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Kh) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === $h) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Zh) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === Y0)
      return (
        (a = e.get('WEBGL_compressed_texture_etc1')),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Jh || s === Qh)
      if (((a = e.get('WEBGL_compressed_texture_etc')), a !== null)) {
        if (s === Jh)
          return c === vt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Qh)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === eu ||
      s === tu ||
      s === nu ||
      s === iu ||
      s === ru ||
      s === su ||
      s === ou ||
      s === au ||
      s === cu ||
      s === lu ||
      s === hu ||
      s === uu ||
      s === fu ||
      s === du
    )
      if (((a = e.get('WEBGL_compressed_texture_astc')), a !== null)) {
        if (s === eu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === tu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === nu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === iu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === ru)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === su)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === ou)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === au)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === cu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === lu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === hu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === uu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === fu)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === du)
          return c === vt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === ja || s === pu || s === mu)
      if (((a = e.get('EXT_texture_compression_bptc')), a !== null)) {
        if (s === ja)
          return c === vt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === pu) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === mu) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === K0 || s === gu || s === _u || s === vu)
      if (((a = e.get('EXT_texture_compression_rgtc')), a !== null)) {
        if (s === ja) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === gu) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === _u) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === vu) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ur
      ? n
        ? r.UNSIGNED_INT_24_8
        : ((a = e.get('WEBGL_depth_texture')),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : r[s] !== void 0
      ? r[s]
      : null;
  }
  return { convert: i };
}
class Ab extends Wt {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class sr extends st {
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group');
  }
}
const wb = { type: 'move' };
class gc {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new sr()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new sr()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new P()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new P())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new sr()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new P()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new P())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: 'connected', data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      s = null,
      o = null;
    const a = this._targetRay,
      c = this._grip,
      l = this._hand;
    if (e && t.session.visibilityState !== 'visible-blurred') {
      if (l && e.hand) {
        o = !0;
        for (const g of e.hand.values()) {
          const d = t.getJointPose(g, n),
            m = this._getHandJoint(l, g);
          d !== null &&
            (m.matrix.fromArray(d.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.matrixWorldNeedsUpdate = !0),
            (m.jointRadius = d.radius)),
            (m.visible = d !== null);
        }
        const h = l.joints['index-finger-tip'],
          f = l.joints['thumb-tip'],
          u = h.position.distanceTo(f.position),
          p = 0.02,
          _ = 0.005;
        l.inputState.pinching && u > p + _
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({
              type: 'pinchend',
              handedness: e.handedness,
              target: this
            }))
          : !l.inputState.pinching &&
            u <= p - _ &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: e.handedness,
              target: this
            }));
      } else
        c !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (c.matrix.fromArray(s.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            (c.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((c.hasLinearVelocity = !0),
                c.linearVelocity.copy(s.linearVelocity))
              : (c.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((c.hasAngularVelocity = !0),
                c.angularVelocity.copy(s.angularVelocity))
              : (c.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && s !== null && (i = s),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(wb)));
    }
    return (
      a !== null && (a.visible = i !== null),
      c !== null && (c.visible = s !== null),
      l !== null && (l.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new sr();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Rb extends Ct {
  constructor(e, t, n, i, s, o, a, c, l, h) {
    if (((h = h !== void 0 ? h : fr), h !== fr && h !== ls))
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      );
    n === void 0 && h === fr && (n = Ci),
      n === void 0 && h === ls && (n = ur),
      super(null, i, s, o, a, c, h, n, l),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : Et),
      (this.minFilter = c !== void 0 ? c : Et),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Cb extends _s {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      s = 1,
      o = null,
      a = 'local-floor',
      c = 1,
      l = null,
      h = null,
      f = null,
      u = null,
      p = null,
      _ = null;
    const g = t.getContextAttributes();
    let d = null,
      m = null;
    const y = [],
      v = [],
      x = new Wt();
    x.layers.enable(1), (x.viewport = new Je());
    const S = new Wt();
    S.layers.enable(2), (S.viewport = new Je());
    const b = [x, S],
      T = new Ab();
    T.layers.enable(1), T.layers.enable(2);
    let C = null,
      M = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (k) {
        let V = y[k];
        return (
          V === void 0 && ((V = new gc()), (y[k] = V)), V.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (k) {
        let V = y[k];
        return V === void 0 && ((V = new gc()), (y[k] = V)), V.getGripSpace();
      }),
      (this.getHand = function (k) {
        let V = y[k];
        return V === void 0 && ((V = new gc()), (y[k] = V)), V.getHandSpace();
      });
    function A(k) {
      const V = v.indexOf(k.inputSource);
      if (V === -1) return;
      const oe = y[V];
      oe !== void 0 &&
        (oe.update(k.inputSource, k.frame, l || o),
        oe.dispatchEvent({ type: k.type, data: k.inputSource }));
    }
    function X() {
      i.removeEventListener('select', A),
        i.removeEventListener('selectstart', A),
        i.removeEventListener('selectend', A),
        i.removeEventListener('squeeze', A),
        i.removeEventListener('squeezestart', A),
        i.removeEventListener('squeezeend', A),
        i.removeEventListener('end', X),
        i.removeEventListener('inputsourceschange', Y);
      for (let k = 0; k < y.length; k++) {
        const V = v[k];
        V !== null && ((v[k] = null), y[k].disconnect(V));
      }
      (C = null),
        (M = null),
        e.setRenderTarget(d),
        (p = null),
        (u = null),
        (f = null),
        (i = null),
        (m = null),
        $.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: 'sessionend' });
    }
    (this.setFramebufferScaleFactor = function (k) {
      (s = k),
        n.isPresenting === !0 &&
          console.warn(
            'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
          );
    }),
      (this.setReferenceSpaceType = function (k) {
        (a = k),
          n.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.'
            );
      }),
      (this.getReferenceSpace = function () {
        return l || o;
      }),
      (this.setReferenceSpace = function (k) {
        l = k;
      }),
      (this.getBaseLayer = function () {
        return u !== null ? u : p;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (k) {
        if (((i = k), i !== null)) {
          if (
            ((d = e.getRenderTarget()),
            i.addEventListener('select', A),
            i.addEventListener('selectstart', A),
            i.addEventListener('selectend', A),
            i.addEventListener('squeeze', A),
            i.addEventListener('squeezestart', A),
            i.addEventListener('squeezeend', A),
            i.addEventListener('end', X),
            i.addEventListener('inputsourceschange', Y),
            g.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const V = {
              antialias: i.renderState.layers === void 0 ? g.antialias : !0,
              alpha: !0,
              depth: g.depth,
              stencil: g.stencil,
              framebufferScaleFactor: s
            };
            (p = new XRWebGLLayer(i, t, V)),
              i.updateRenderState({ baseLayer: p }),
              (m = new _r(p.framebufferWidth, p.framebufferHeight, {
                format: yn,
                type: Oi,
                colorSpace: e.outputColorSpace,
                stencilBuffer: g.stencil
              }));
          } else {
            let V = null,
              oe = null,
              re = null;
            g.depth &&
              ((re = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (V = g.stencil ? ls : fr),
              (oe = g.stencil ? ur : Ci));
            const le = {
              colorFormat: t.RGBA8,
              depthFormat: re,
              scaleFactor: s
            };
            (f = new XRWebGLBinding(i, t)),
              (u = f.createProjectionLayer(le)),
              i.updateRenderState({ layers: [u] }),
              (m = new _r(u.textureWidth, u.textureHeight, {
                format: yn,
                type: Oi,
                depthTexture: new Rb(
                  u.textureWidth,
                  u.textureHeight,
                  oe,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  V
                ),
                stencilBuffer: g.stencil,
                colorSpace: e.outputColorSpace,
                samples: g.antialias ? 4 : 0
              }));
            const ve = e.properties.get(m);
            ve.__ignoreDepthValues = u.ignoreDepthValues;
          }
          (m.isXRRenderTarget = !0),
            this.setFoveation(c),
            (l = null),
            (o = await i.requestReferenceSpace(a)),
            $.setContext(i),
            $.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: 'sessionstart' });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function Y(k) {
      for (let V = 0; V < k.removed.length; V++) {
        const oe = k.removed[V],
          re = v.indexOf(oe);
        re >= 0 && ((v[re] = null), y[re].disconnect(oe));
      }
      for (let V = 0; V < k.added.length; V++) {
        const oe = k.added[V];
        let re = v.indexOf(oe);
        if (re === -1) {
          for (let ve = 0; ve < y.length; ve++)
            if (ve >= v.length) {
              v.push(oe), (re = ve);
              break;
            } else if (v[ve] === null) {
              (v[ve] = oe), (re = ve);
              break;
            }
          if (re === -1) break;
        }
        const le = y[re];
        le && le.connect(oe);
      }
    }
    const D = new P(),
      F = new P();
    function N(k, V, oe) {
      D.setFromMatrixPosition(V.matrixWorld),
        F.setFromMatrixPosition(oe.matrixWorld);
      const re = D.distanceTo(F),
        le = V.projectionMatrix.elements,
        ve = oe.projectionMatrix.elements,
        Ae = le[14] / (le[10] - 1),
        ye = le[14] / (le[10] + 1),
        Xe = (le[9] + 1) / le[5],
        qt = (le[9] - 1) / le[5],
        De = (le[8] - 1) / le[0],
        O = (ve[8] + 1) / ve[0],
        Pt = Ae * De,
        xe = Ae * O,
        Ce = re / (-De + O),
        Te = Ce * -De;
      V.matrixWorld.decompose(k.position, k.quaternion, k.scale),
        k.translateX(Te),
        k.translateZ(Ce),
        k.matrixWorld.compose(k.position, k.quaternion, k.scale),
        k.matrixWorldInverse.copy(k.matrixWorld).invert();
      const tt = Ae + Ce,
        Be = ye + Ce,
        Ie = Pt - Te,
        Ke = xe + (re - Te),
        At = ((Xe * ye) / Be) * tt,
        Dt = ((qt * ye) / Be) * tt;
      k.projectionMatrix.makePerspective(Ie, Ke, At, Dt, tt, Be),
        k.projectionMatrixInverse.copy(k.projectionMatrix).invert();
    }
    function K(k, V) {
      V === null
        ? k.matrixWorld.copy(k.matrix)
        : k.matrixWorld.multiplyMatrices(V.matrixWorld, k.matrix),
        k.matrixWorldInverse.copy(k.matrixWorld).invert();
    }
    this.updateCamera = function (k) {
      if (i === null) return;
      (T.near = S.near = x.near = k.near),
        (T.far = S.far = x.far = k.far),
        (C !== T.near || M !== T.far) &&
          (i.updateRenderState({ depthNear: T.near, depthFar: T.far }),
          (C = T.near),
          (M = T.far));
      const V = k.parent,
        oe = T.cameras;
      K(T, V);
      for (let re = 0; re < oe.length; re++) K(oe[re], V);
      oe.length === 2
        ? N(T, x, S)
        : T.projectionMatrix.copy(x.projectionMatrix),
        z(k, T, V);
    };
    function z(k, V, oe) {
      oe === null
        ? k.matrix.copy(V.matrixWorld)
        : (k.matrix.copy(oe.matrixWorld),
          k.matrix.invert(),
          k.matrix.multiply(V.matrixWorld)),
        k.matrix.decompose(k.position, k.quaternion, k.scale),
        k.updateMatrixWorld(!0),
        k.projectionMatrix.copy(V.projectionMatrix),
        k.projectionMatrixInverse.copy(V.projectionMatrixInverse),
        k.isPerspectiveCamera &&
          ((k.fov = us * 2 * Math.atan(1 / k.projectionMatrix.elements[5])),
          (k.zoom = 1));
    }
    (this.getCamera = function () {
      return T;
    }),
      (this.getFoveation = function () {
        if (!(u === null && p === null)) return c;
      }),
      (this.setFoveation = function (k) {
        (c = k),
          u !== null && (u.fixedFoveation = k),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = k);
      });
    let j = null;
    function J(k, V) {
      if (((h = V.getViewerPose(l || o)), (_ = V), h !== null)) {
        const oe = h.views;
        p !== null &&
          (e.setRenderTargetFramebuffer(m, p.framebuffer),
          e.setRenderTarget(m));
        let re = !1;
        oe.length !== T.cameras.length && ((T.cameras.length = 0), (re = !0));
        for (let le = 0; le < oe.length; le++) {
          const ve = oe[le];
          let Ae = null;
          if (p !== null) Ae = p.getViewport(ve);
          else {
            const Xe = f.getViewSubImage(u, ve);
            (Ae = Xe.viewport),
              le === 0 &&
                (e.setRenderTargetTextures(
                  m,
                  Xe.colorTexture,
                  u.ignoreDepthValues ? void 0 : Xe.depthStencilTexture
                ),
                e.setRenderTarget(m));
          }
          let ye = b[le];
          ye === void 0 &&
            ((ye = new Wt()),
            ye.layers.enable(le),
            (ye.viewport = new Je()),
            (b[le] = ye)),
            ye.matrix.fromArray(ve.transform.matrix),
            ye.matrix.decompose(ye.position, ye.quaternion, ye.scale),
            ye.projectionMatrix.fromArray(ve.projectionMatrix),
            ye.projectionMatrixInverse.copy(ye.projectionMatrix).invert(),
            ye.viewport.set(Ae.x, Ae.y, Ae.width, Ae.height),
            le === 0 &&
              (T.matrix.copy(ye.matrix),
              T.matrix.decompose(T.position, T.quaternion, T.scale)),
            re === !0 && T.cameras.push(ye);
        }
      }
      for (let oe = 0; oe < y.length; oe++) {
        const re = v[oe],
          le = y[oe];
        re !== null && le !== void 0 && le.update(re, V, l || o);
      }
      j && j(k, V),
        V.detectedPlanes &&
          n.dispatchEvent({ type: 'planesdetected', data: V }),
        (_ = null);
    }
    const $ = new Dp();
    $.setAnimationLoop(J),
      (this.setAnimationLoop = function (k) {
        j = k;
      }),
      (this.dispose = function () {});
  }
}
function Lb(r, e) {
  function t(d, m) {
    d.matrixAutoUpdate === !0 && d.updateMatrix(), m.value.copy(d.matrix);
  }
  function n(d, m) {
    m.color.getRGB(d.fogColor.value, Cp(r)),
      m.isFog
        ? ((d.fogNear.value = m.near), (d.fogFar.value = m.far))
        : m.isFogExp2 && (d.fogDensity.value = m.density);
  }
  function i(d, m, y, v, x) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? s(d, m)
      : m.isMeshToonMaterial
      ? (s(d, m), f(d, m))
      : m.isMeshPhongMaterial
      ? (s(d, m), h(d, m))
      : m.isMeshStandardMaterial
      ? (s(d, m), u(d, m), m.isMeshPhysicalMaterial && p(d, m, x))
      : m.isMeshMatcapMaterial
      ? (s(d, m), _(d, m))
      : m.isMeshDepthMaterial
      ? s(d, m)
      : m.isMeshDistanceMaterial
      ? (s(d, m), g(d, m))
      : m.isMeshNormalMaterial
      ? s(d, m)
      : m.isLineBasicMaterial
      ? (o(d, m), m.isLineDashedMaterial && a(d, m))
      : m.isPointsMaterial
      ? c(d, m, y, v)
      : m.isSpriteMaterial
      ? l(d, m)
      : m.isShadowMaterial
      ? (d.color.value.copy(m.color), (d.opacity.value = m.opacity))
      : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function s(d, m) {
    (d.opacity.value = m.opacity),
      m.color && d.diffuse.value.copy(m.color),
      m.emissive &&
        d.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((d.map.value = m.map), t(m.map, d.mapTransform)),
      m.alphaMap &&
        ((d.alphaMap.value = m.alphaMap), t(m.alphaMap, d.alphaMapTransform)),
      m.bumpMap &&
        ((d.bumpMap.value = m.bumpMap),
        t(m.bumpMap, d.bumpMapTransform),
        (d.bumpScale.value = m.bumpScale),
        m.side === Jt && (d.bumpScale.value *= -1)),
      m.normalMap &&
        ((d.normalMap.value = m.normalMap),
        t(m.normalMap, d.normalMapTransform),
        d.normalScale.value.copy(m.normalScale),
        m.side === Jt && d.normalScale.value.negate()),
      m.displacementMap &&
        ((d.displacementMap.value = m.displacementMap),
        t(m.displacementMap, d.displacementMapTransform),
        (d.displacementScale.value = m.displacementScale),
        (d.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((d.emissiveMap.value = m.emissiveMap),
        t(m.emissiveMap, d.emissiveMapTransform)),
      m.specularMap &&
        ((d.specularMap.value = m.specularMap),
        t(m.specularMap, d.specularMapTransform)),
      m.alphaTest > 0 && (d.alphaTest.value = m.alphaTest);
    const y = e.get(m).envMap;
    if (
      (y &&
        ((d.envMap.value = y),
        (d.flipEnvMap.value =
          y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
        (d.reflectivity.value = m.reflectivity),
        (d.ior.value = m.ior),
        (d.refractionRatio.value = m.refractionRatio)),
      m.lightMap)
    ) {
      d.lightMap.value = m.lightMap;
      const v = r._useLegacyLights === !0 ? Math.PI : 1;
      (d.lightMapIntensity.value = m.lightMapIntensity * v),
        t(m.lightMap, d.lightMapTransform);
    }
    m.aoMap &&
      ((d.aoMap.value = m.aoMap),
      (d.aoMapIntensity.value = m.aoMapIntensity),
      t(m.aoMap, d.aoMapTransform));
  }
  function o(d, m) {
    d.diffuse.value.copy(m.color),
      (d.opacity.value = m.opacity),
      m.map && ((d.map.value = m.map), t(m.map, d.mapTransform));
  }
  function a(d, m) {
    (d.dashSize.value = m.dashSize),
      (d.totalSize.value = m.dashSize + m.gapSize),
      (d.scale.value = m.scale);
  }
  function c(d, m, y, v) {
    d.diffuse.value.copy(m.color),
      (d.opacity.value = m.opacity),
      (d.size.value = m.size * y),
      (d.scale.value = v * 0.5),
      m.map && ((d.map.value = m.map), t(m.map, d.uvTransform)),
      m.alphaMap &&
        ((d.alphaMap.value = m.alphaMap), t(m.alphaMap, d.alphaMapTransform)),
      m.alphaTest > 0 && (d.alphaTest.value = m.alphaTest);
  }
  function l(d, m) {
    d.diffuse.value.copy(m.color),
      (d.opacity.value = m.opacity),
      (d.rotation.value = m.rotation),
      m.map && ((d.map.value = m.map), t(m.map, d.mapTransform)),
      m.alphaMap &&
        ((d.alphaMap.value = m.alphaMap), t(m.alphaMap, d.alphaMapTransform)),
      m.alphaTest > 0 && (d.alphaTest.value = m.alphaTest);
  }
  function h(d, m) {
    d.specular.value.copy(m.specular),
      (d.shininess.value = Math.max(m.shininess, 1e-4));
  }
  function f(d, m) {
    m.gradientMap && (d.gradientMap.value = m.gradientMap);
  }
  function u(d, m) {
    (d.metalness.value = m.metalness),
      m.metalnessMap &&
        ((d.metalnessMap.value = m.metalnessMap),
        t(m.metalnessMap, d.metalnessMapTransform)),
      (d.roughness.value = m.roughness),
      m.roughnessMap &&
        ((d.roughnessMap.value = m.roughnessMap),
        t(m.roughnessMap, d.roughnessMapTransform)),
      e.get(m).envMap && (d.envMapIntensity.value = m.envMapIntensity);
  }
  function p(d, m, y) {
    (d.ior.value = m.ior),
      m.sheen > 0 &&
        (d.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (d.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((d.sheenColorMap.value = m.sheenColorMap),
          t(m.sheenColorMap, d.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((d.sheenRoughnessMap.value = m.sheenRoughnessMap),
          t(m.sheenRoughnessMap, d.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((d.clearcoat.value = m.clearcoat),
        (d.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((d.clearcoatMap.value = m.clearcoatMap),
          t(m.clearcoatMap, d.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((d.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          t(m.clearcoatRoughnessMap, d.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((d.clearcoatNormalMap.value = m.clearcoatNormalMap),
          t(m.clearcoatNormalMap, d.clearcoatNormalMapTransform),
          d.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === Jt && d.clearcoatNormalScale.value.negate())),
      m.iridescence > 0 &&
        ((d.iridescence.value = m.iridescence),
        (d.iridescenceIOR.value = m.iridescenceIOR),
        (d.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (d.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((d.iridescenceMap.value = m.iridescenceMap),
          t(m.iridescenceMap, d.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((d.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          t(m.iridescenceThicknessMap, d.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((d.transmission.value = m.transmission),
        (d.transmissionSamplerMap.value = y.texture),
        d.transmissionSamplerSize.value.set(y.width, y.height),
        m.transmissionMap &&
          ((d.transmissionMap.value = m.transmissionMap),
          t(m.transmissionMap, d.transmissionMapTransform)),
        (d.thickness.value = m.thickness),
        m.thicknessMap &&
          ((d.thicknessMap.value = m.thicknessMap),
          t(m.thicknessMap, d.thicknessMapTransform)),
        (d.attenuationDistance.value = m.attenuationDistance),
        d.attenuationColor.value.copy(m.attenuationColor)),
      m.anisotropy > 0 &&
        (d.anisotropyVector.value.set(
          m.anisotropy * Math.cos(m.anisotropyRotation),
          m.anisotropy * Math.sin(m.anisotropyRotation)
        ),
        m.anisotropyMap &&
          ((d.anisotropyMap.value = m.anisotropyMap),
          t(m.anisotropyMap, d.anisotropyMapTransform))),
      (d.specularIntensity.value = m.specularIntensity),
      d.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((d.specularColorMap.value = m.specularColorMap),
        t(m.specularColorMap, d.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((d.specularIntensityMap.value = m.specularIntensityMap),
        t(m.specularIntensityMap, d.specularIntensityMapTransform));
  }
  function _(d, m) {
    m.matcap && (d.matcap.value = m.matcap);
  }
  function g(d, m) {
    const y = e.get(m).light;
    d.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (d.nearDistance.value = y.shadow.camera.near),
      (d.farDistance.value = y.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function Pb(r, e, t, n) {
  let i = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(y, v) {
    const x = v.program;
    n.uniformBlockBinding(y, x);
  }
  function l(y, v) {
    let x = i[y.id];
    x === void 0 &&
      (_(y), (x = h(y)), (i[y.id] = x), y.addEventListener('dispose', d));
    const S = v.program;
    n.updateUBOMapping(y, S);
    const b = e.render.frame;
    s[y.id] !== b && (u(y), (s[y.id] = b));
  }
  function h(y) {
    const v = f();
    y.__bindingPointIndex = v;
    const x = r.createBuffer(),
      S = y.__size,
      b = y.usage;
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, x),
      r.bufferData(r.UNIFORM_BUFFER, S, b),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, v, x),
      x
    );
  }
  function f() {
    for (let y = 0; y < a; y++) if (o.indexOf(y) === -1) return o.push(y), y;
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
      ),
      0
    );
  }
  function u(y) {
    const v = i[y.id],
      x = y.uniforms,
      S = y.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, v);
    for (let b = 0, T = x.length; b < T; b++) {
      const C = x[b];
      if (p(C, b, S) === !0) {
        const M = C.__offset,
          A = Array.isArray(C.value) ? C.value : [C.value];
        let X = 0;
        for (let Y = 0; Y < A.length; Y++) {
          const D = A[Y],
            F = g(D);
          typeof D == 'number'
            ? ((C.__data[0] = D),
              r.bufferSubData(r.UNIFORM_BUFFER, M + X, C.__data))
            : D.isMatrix3
            ? ((C.__data[0] = D.elements[0]),
              (C.__data[1] = D.elements[1]),
              (C.__data[2] = D.elements[2]),
              (C.__data[3] = D.elements[0]),
              (C.__data[4] = D.elements[3]),
              (C.__data[5] = D.elements[4]),
              (C.__data[6] = D.elements[5]),
              (C.__data[7] = D.elements[0]),
              (C.__data[8] = D.elements[6]),
              (C.__data[9] = D.elements[7]),
              (C.__data[10] = D.elements[8]),
              (C.__data[11] = D.elements[0]))
            : (D.toArray(C.__data, X),
              (X += F.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        r.bufferSubData(r.UNIFORM_BUFFER, M, C.__data);
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function p(y, v, x) {
    const S = y.value;
    if (x[v] === void 0) {
      if (typeof S == 'number') x[v] = S;
      else {
        const b = Array.isArray(S) ? S : [S],
          T = [];
        for (let C = 0; C < b.length; C++) T.push(b[C].clone());
        x[v] = T;
      }
      return !0;
    } else if (typeof S == 'number') {
      if (x[v] !== S) return (x[v] = S), !0;
    } else {
      const b = Array.isArray(x[v]) ? x[v] : [x[v]],
        T = Array.isArray(S) ? S : [S];
      for (let C = 0; C < b.length; C++) {
        const M = b[C];
        if (M.equals(T[C]) === !1) return M.copy(T[C]), !0;
      }
    }
    return !1;
  }
  function _(y) {
    const v = y.uniforms;
    let x = 0;
    const S = 16;
    let b = 0;
    for (let T = 0, C = v.length; T < C; T++) {
      const M = v[T],
        A = { boundary: 0, storage: 0 },
        X = Array.isArray(M.value) ? M.value : [M.value];
      for (let Y = 0, D = X.length; Y < D; Y++) {
        const F = X[Y],
          N = g(F);
        (A.boundary += N.boundary), (A.storage += N.storage);
      }
      if (
        ((M.__data = new Float32Array(
          A.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (M.__offset = x),
        T > 0)
      ) {
        b = x % S;
        const Y = S - b;
        b !== 0 && Y - A.boundary < 0 && ((x += S - b), (M.__offset = x));
      }
      x += A.storage;
    }
    return (
      (b = x % S), b > 0 && (x += S - b), (y.__size = x), (y.__cache = {}), this
    );
  }
  function g(y) {
    const v = { boundary: 0, storage: 0 };
    return (
      typeof y == 'number'
        ? ((v.boundary = 4), (v.storage = 4))
        : y.isVector2
        ? ((v.boundary = 8), (v.storage = 8))
        : y.isVector3 || y.isColor
        ? ((v.boundary = 16), (v.storage = 12))
        : y.isVector4
        ? ((v.boundary = 16), (v.storage = 16))
        : y.isMatrix3
        ? ((v.boundary = 48), (v.storage = 48))
        : y.isMatrix4
        ? ((v.boundary = 64), (v.storage = 64))
        : y.isTexture
        ? console.warn(
            'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
          )
        : console.warn(
            'THREE.WebGLRenderer: Unsupported uniform value type.',
            y
          ),
      v
    );
  }
  function d(y) {
    const v = y.target;
    v.removeEventListener('dispose', d);
    const x = o.indexOf(v.__bindingPointIndex);
    o.splice(x, 1), r.deleteBuffer(i[v.id]), delete i[v.id], delete s[v.id];
  }
  function m() {
    for (const y in i) r.deleteBuffer(i[y]);
    (o = []), (i = {}), (s = {});
  }
  return { bind: c, update: l, dispose: m };
}
class Fp {
  constructor(e = {}) {
    const {
      canvas: t = Ev(),
      context: n = null,
      depth: i = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: l = !1,
      powerPreference: h = 'default',
      failIfMajorPerformanceCaveat: f = !1
    } = e;
    this.isWebGLRenderer = !0;
    let u;
    n !== null ? (u = n.getContextAttributes().alpha) : (u = o);
    const p = new Uint32Array(4),
      _ = new Int32Array(4);
    let g = null,
      d = null;
    const m = [],
      y = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = qe),
      (this._useLegacyLights = !1),
      (this.toneMapping = Ii),
      (this.toneMappingExposure = 1);
    const v = this;
    let x = !1,
      S = 0,
      b = 0,
      T = null,
      C = -1,
      M = null;
    const A = new Je(),
      X = new Je();
    let Y = null;
    const D = new Re(0);
    let F = 0,
      N = t.width,
      K = t.height,
      z = 1,
      j = null,
      J = null;
    const $ = new Je(0, 0, N, K),
      k = new Je(0, 0, N, K);
    let V = !1;
    const oe = new Wl();
    let re = !1,
      le = !1,
      ve = null;
    const Ae = new Ue(),
      ye = new Ve(),
      Xe = new P(),
      qt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
      };
    function De() {
      return T === null ? z : 1;
    }
    let O = n;
    function Pt(w, I) {
      for (let W = 0; W < w.length; W++) {
        const U = w[W],
          q = t.getContext(U, I);
        if (q !== null) return q;
      }
      return null;
    }
    try {
      const w = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: a,
        premultipliedAlpha: c,
        preserveDrawingBuffer: l,
        powerPreference: h,
        failIfMajorPerformanceCaveat: f
      };
      if (
        ('setAttribute' in t &&
          t.setAttribute('data-engine', `three.js r${Hl}`),
        t.addEventListener('webglcontextlost', ae, !1),
        t.addEventListener('webglcontextrestored', H, !1),
        t.addEventListener('webglcontextcreationerror', ie, !1),
        O === null)
      ) {
        const I = ['webgl2', 'webgl', 'experimental-webgl'];
        if (
          (v.isWebGL1Renderer === !0 && I.shift(), (O = Pt(I, w)), O === null)
        )
          throw Pt(I)
            ? new Error(
                'Error creating WebGL context with your selected attributes.'
              )
            : new Error('Error creating WebGL context.');
      }
      typeof WebGLRenderingContext < 'u' &&
        O instanceof WebGLRenderingContext &&
        console.warn(
          'THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.'
        ),
        O.getShaderPrecisionFormat === void 0 &&
          (O.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (w) {
      throw (console.error('THREE.WebGLRenderer: ' + w.message), w);
    }
    let xe,
      Ce,
      Te,
      tt,
      Be,
      Ie,
      Ke,
      At,
      Dt,
      R,
      E,
      B,
      ee,
      Q,
      te,
      de,
      ne,
      G,
      ge,
      pe,
      me,
      ue,
      fe,
      Ne;
    function Qe() {
      (xe = new HM(O)),
        (Ce = new UM(O, xe, e)),
        xe.init(Ce),
        (ue = new Tb(O, xe, Ce)),
        (Te = new Sb(O, xe, Ce)),
        (tt = new WM(O)),
        (Be = new cb()),
        (Ie = new bb(O, xe, Te, Be, Ce, ue, tt)),
        (Ke = new FM(v)),
        (At = new zM(v)),
        (Dt = new ey(O, Ce)),
        (fe = new IM(O, xe, Dt, Ce)),
        (R = new GM(O, Dt, tt, fe)),
        (E = new YM(O, R, Dt, tt)),
        (ge = new jM(O, Ce, Ie)),
        (de = new NM(Be)),
        (B = new ab(v, Ke, At, xe, Ce, fe, de)),
        (ee = new Lb(v, Be)),
        (Q = new hb()),
        (te = new gb(xe, Ce)),
        (G = new DM(v, Ke, At, Te, E, u, c)),
        (ne = new Mb(v, E, Ce)),
        (Ne = new Pb(O, tt, Ce, Te)),
        (pe = new OM(O, xe, tt, Ce)),
        (me = new VM(O, xe, tt, Ce)),
        (tt.programs = B.programs),
        (v.capabilities = Ce),
        (v.extensions = xe),
        (v.properties = Be),
        (v.renderLists = Q),
        (v.shadowMap = ne),
        (v.state = Te),
        (v.info = tt);
    }
    Qe();
    const L = new Cb(v, O);
    (this.xr = L),
      (this.getContext = function () {
        return O;
      }),
      (this.getContextAttributes = function () {
        return O.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const w = xe.get('WEBGL_lose_context');
        w && w.loseContext();
      }),
      (this.forceContextRestore = function () {
        const w = xe.get('WEBGL_lose_context');
        w && w.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return z;
      }),
      (this.setPixelRatio = function (w) {
        w !== void 0 && ((z = w), this.setSize(N, K, !1));
      }),
      (this.getSize = function (w) {
        return w.set(N, K);
      }),
      (this.setSize = function (w, I, W = !0) {
        if (L.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (N = w),
          (K = I),
          (t.width = Math.floor(w * z)),
          (t.height = Math.floor(I * z)),
          W === !0 && ((t.style.width = w + 'px'), (t.style.height = I + 'px')),
          this.setViewport(0, 0, w, I);
      }),
      (this.getDrawingBufferSize = function (w) {
        return w.set(N * z, K * z).floor();
      }),
      (this.setDrawingBufferSize = function (w, I, W) {
        (N = w),
          (K = I),
          (z = W),
          (t.width = Math.floor(w * W)),
          (t.height = Math.floor(I * W)),
          this.setViewport(0, 0, w, I);
      }),
      (this.getCurrentViewport = function (w) {
        return w.copy(A);
      }),
      (this.getViewport = function (w) {
        return w.copy($);
      }),
      (this.setViewport = function (w, I, W, U) {
        w.isVector4 ? $.set(w.x, w.y, w.z, w.w) : $.set(w, I, W, U),
          Te.viewport(A.copy($).multiplyScalar(z).floor());
      }),
      (this.getScissor = function (w) {
        return w.copy(k);
      }),
      (this.setScissor = function (w, I, W, U) {
        w.isVector4 ? k.set(w.x, w.y, w.z, w.w) : k.set(w, I, W, U),
          Te.scissor(X.copy(k).multiplyScalar(z).floor());
      }),
      (this.getScissorTest = function () {
        return V;
      }),
      (this.setScissorTest = function (w) {
        Te.setScissorTest((V = w));
      }),
      (this.setOpaqueSort = function (w) {
        j = w;
      }),
      (this.setTransparentSort = function (w) {
        J = w;
      }),
      (this.getClearColor = function (w) {
        return w.copy(G.getClearColor());
      }),
      (this.setClearColor = function () {
        G.setClearColor.apply(G, arguments);
      }),
      (this.getClearAlpha = function () {
        return G.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        G.setClearAlpha.apply(G, arguments);
      }),
      (this.clear = function (w = !0, I = !0, W = !0) {
        let U = 0;
        if (w) {
          let q = !1;
          if (T !== null) {
            const he = T.texture.format;
            q = he === gp || he === mp || he === pp;
          }
          if (q) {
            const he = T.texture.type,
              _e =
                he === Oi ||
                he === Ci ||
                he === Gl ||
                he === ur ||
                he === fp ||
                he === dp,
              Se = G.getClearColor(),
              be = G.getClearAlpha(),
              Fe = Se.r,
              Me = Se.g,
              Le = Se.b;
            _e
              ? ((p[0] = Fe),
                (p[1] = Me),
                (p[2] = Le),
                (p[3] = be),
                O.clearBufferuiv(O.COLOR, 0, p))
              : ((_[0] = Fe),
                (_[1] = Me),
                (_[2] = Le),
                (_[3] = be),
                O.clearBufferiv(O.COLOR, 0, _));
          } else U |= O.COLOR_BUFFER_BIT;
        }
        I && (U |= O.DEPTH_BUFFER_BIT),
          W && (U |= O.STENCIL_BUFFER_BIT),
          O.clear(U);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener('webglcontextlost', ae, !1),
          t.removeEventListener('webglcontextrestored', H, !1),
          t.removeEventListener('webglcontextcreationerror', ie, !1),
          Q.dispose(),
          te.dispose(),
          Be.dispose(),
          Ke.dispose(),
          At.dispose(),
          E.dispose(),
          fe.dispose(),
          Ne.dispose(),
          B.dispose(),
          L.dispose(),
          L.removeEventListener('sessionstart', et),
          L.removeEventListener('sessionend', In),
          ve && (ve.dispose(), (ve = null)),
          zt.stop();
      });
    function ae(w) {
      w.preventDefault(),
        console.log('THREE.WebGLRenderer: Context Lost.'),
        (x = !0);
    }
    function H() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (x = !1);
      const w = tt.autoReset,
        I = ne.enabled,
        W = ne.autoUpdate,
        U = ne.needsUpdate,
        q = ne.type;
      Qe(),
        (tt.autoReset = w),
        (ne.enabled = I),
        (ne.autoUpdate = W),
        (ne.needsUpdate = U),
        (ne.type = q);
    }
    function ie(w) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        w.statusMessage
      );
    }
    function ce(w) {
      const I = w.target;
      I.removeEventListener('dispose', ce), We(I);
    }
    function We(w) {
      nt(w), Be.remove(w);
    }
    function nt(w) {
      const I = Be.get(w).programs;
      I !== void 0 &&
        (I.forEach(function (W) {
          B.releaseProgram(W);
        }),
        w.isShaderMaterial && B.releaseShaderCache(w));
    }
    (this.renderBufferDirect = function (w, I, W, U, q, he) {
      I === null && (I = qt);
      const _e = q.isMesh && q.matrixWorld.determinant() < 0,
        Se = Yp(w, I, W, U, q);
      Te.setMaterial(U, _e);
      let be = W.index,
        Fe = 1;
      if (U.wireframe === !0) {
        if (((be = R.getWireframeAttribute(W)), be === void 0)) return;
        Fe = 2;
      }
      const Me = W.drawRange,
        Le = W.attributes.position;
      let ot = Me.start * Fe,
        lt = (Me.start + Me.count) * Fe;
      he !== null &&
        ((ot = Math.max(ot, he.start * Fe)),
        (lt = Math.min(lt, (he.start + he.count) * Fe))),
        be !== null
          ? ((ot = Math.max(ot, 0)), (lt = Math.min(lt, be.count)))
          : Le != null &&
            ((ot = Math.max(ot, 0)), (lt = Math.min(lt, Le.count)));
      const un = lt - ot;
      if (un < 0 || un === 1 / 0) return;
      fe.setup(q, U, Se, W, be);
      let jn,
        ft = pe;
      if (
        (be !== null && ((jn = Dt.get(be)), (ft = me), ft.setIndex(jn)),
        q.isMesh)
      )
        U.wireframe === !0
          ? (Te.setLineWidth(U.wireframeLinewidth * De()), ft.setMode(O.LINES))
          : ft.setMode(O.TRIANGLES);
      else if (q.isLine) {
        let ke = U.linewidth;
        ke === void 0 && (ke = 1),
          Te.setLineWidth(ke * De()),
          q.isLineSegments
            ? ft.setMode(O.LINES)
            : q.isLineLoop
            ? ft.setMode(O.LINE_LOOP)
            : ft.setMode(O.LINE_STRIP);
      } else
        q.isPoints
          ? ft.setMode(O.POINTS)
          : q.isSprite && ft.setMode(O.TRIANGLES);
      if (q.isInstancedMesh) ft.renderInstances(ot, un, q.count);
      else if (W.isInstancedBufferGeometry) {
        const ke = W._maxInstanceCount !== void 0 ? W._maxInstanceCount : 1 / 0,
          Ea = Math.min(W.instanceCount, ke);
        ft.renderInstances(ot, un, Ea);
      } else ft.render(ot, un);
    }),
      (this.compile = function (w, I) {
        function W(U, q, he) {
          U.transparent === !0 && U.side === Nn && U.forceSinglePass === !1
            ? ((U.side = Jt),
              (U.needsUpdate = !0),
              oo(U, q, he),
              (U.side = ui),
              (U.needsUpdate = !0),
              oo(U, q, he),
              (U.side = Nn))
            : oo(U, q, he);
        }
        (d = te.get(w)),
          d.init(),
          y.push(d),
          w.traverseVisible(function (U) {
            U.isLight &&
              U.layers.test(I.layers) &&
              (d.pushLight(U), U.castShadow && d.pushShadow(U));
          }),
          d.setupLights(v._useLegacyLights),
          w.traverse(function (U) {
            const q = U.material;
            if (q)
              if (Array.isArray(q))
                for (let he = 0; he < q.length; he++) {
                  const _e = q[he];
                  W(_e, w, U);
                }
              else W(q, w, U);
          }),
          y.pop(),
          (d = null);
      });
    let ut = null;
    function di(w) {
      ut && ut(w);
    }
    function et() {
      zt.stop();
    }
    function In() {
      zt.start();
    }
    const zt = new Dp();
    zt.setAnimationLoop(di),
      typeof self < 'u' && zt.setContext(self),
      (this.setAnimationLoop = function (w) {
        (ut = w), L.setAnimationLoop(w), w === null ? zt.stop() : zt.start();
      }),
      L.addEventListener('sessionstart', et),
      L.addEventListener('sessionend', In),
      (this.render = function (w, I) {
        if (I !== void 0 && I.isCamera !== !0) {
          console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
          );
          return;
        }
        if (x === !0) return;
        w.matrixWorldAutoUpdate === !0 && w.updateMatrixWorld(),
          I.parent === null &&
            I.matrixWorldAutoUpdate === !0 &&
            I.updateMatrixWorld(),
          L.enabled === !0 &&
            L.isPresenting === !0 &&
            (L.cameraAutoUpdate === !0 && L.updateCamera(I),
            (I = L.getCamera())),
          w.isScene === !0 && w.onBeforeRender(v, w, I, T),
          (d = te.get(w, y.length)),
          d.init(),
          y.push(d),
          Ae.multiplyMatrices(I.projectionMatrix, I.matrixWorldInverse),
          oe.setFromProjectionMatrix(Ae),
          (le = this.localClippingEnabled),
          (re = de.init(this.clippingPlanes, le)),
          (g = Q.get(w, m.length)),
          g.init(),
          m.push(g),
          th(w, I, 0, v.sortObjects),
          g.finish(),
          v.sortObjects === !0 && g.sort(j, J),
          this.info.render.frame++,
          re === !0 && de.beginShadows();
        const W = d.state.shadowsArray;
        if (
          (ne.render(W, w, I),
          re === !0 && de.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          G.render(g, w),
          d.setupLights(v._useLegacyLights),
          I.isArrayCamera)
        ) {
          const U = I.cameras;
          for (let q = 0, he = U.length; q < he; q++) {
            const _e = U[q];
            nh(g, w, _e, _e.viewport);
          }
        } else nh(g, w, I);
        T !== null &&
          (Ie.updateMultisampleRenderTarget(T), Ie.updateRenderTargetMipmap(T)),
          w.isScene === !0 && w.onAfterRender(v, w, I),
          fe.resetDefaultState(),
          (C = -1),
          (M = null),
          y.pop(),
          y.length > 0 ? (d = y[y.length - 1]) : (d = null),
          m.pop(),
          m.length > 0 ? (g = m[m.length - 1]) : (g = null);
      });
    function th(w, I, W, U) {
      if (w.visible === !1) return;
      if (w.layers.test(I.layers)) {
        if (w.isGroup) W = w.renderOrder;
        else if (w.isLOD) w.autoUpdate === !0 && w.update(I);
        else if (w.isLight) d.pushLight(w), w.castShadow && d.pushShadow(w);
        else if (w.isSprite) {
          if (!w.frustumCulled || oe.intersectsSprite(w)) {
            U && Xe.setFromMatrixPosition(w.matrixWorld).applyMatrix4(Ae);
            const _e = E.update(w),
              Se = w.material;
            Se.visible && g.push(w, _e, Se, W, Xe.z, null);
          }
        } else if (
          (w.isMesh || w.isLine || w.isPoints) &&
          (!w.frustumCulled || oe.intersectsObject(w))
        ) {
          const _e = E.update(w),
            Se = w.material;
          if (
            (U &&
              (w.boundingSphere !== void 0
                ? (w.boundingSphere === null && w.computeBoundingSphere(),
                  Xe.copy(w.boundingSphere.center))
                : (_e.boundingSphere === null && _e.computeBoundingSphere(),
                  Xe.copy(_e.boundingSphere.center)),
              Xe.applyMatrix4(w.matrixWorld).applyMatrix4(Ae)),
            Array.isArray(Se))
          ) {
            const be = _e.groups;
            for (let Fe = 0, Me = be.length; Fe < Me; Fe++) {
              const Le = be[Fe],
                ot = Se[Le.materialIndex];
              ot && ot.visible && g.push(w, _e, ot, W, Xe.z, Le);
            }
          } else Se.visible && g.push(w, _e, Se, W, Xe.z, null);
        }
      }
      const he = w.children;
      for (let _e = 0, Se = he.length; _e < Se; _e++) th(he[_e], I, W, U);
    }
    function nh(w, I, W, U) {
      const q = w.opaque,
        he = w.transmissive,
        _e = w.transparent;
      d.setupLightsView(W),
        re === !0 && de.setGlobalState(v.clippingPlanes, W),
        he.length > 0 && jp(q, he, I, W),
        U && Te.viewport(A.copy(U)),
        q.length > 0 && so(q, I, W),
        he.length > 0 && so(he, I, W),
        _e.length > 0 && so(_e, I, W),
        Te.buffers.depth.setTest(!0),
        Te.buffers.depth.setMask(!0),
        Te.buffers.color.setMask(!0),
        Te.setPolygonOffset(!1);
    }
    function jp(w, I, W, U) {
      const q = Ce.isWebGL2;
      ve === null &&
        (ve = new _r(1, 1, {
          generateMipmaps: !0,
          type: xe.has('EXT_color_buffer_half_float') ? Qs : Oi,
          minFilter: gr,
          samples: q ? 4 : 0
        })),
        v.getDrawingBufferSize(ye),
        q ? ve.setSize(ye.x, ye.y) : ve.setSize(ua(ye.x), ua(ye.y));
      const he = v.getRenderTarget();
      v.setRenderTarget(ve),
        v.getClearColor(D),
        (F = v.getClearAlpha()),
        F < 1 && v.setClearColor(16777215, 0.5),
        v.clear();
      const _e = v.toneMapping;
      (v.toneMapping = Ii),
        so(w, W, U),
        Ie.updateMultisampleRenderTarget(ve),
        Ie.updateRenderTargetMipmap(ve);
      let Se = !1;
      for (let be = 0, Fe = I.length; be < Fe; be++) {
        const Me = I[be],
          Le = Me.object,
          ot = Me.geometry,
          lt = Me.material,
          un = Me.group;
        if (lt.side === Nn && Le.layers.test(U.layers)) {
          const jn = lt.side;
          (lt.side = Jt),
            (lt.needsUpdate = !0),
            ih(Le, W, U, ot, lt, un),
            (lt.side = jn),
            (lt.needsUpdate = !0),
            (Se = !0);
        }
      }
      Se === !0 &&
        (Ie.updateMultisampleRenderTarget(ve), Ie.updateRenderTargetMipmap(ve)),
        v.setRenderTarget(he),
        v.setClearColor(D, F),
        (v.toneMapping = _e);
    }
    function so(w, I, W) {
      const U = I.isScene === !0 ? I.overrideMaterial : null;
      for (let q = 0, he = w.length; q < he; q++) {
        const _e = w[q],
          Se = _e.object,
          be = _e.geometry,
          Fe = U === null ? _e.material : U,
          Me = _e.group;
        Se.layers.test(W.layers) && ih(Se, I, W, be, Fe, Me);
      }
    }
    function ih(w, I, W, U, q, he) {
      w.onBeforeRender(v, I, W, U, q, he),
        w.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse, w.matrixWorld),
        w.normalMatrix.getNormalMatrix(w.modelViewMatrix),
        q.onBeforeRender(v, I, W, U, w, he),
        q.transparent === !0 && q.side === Nn && q.forceSinglePass === !1
          ? ((q.side = Jt),
            (q.needsUpdate = !0),
            v.renderBufferDirect(W, I, U, q, w, he),
            (q.side = ui),
            (q.needsUpdate = !0),
            v.renderBufferDirect(W, I, U, q, w, he),
            (q.side = Nn))
          : v.renderBufferDirect(W, I, U, q, w, he),
        w.onAfterRender(v, I, W, U, q, he);
    }
    function oo(w, I, W) {
      I.isScene !== !0 && (I = qt);
      const U = Be.get(w),
        q = d.state.lights,
        he = d.state.shadowsArray,
        _e = q.state.version,
        Se = B.getParameters(w, q.state, he, I, W),
        be = B.getProgramCacheKey(Se);
      let Fe = U.programs;
      (U.environment = w.isMeshStandardMaterial ? I.environment : null),
        (U.fog = I.fog),
        (U.envMap = (w.isMeshStandardMaterial ? At : Ke).get(
          w.envMap || U.environment
        )),
        Fe === void 0 &&
          (w.addEventListener('dispose', ce),
          (Fe = new Map()),
          (U.programs = Fe));
      let Me = Fe.get(be);
      if (Me !== void 0) {
        if (U.currentProgram === Me && U.lightsStateVersion === _e)
          return rh(w, Se), Me;
      } else
        (Se.uniforms = B.getUniforms(w)),
          w.onBuild(W, Se, v),
          w.onBeforeCompile(Se, v),
          (Me = B.acquireProgram(Se, be)),
          Fe.set(be, Me),
          (U.uniforms = Se.uniforms);
      const Le = U.uniforms;
      ((!w.isShaderMaterial && !w.isRawShaderMaterial) || w.clipping === !0) &&
        (Le.clippingPlanes = de.uniform),
        rh(w, Se),
        (U.needsLights = $p(w)),
        (U.lightsStateVersion = _e),
        U.needsLights &&
          ((Le.ambientLightColor.value = q.state.ambient),
          (Le.lightProbe.value = q.state.probe),
          (Le.directionalLights.value = q.state.directional),
          (Le.directionalLightShadows.value = q.state.directionalShadow),
          (Le.spotLights.value = q.state.spot),
          (Le.spotLightShadows.value = q.state.spotShadow),
          (Le.rectAreaLights.value = q.state.rectArea),
          (Le.ltc_1.value = q.state.rectAreaLTC1),
          (Le.ltc_2.value = q.state.rectAreaLTC2),
          (Le.pointLights.value = q.state.point),
          (Le.pointLightShadows.value = q.state.pointShadow),
          (Le.hemisphereLights.value = q.state.hemi),
          (Le.directionalShadowMap.value = q.state.directionalShadowMap),
          (Le.directionalShadowMatrix.value = q.state.directionalShadowMatrix),
          (Le.spotShadowMap.value = q.state.spotShadowMap),
          (Le.spotLightMatrix.value = q.state.spotLightMatrix),
          (Le.spotLightMap.value = q.state.spotLightMap),
          (Le.pointShadowMap.value = q.state.pointShadowMap),
          (Le.pointShadowMatrix.value = q.state.pointShadowMatrix));
      const ot = Me.getUniforms(),
        lt = Jo.seqWithValue(ot.seq, Le);
      return (U.currentProgram = Me), (U.uniformsList = lt), Me;
    }
    function rh(w, I) {
      const W = Be.get(w);
      (W.outputColorSpace = I.outputColorSpace),
        (W.instancing = I.instancing),
        (W.instancingColor = I.instancingColor),
        (W.skinning = I.skinning),
        (W.morphTargets = I.morphTargets),
        (W.morphNormals = I.morphNormals),
        (W.morphColors = I.morphColors),
        (W.morphTargetsCount = I.morphTargetsCount),
        (W.numClippingPlanes = I.numClippingPlanes),
        (W.numIntersection = I.numClipIntersection),
        (W.vertexAlphas = I.vertexAlphas),
        (W.vertexTangents = I.vertexTangents),
        (W.toneMapping = I.toneMapping);
    }
    function Yp(w, I, W, U, q) {
      I.isScene !== !0 && (I = qt), Ie.resetTextureUnits();
      const he = I.fog,
        _e = U.isMeshStandardMaterial ? I.environment : null,
        Se =
          T === null
            ? v.outputColorSpace
            : T.isXRRenderTarget === !0
            ? T.texture.colorSpace
            : _t,
        be = (U.isMeshStandardMaterial ? At : Ke).get(U.envMap || _e),
        Fe =
          U.vertexColors === !0 &&
          !!W.attributes.color &&
          W.attributes.color.itemSize === 4,
        Me = !!W.attributes.tangent && (!!U.normalMap || U.anisotropy > 0),
        Le = !!W.morphAttributes.position,
        ot = !!W.morphAttributes.normal,
        lt = !!W.morphAttributes.color;
      let un = Ii;
      U.toneMapped &&
        (T === null || T.isXRRenderTarget === !0) &&
        (un = v.toneMapping);
      const jn =
          W.morphAttributes.position ||
          W.morphAttributes.normal ||
          W.morphAttributes.color,
        ft = jn !== void 0 ? jn.length : 0,
        ke = Be.get(U),
        Ea = d.state.lights;
      if (re === !0 && (le === !0 || w !== M)) {
        const en = w === M && U.id === C;
        de.setState(U, w, en);
      }
      let dt = !1;
      U.version === ke.__version
        ? ((ke.needsLights && ke.lightsStateVersion !== Ea.state.version) ||
            ke.outputColorSpace !== Se ||
            (q.isInstancedMesh && ke.instancing === !1) ||
            (!q.isInstancedMesh && ke.instancing === !0) ||
            (q.isSkinnedMesh && ke.skinning === !1) ||
            (!q.isSkinnedMesh && ke.skinning === !0) ||
            (q.isInstancedMesh &&
              ke.instancingColor === !0 &&
              q.instanceColor === null) ||
            (q.isInstancedMesh &&
              ke.instancingColor === !1 &&
              q.instanceColor !== null) ||
            ke.envMap !== be ||
            (U.fog === !0 && ke.fog !== he) ||
            (ke.numClippingPlanes !== void 0 &&
              (ke.numClippingPlanes !== de.numPlanes ||
                ke.numIntersection !== de.numIntersection)) ||
            ke.vertexAlphas !== Fe ||
            ke.vertexTangents !== Me ||
            ke.morphTargets !== Le ||
            ke.morphNormals !== ot ||
            ke.morphColors !== lt ||
            ke.toneMapping !== un ||
            (Ce.isWebGL2 === !0 && ke.morphTargetsCount !== ft)) &&
          (dt = !0)
        : ((dt = !0), (ke.__version = U.version));
      let zi = ke.currentProgram;
      dt === !0 && (zi = oo(U, I, q));
      let sh = !1,
        Ms = !1,
        Ta = !1;
      const Ht = zi.getUniforms(),
        Hi = ke.uniforms;
      if (
        (Te.useProgram(zi.program) && ((sh = !0), (Ms = !0), (Ta = !0)),
        U.id !== C && ((C = U.id), (Ms = !0)),
        sh || M !== w)
      ) {
        Ht.setValue(O, 'projectionMatrix', w.projectionMatrix),
          Ht.setValue(O, 'viewMatrix', w.matrixWorldInverse);
        const en = Ht.map.cameraPosition;
        en !== void 0 &&
          en.setValue(O, Xe.setFromMatrixPosition(w.matrixWorld)),
          Ce.logarithmicDepthBuffer &&
            Ht.setValue(
              O,
              'logDepthBufFC',
              2 / (Math.log(w.far + 1) / Math.LN2)
            ),
          (U.isMeshPhongMaterial ||
            U.isMeshToonMaterial ||
            U.isMeshLambertMaterial ||
            U.isMeshBasicMaterial ||
            U.isMeshStandardMaterial ||
            U.isShaderMaterial) &&
            Ht.setValue(O, 'isOrthographic', w.isOrthographicCamera === !0),
          M !== w && ((M = w), (Ms = !0), (Ta = !0));
      }
      if (q.isSkinnedMesh) {
        Ht.setOptional(O, q, 'bindMatrix'),
          Ht.setOptional(O, q, 'bindMatrixInverse');
        const en = q.skeleton;
        en &&
          (Ce.floatVertexTextures
            ? (en.boneTexture === null && en.computeBoneTexture(),
              Ht.setValue(O, 'boneTexture', en.boneTexture, Ie),
              Ht.setValue(O, 'boneTextureSize', en.boneTextureSize))
            : console.warn(
                'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.'
              ));
      }
      const Aa = W.morphAttributes;
      if (
        ((Aa.position !== void 0 ||
          Aa.normal !== void 0 ||
          (Aa.color !== void 0 && Ce.isWebGL2 === !0)) &&
          ge.update(q, W, zi),
        (Ms || ke.receiveShadow !== q.receiveShadow) &&
          ((ke.receiveShadow = q.receiveShadow),
          Ht.setValue(O, 'receiveShadow', q.receiveShadow)),
        U.isMeshGouraudMaterial &&
          U.envMap !== null &&
          ((Hi.envMap.value = be),
          (Hi.flipEnvMap.value =
            be.isCubeTexture && be.isRenderTargetTexture === !1 ? -1 : 1)),
        Ms &&
          (Ht.setValue(O, 'toneMappingExposure', v.toneMappingExposure),
          ke.needsLights && Kp(Hi, Ta),
          he && U.fog === !0 && ee.refreshFogUniforms(Hi, he),
          ee.refreshMaterialUniforms(Hi, U, z, K, ve),
          Jo.upload(O, ke.uniformsList, Hi, Ie)),
        U.isShaderMaterial &&
          U.uniformsNeedUpdate === !0 &&
          (Jo.upload(O, ke.uniformsList, Hi, Ie), (U.uniformsNeedUpdate = !1)),
        U.isSpriteMaterial && Ht.setValue(O, 'center', q.center),
        Ht.setValue(O, 'modelViewMatrix', q.modelViewMatrix),
        Ht.setValue(O, 'normalMatrix', q.normalMatrix),
        Ht.setValue(O, 'modelMatrix', q.matrixWorld),
        U.isShaderMaterial || U.isRawShaderMaterial)
      ) {
        const en = U.uniformsGroups;
        for (let wa = 0, Zp = en.length; wa < Zp; wa++)
          if (Ce.isWebGL2) {
            const oh = en[wa];
            Ne.update(oh, zi), Ne.bind(oh, zi);
          } else
            console.warn(
              'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.'
            );
      }
      return zi;
    }
    function Kp(w, I) {
      (w.ambientLightColor.needsUpdate = I),
        (w.lightProbe.needsUpdate = I),
        (w.directionalLights.needsUpdate = I),
        (w.directionalLightShadows.needsUpdate = I),
        (w.pointLights.needsUpdate = I),
        (w.pointLightShadows.needsUpdate = I),
        (w.spotLights.needsUpdate = I),
        (w.spotLightShadows.needsUpdate = I),
        (w.rectAreaLights.needsUpdate = I),
        (w.hemisphereLights.needsUpdate = I);
    }
    function $p(w) {
      return (
        w.isMeshLambertMaterial ||
        w.isMeshToonMaterial ||
        w.isMeshPhongMaterial ||
        w.isMeshStandardMaterial ||
        w.isShadowMaterial ||
        (w.isShaderMaterial && w.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return S;
    }),
      (this.getActiveMipmapLevel = function () {
        return b;
      }),
      (this.getRenderTarget = function () {
        return T;
      }),
      (this.setRenderTargetTextures = function (w, I, W) {
        (Be.get(w.texture).__webglTexture = I),
          (Be.get(w.depthTexture).__webglTexture = W);
        const U = Be.get(w);
        (U.__hasExternalTextures = !0),
          U.__hasExternalTextures &&
            ((U.__autoAllocateDepthBuffer = W === void 0),
            U.__autoAllocateDepthBuffer ||
              (xe.has('WEBGL_multisampled_render_to_texture') === !0 &&
                (console.warn(
                  'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
                ),
                (U.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (w, I) {
        const W = Be.get(w);
        (W.__webglFramebuffer = I), (W.__useDefaultFramebuffer = I === void 0);
      }),
      (this.setRenderTarget = function (w, I = 0, W = 0) {
        (T = w), (S = I), (b = W);
        let U = !0,
          q = null,
          he = !1,
          _e = !1;
        if (w) {
          const be = Be.get(w);
          be.__useDefaultFramebuffer !== void 0
            ? (Te.bindFramebuffer(O.FRAMEBUFFER, null), (U = !1))
            : be.__webglFramebuffer === void 0
            ? Ie.setupRenderTarget(w)
            : be.__hasExternalTextures &&
              Ie.rebindTextures(
                w,
                Be.get(w.texture).__webglTexture,
                Be.get(w.depthTexture).__webglTexture
              );
          const Fe = w.texture;
          (Fe.isData3DTexture ||
            Fe.isDataArrayTexture ||
            Fe.isCompressedArrayTexture) &&
            (_e = !0);
          const Me = Be.get(w).__webglFramebuffer;
          w.isWebGLCubeRenderTarget
            ? (Array.isArray(Me[I]) ? (q = Me[I][W]) : (q = Me[I]), (he = !0))
            : Ce.isWebGL2 && w.samples > 0 && Ie.useMultisampledRTT(w) === !1
            ? (q = Be.get(w).__webglMultisampledFramebuffer)
            : Array.isArray(Me)
            ? (q = Me[W])
            : (q = Me),
            A.copy(w.viewport),
            X.copy(w.scissor),
            (Y = w.scissorTest);
        } else
          A.copy($).multiplyScalar(z).floor(),
            X.copy(k).multiplyScalar(z).floor(),
            (Y = V);
        if (
          (Te.bindFramebuffer(O.FRAMEBUFFER, q) &&
            Ce.drawBuffers &&
            U &&
            Te.drawBuffers(w, q),
          Te.viewport(A),
          Te.scissor(X),
          Te.setScissorTest(Y),
          he)
        ) {
          const be = Be.get(w.texture);
          O.framebufferTexture2D(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            O.TEXTURE_CUBE_MAP_POSITIVE_X + I,
            be.__webglTexture,
            W
          );
        } else if (_e) {
          const be = Be.get(w.texture),
            Fe = I || 0;
          O.framebufferTextureLayer(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            be.__webglTexture,
            W || 0,
            Fe
          );
        }
        C = -1;
      }),
      (this.readRenderTargetPixels = function (w, I, W, U, q, he, _e) {
        if (!(w && w.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          );
          return;
        }
        let Se = Be.get(w).__webglFramebuffer;
        if ((w.isWebGLCubeRenderTarget && _e !== void 0 && (Se = Se[_e]), Se)) {
          Te.bindFramebuffer(O.FRAMEBUFFER, Se);
          try {
            const be = w.texture,
              Fe = be.format,
              Me = be.type;
            if (
              Fe !== yn &&
              ue.convert(Fe) !==
                O.getParameter(O.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
              );
              return;
            }
            const Le =
              Me === Qs &&
              (xe.has('EXT_color_buffer_half_float') ||
                (Ce.isWebGL2 && xe.has('EXT_color_buffer_float')));
            if (
              Me !== Oi &&
              ue.convert(Me) !==
                O.getParameter(O.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Me === oi &&
                (Ce.isWebGL2 ||
                  xe.has('OES_texture_float') ||
                  xe.has('WEBGL_color_buffer_float'))
              ) &&
              !Le
            ) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
              );
              return;
            }
            I >= 0 &&
              I <= w.width - U &&
              W >= 0 &&
              W <= w.height - q &&
              O.readPixels(I, W, U, q, ue.convert(Fe), ue.convert(Me), he);
          } finally {
            const be = T !== null ? Be.get(T).__webglFramebuffer : null;
            Te.bindFramebuffer(O.FRAMEBUFFER, be);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (w, I, W = 0) {
        const U = Math.pow(2, -W),
          q = Math.floor(I.image.width * U),
          he = Math.floor(I.image.height * U);
        Ie.setTexture2D(I, 0),
          O.copyTexSubImage2D(O.TEXTURE_2D, W, 0, 0, w.x, w.y, q, he),
          Te.unbindTexture();
      }),
      (this.copyTextureToTexture = function (w, I, W, U = 0) {
        const q = I.image.width,
          he = I.image.height,
          _e = ue.convert(W.format),
          Se = ue.convert(W.type);
        Ie.setTexture2D(W, 0),
          O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, W.flipY),
          O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha),
          O.pixelStorei(O.UNPACK_ALIGNMENT, W.unpackAlignment),
          I.isDataTexture
            ? O.texSubImage2D(
                O.TEXTURE_2D,
                U,
                w.x,
                w.y,
                q,
                he,
                _e,
                Se,
                I.image.data
              )
            : I.isCompressedTexture
            ? O.compressedTexSubImage2D(
                O.TEXTURE_2D,
                U,
                w.x,
                w.y,
                I.mipmaps[0].width,
                I.mipmaps[0].height,
                _e,
                I.mipmaps[0].data
              )
            : O.texSubImage2D(O.TEXTURE_2D, U, w.x, w.y, _e, Se, I.image),
          U === 0 && W.generateMipmaps && O.generateMipmap(O.TEXTURE_2D),
          Te.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (w, I, W, U, q = 0) {
        if (v.isWebGL1Renderer) {
          console.warn(
            'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
          );
          return;
        }
        const he = w.max.x - w.min.x + 1,
          _e = w.max.y - w.min.y + 1,
          Se = w.max.z - w.min.z + 1,
          be = ue.convert(U.format),
          Fe = ue.convert(U.type);
        let Me;
        if (U.isData3DTexture) Ie.setTexture3D(U, 0), (Me = O.TEXTURE_3D);
        else if (U.isDataArrayTexture)
          Ie.setTexture2DArray(U, 0), (Me = O.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
          );
          return;
        }
        O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, U.flipY),
          O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
          O.pixelStorei(O.UNPACK_ALIGNMENT, U.unpackAlignment);
        const Le = O.getParameter(O.UNPACK_ROW_LENGTH),
          ot = O.getParameter(O.UNPACK_IMAGE_HEIGHT),
          lt = O.getParameter(O.UNPACK_SKIP_PIXELS),
          un = O.getParameter(O.UNPACK_SKIP_ROWS),
          jn = O.getParameter(O.UNPACK_SKIP_IMAGES),
          ft = W.isCompressedTexture ? W.mipmaps[0] : W.image;
        O.pixelStorei(O.UNPACK_ROW_LENGTH, ft.width),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, ft.height),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, w.min.x),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, w.min.y),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, w.min.z),
          W.isDataTexture || W.isData3DTexture
            ? O.texSubImage3D(Me, q, I.x, I.y, I.z, he, _e, Se, be, Fe, ft.data)
            : W.isCompressedArrayTexture
            ? (console.warn(
                'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
              ),
              O.compressedTexSubImage3D(
                Me,
                q,
                I.x,
                I.y,
                I.z,
                he,
                _e,
                Se,
                be,
                ft.data
              ))
            : O.texSubImage3D(Me, q, I.x, I.y, I.z, he, _e, Se, be, Fe, ft),
          O.pixelStorei(O.UNPACK_ROW_LENGTH, Le),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, ot),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, lt),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, un),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, jn),
          q === 0 && U.generateMipmaps && O.generateMipmap(Me),
          Te.unbindTexture();
      }),
      (this.initTexture = function (w) {
        w.isCubeTexture
          ? Ie.setTextureCube(w, 0)
          : w.isData3DTexture
          ? Ie.setTexture3D(w, 0)
          : w.isDataArrayTexture || w.isCompressedArrayTexture
          ? Ie.setTexture2DArray(w, 0)
          : Ie.setTexture2D(w, 0),
          Te.unbindTexture();
      }),
      (this.resetState = function () {
        (S = 0), (b = 0), (T = null), Te.reset(), fe.reset();
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        );
  }
  get coordinateSystem() {
    return ai;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        'THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      'THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.'
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
      ),
      this.outputColorSpace === qe ? dr : vp
    );
  }
  set outputEncoding(e) {
    console.warn(
      'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.'
    ),
      (this.outputColorSpace = e === dr ? qe : _t);
  }
  get useLegacyLights() {
    return (
      console.warn(
        'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
    ),
      (this._useLegacyLights = e);
  }
}
class Db extends Fp {}
Db.prototype.isWebGL1Renderer = !0;
class Ib extends st {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class Ob {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = il),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = Pn());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Pn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Pn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      }
    );
  }
}
const Gt = new P();
class Yl {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Gt.fromBufferAttribute(this, t),
        Gt.applyMatrix4(e),
        this.setXYZ(t, Gt.x, Gt.y, Gt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gt.fromBufferAttribute(this, t),
        Gt.applyNormalMatrix(e),
        this.setXYZ(t, Gt.x, Gt.y, Gt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gt.fromBufferAttribute(this, t),
        Gt.transformDirection(e),
        this.setXYZ(t, Gt.x, Gt.y, Gt.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ye(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Fn(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Ye(t, this.array)), (n = Ye(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ye(t, this.array)),
        (n = Ye(n, this.array)),
        (i = Ye(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ye(t, this.array)),
        (n = Ye(n, this.array)),
        (i = Ye(i, this.array)),
        (s = Ye(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new Lt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Yl(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        }
      );
  }
}
const af = new P(),
  cf = new Je(),
  lf = new Je(),
  Ub = new P(),
  hf = new Ue(),
  Br = new P(),
  _c = new qn(),
  uf = new Ue(),
  vc = new xa();
class Nb extends bn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = 'attached'),
      (this.bindMatrix = new Ue()),
      (this.bindMatrixInverse = new Ue()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new fi()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute('position');
    for (let n = 0; n < t.count; n++)
      Br.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Br),
        this.boundingBox.expandByPoint(Br);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new qn()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute('position');
    for (let n = 0; n < t.count; n++)
      Br.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Br),
        this.boundingSphere.expandByPoint(Br);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _c.copy(this.boundingSphere),
      _c.applyMatrix4(i),
      e.ray.intersectsSphere(_c) !== !1 &&
        (uf.copy(i).invert(),
        vc.copy(e.ray).applyMatrix4(uf),
        !(
          this.boundingBox !== null && vc.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, vc)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Je(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === 'attached'
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === 'detached'
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    cf.fromBufferAttribute(i.attributes.skinIndex, e),
      lf.fromBufferAttribute(i.attributes.skinWeight, e),
      af.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = lf.getComponent(s);
      if (o !== 0) {
        const a = cf.getComponent(s);
        hf.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
          t.addScaledVector(Ub.copy(af).applyMatrix4(hf), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        'THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.'
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class kp extends st {
  constructor() {
    super(), (this.isBone = !0), (this.type = 'Bone');
  }
}
class Fb extends Ct {
  constructor(e = null, t = 1, n = 1, i, s, o, a, c, l = Et, h = Et, f, u) {
    super(null, o, a, c, l, h, i, s, f, u),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const ff = new Ue(),
  kb = new Ue();
class Kl {
  constructor(e = [], t = []) {
    (this.uuid = Pn()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Ue());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Ue();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : kb;
      ff.multiplyMatrices(a, t[s]), ff.toArray(n, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Kl(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = xp(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Fb(t, e, e, yn, oi);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const s = e.bones[n];
      let o = t[s];
      o === void 0 &&
        (console.warn('THREE.Skeleton: No bone found with UUID:', s),
        (o = new kp())),
        this.bones.push(o),
        this.boneInverses.push(new Ue().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON'
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = n[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class df extends Lt {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const zr = new Ue(),
  pf = new Ue(),
  ko = [],
  mf = new fi(),
  Bb = new Ue(),
  Cs = new bn(),
  Ls = new qn();
class zb extends bn {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new df(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, Bb);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new fi()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, zr),
        mf.copy(e.boundingBox).applyMatrix4(zr),
        this.boundingBox.union(mf);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new qn()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, zr),
        Ls.copy(e.boundingSphere).applyMatrix4(zr),
        this.boundingSphere.union(Ls);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((Cs.geometry = this.geometry),
      (Cs.material = this.material),
      Cs.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Ls.copy(this.boundingSphere),
        Ls.applyMatrix4(n),
        e.ray.intersectsSphere(Ls) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, zr),
          pf.multiplyMatrices(n, zr),
          (Cs.matrixWorld = pf),
          Cs.raycast(e, ko);
        for (let o = 0, a = ko.length; o < a; o++) {
          const c = ko[o];
          (c.instanceId = s), (c.object = this), t.push(c);
        }
        ko.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new df(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
class Bp extends Hn {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new Re(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const gf = new P(),
  _f = new P(),
  vf = new Ue(),
  yc = new xa(),
  Bo = new qn();
class $l extends st {
  constructor(e = new Dn(), t = new Bp()) {
    super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, s = t.count; i < s; i++)
        gf.fromBufferAttribute(t, i - 1),
          _f.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += gf.distanceTo(_f));
      e.setAttribute('lineDistance', new ci(n, 1));
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Bo.copy(n.boundingSphere),
      Bo.applyMatrix4(i),
      (Bo.radius += s),
      e.ray.intersectsSphere(Bo) === !1)
    )
      return;
    vf.copy(i).invert(), yc.copy(e.ray).applyMatrix4(vf);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = a * a,
      l = new P(),
      h = new P(),
      f = new P(),
      u = new P(),
      p = this.isLineSegments ? 2 : 1,
      _ = n.index,
      d = n.attributes.position;
    if (_ !== null) {
      const m = Math.max(0, o.start),
        y = Math.min(_.count, o.start + o.count);
      for (let v = m, x = y - 1; v < x; v += p) {
        const S = _.getX(v),
          b = _.getX(v + 1);
        if (
          (l.fromBufferAttribute(d, S),
          h.fromBufferAttribute(d, b),
          yc.distanceSqToSegment(l, h, u, f) > c)
        )
          continue;
        u.applyMatrix4(this.matrixWorld);
        const C = e.ray.origin.distanceTo(u);
        C < e.near ||
          C > e.far ||
          t.push({
            distance: C,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this
          });
      }
    } else {
      const m = Math.max(0, o.start),
        y = Math.min(d.count, o.start + o.count);
      for (let v = m, x = y - 1; v < x; v += p) {
        if (
          (l.fromBufferAttribute(d, v),
          h.fromBufferAttribute(d, v + 1),
          yc.distanceSqToSegment(l, h, u, f) > c)
        )
          continue;
        u.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(u);
        b < e.near ||
          b > e.far ||
          t.push({
            distance: b,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const yf = new P(),
  xf = new P();
class Hb extends $l {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        yf.fromBufferAttribute(t, i),
          xf.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + yf.distanceTo(xf));
      e.setAttribute('lineDistance', new ci(n, 1));
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      );
    return this;
  }
}
class Gb extends $l {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
  }
}
class zp extends Hn {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new Re(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const Mf = new Ue(),
  al = new xa(),
  zo = new qn(),
  Ho = new P();
class Vb extends st {
  constructor(e = new Dn(), t = new zp()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      zo.copy(n.boundingSphere),
      zo.applyMatrix4(i),
      (zo.radius += s),
      e.ray.intersectsSphere(zo) === !1)
    )
      return;
    Mf.copy(i).invert(), al.copy(e.ray).applyMatrix4(Mf);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = a * a,
      l = n.index,
      f = n.attributes.position;
    if (l !== null) {
      const u = Math.max(0, o.start),
        p = Math.min(l.count, o.start + o.count);
      for (let _ = u, g = p; _ < g; _++) {
        const d = l.getX(_);
        Ho.fromBufferAttribute(f, d), Sf(Ho, d, c, i, e, t, this);
      }
    } else {
      const u = Math.max(0, o.start),
        p = Math.min(f.count, o.start + o.count);
      for (let _ = u, g = p; _ < g; _++)
        Ho.fromBufferAttribute(f, _), Sf(Ho, _, c, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function Sf(r, e, t, n, i, s, o) {
  const a = al.distanceSqToPoint(r);
  if (a < t) {
    const c = new P();
    al.closestPointToPoint(r, c), c.applyMatrix4(n);
    const l = i.ray.origin.distanceTo(c);
    if (l < i.near || l > i.far) return;
    s.push({
      distance: l,
      distanceToRay: Math.sqrt(a),
      point: c,
      index: e,
      face: null,
      object: o
    });
  }
}
class Zl extends Hn {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: '' }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new Re(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Re(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = yp),
      (this.normalScale = new Ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '' }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Bi extends Zl {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ve(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return Nt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Re(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Re(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Re(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function xi(r, e, t) {
  return Hp(r)
    ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
    : r.slice(e, t);
}
function Go(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == 'number'
    ? new e(r)
    : Array.prototype.slice.call(r);
}
function Hp(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function Wb(r) {
  function e(i, s) {
    return r[i] - r[s];
  }
  const t = r.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function bf(r, e, t) {
  const n = r.length,
    i = new r.constructor(n);
  for (let s = 0, o = 0; o !== n; ++s) {
    const a = t[s] * e;
    for (let c = 0; c !== e; ++c) i[o++] = r[a + c];
  }
  return i;
}
function Gp(r, e, t, n) {
  let i = 1,
    s = r[0];
  for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
  if (s === void 0) return;
  let o = s[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[n]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = r[i++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[n]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = r[i++]);
      while (s !== void 0);
    else
      do (o = s[n]), o !== void 0 && (e.push(s.time), t.push(o)), (s = r[i++]);
      while (s !== void 0);
}
class ro {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      s = t[n - 1];
    n: {
      e: {
        let o;
        t: {
          i: if (!(e < i)) {
            for (let a = n + 2; ; ) {
              if (i === void 0) {
                if (e < s) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === a) break;
              if (((s = i), (i = t[++n]), e < i)) break e;
            }
            o = t.length;
            break t;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((n = 2), (s = a));
            for (let c = n - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === c) break;
              if (((i = s), (s = t[--n - 1]), e >= s)) break e;
            }
            (o = n), (n = 0);
            break t;
          }
          break n;
        }
        for (; n < o; ) {
          const a = (n + o) >>> 1;
          e < t[a] ? (o = a) : (n = a + 1);
        }
        if (((i = t[n]), (s = t[n - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, s, i);
    }
    return this.interpolate_(n, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let o = 0; o !== i; ++o) t[o] = n[s + o];
    return t;
  }
  interpolate_() {
    throw new Error('call to abstract method');
  }
  intervalChanged_() {}
}
class qb extends ro {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: yu, endingEnd: yu });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = i[s],
      c = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case xu:
          (s = e), (a = 2 * t - n);
          break;
        case Mu:
          (s = i.length - 2), (a = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (a = n);
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case xu:
          (o = e), (c = 2 * n - t);
          break;
        case Mu:
          (o = 1), (c = n + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (c = t);
      }
    const l = (n - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = l / (t - a)),
      (this._weightNext = l / (c - n)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = e * a,
      l = c - a,
      h = this._offsetPrev,
      f = this._offsetNext,
      u = this._weightPrev,
      p = this._weightNext,
      _ = (n - t) / (i - t),
      g = _ * _,
      d = g * _,
      m = -u * d + 2 * u * g - u * _,
      y = (1 + u) * d + (-1.5 - 2 * u) * g + (-0.5 + u) * _ + 1,
      v = (-1 - p) * d + (1.5 + p) * g + 0.5 * _,
      x = p * d - p * g;
    for (let S = 0; S !== a; ++S)
      s[S] = m * o[h + S] + y * o[l + S] + v * o[c + S] + x * o[f + S];
    return s;
  }
}
class Xb extends ro {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = e * a,
      l = c - a,
      h = (n - t) / (i - t),
      f = 1 - h;
    for (let u = 0; u !== a; ++u) s[u] = o[l + u] * f + o[c + u] * h;
    return s;
  }
}
class jb extends ro {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Xn {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (t === void 0 || t.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
    (this.name = e),
      (this.times = Go(t, this.TimeBufferType)),
      (this.values = Go(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Go(e.times, Array),
        values: Go(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new jb(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Xb(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new qb(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case eo:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case hs:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Ya:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn('THREE.KeyframeTrack:', n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return eo;
      case this.InterpolantFactoryMethodLinear:
        return hs;
      case this.InterpolantFactoryMethodSmooth:
        return Ya;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let s = 0,
      o = i - 1;
    for (; s !== i && n[s] < e; ) ++s;
    for (; o !== -1 && n[o] > t; ) --o;
    if ((++o, s !== 0 || o !== i)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = xi(n, s, o)), (this.values = xi(this.values, s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this),
      (e = !1));
    const n = this.times,
      i = this.values,
      s = n.length;
    s === 0 &&
      (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const c = n[a];
      if (typeof c == 'number' && isNaN(c)) {
        console.error(
          'THREE.KeyframeTrack: Time is not a valid number.',
          this,
          a,
          c
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > c) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, a, c, o),
          (e = !1);
        break;
      }
      o = c;
    }
    if (i !== void 0 && Hp(i))
      for (let a = 0, c = i.length; a !== c; ++a) {
        const l = i[a];
        if (isNaN(l)) {
          console.error(
            'THREE.KeyframeTrack: Value is not a valid number.',
            this,
            a,
            l
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = xi(this.times),
      t = xi(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === Ya,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let c = !1;
      const l = e[a],
        h = e[a + 1];
      if (l !== h && (a !== 1 || l !== e[0]))
        if (i) c = !0;
        else {
          const f = a * n,
            u = f - n,
            p = f + n;
          for (let _ = 0; _ !== n; ++_) {
            const g = t[f + _];
            if (g !== t[u + _] || g !== t[p + _]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (a !== o) {
          e[o] = e[a];
          const f = a * n,
            u = o * n;
          for (let p = 0; p !== n; ++p) t[u + p] = t[f + p];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * n, c = o * n, l = 0; l !== n; ++l) t[c + l] = t[a + l];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = xi(e, 0, o)), (this.values = xi(t, 0, o * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = xi(this.times, 0),
      t = xi(this.values, 0),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Xn.prototype.TimeBufferType = Float32Array;
Xn.prototype.ValueBufferType = Float32Array;
Xn.prototype.DefaultInterpolation = hs;
class ys extends Xn {}
ys.prototype.ValueTypeName = 'bool';
ys.prototype.ValueBufferType = Array;
ys.prototype.DefaultInterpolation = eo;
ys.prototype.InterpolantFactoryMethodLinear = void 0;
ys.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vp extends Xn {}
Vp.prototype.ValueTypeName = 'color';
class ds extends Xn {}
ds.prototype.ValueTypeName = 'number';
class Yb extends ro {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = (n - t) / (i - t);
    let l = e * a;
    for (let h = l + a; l !== h; l += 4) ki.slerpFlat(s, 0, o, l - a, o, l, c);
    return s;
  }
}
class yr extends Xn {
  InterpolantFactoryMethodLinear(e) {
    return new Yb(this.times, this.values, this.getValueSize(), e);
  }
}
yr.prototype.ValueTypeName = 'quaternion';
yr.prototype.DefaultInterpolation = hs;
yr.prototype.InterpolantFactoryMethodSmooth = void 0;
class xs extends Xn {}
xs.prototype.ValueTypeName = 'string';
xs.prototype.ValueBufferType = Array;
xs.prototype.DefaultInterpolation = eo;
xs.prototype.InterpolantFactoryMethodLinear = void 0;
xs.prototype.InterpolantFactoryMethodSmooth = void 0;
class ps extends Xn {}
ps.prototype.ValueTypeName = 'vector';
class Kb {
  constructor(e, t = -1, n, i = $0) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = Pn()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o) t.push(Zb(n[o]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode
      };
    for (let s = 0, o = n.length; s !== o; ++s) t.push(Xn.toJSON(n[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let c = [],
        l = [];
      c.push((a + s - 1) % s, a, (a + 1) % s), l.push(0, 1, 0);
      const h = Wb(c);
      (c = bf(c, 1, h)),
        (l = bf(l, 1, h)),
        !i && c[0] === 0 && (c.push(s), l.push(l[0])),
        o.push(
          new ds('.morphTargetInfluences[' + t[a].name + ']', c, l).scale(1 / n)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, c = e.length; a < c; a++) {
      const l = e[a],
        h = l.name.match(s);
      if (h && h.length > 1) {
        const f = h[1];
        let u = i[f];
        u || (i[f] = u = []), u.push(l);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error('THREE.AnimationClip: No animation in JSONLoader data.'),
        null
      );
    const n = function (f, u, p, _, g) {
        if (p.length !== 0) {
          const d = [],
            m = [];
          Gp(p, d, m, _), d.length !== 0 && g.push(new f(u, d, m));
        }
      },
      i = [],
      s = e.name || 'default',
      o = e.fps || 30,
      a = e.blendMode;
    let c = e.length || -1;
    const l = e.hierarchy || [];
    for (let f = 0; f < l.length; f++) {
      const u = l[f].keys;
      if (!(!u || u.length === 0))
        if (u[0].morphTargets) {
          const p = {};
          let _;
          for (_ = 0; _ < u.length; _++)
            if (u[_].morphTargets)
              for (let g = 0; g < u[_].morphTargets.length; g++)
                p[u[_].morphTargets[g]] = -1;
          for (const g in p) {
            const d = [],
              m = [];
            for (let y = 0; y !== u[_].morphTargets.length; ++y) {
              const v = u[_];
              d.push(v.time), m.push(v.morphTarget === g ? 1 : 0);
            }
            i.push(new ds('.morphTargetInfluence[' + g + ']', d, m));
          }
          c = p.length * o;
        } else {
          const p = '.bones[' + t[f].name + ']';
          n(ps, p + '.position', u, 'pos', i),
            n(yr, p + '.quaternion', u, 'rot', i),
            n(ps, p + '.scale', u, 'scl', i);
        }
    }
    return i.length === 0 ? null : new this(s, c, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function $b(r) {
  switch (r.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return ds;
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return ps;
    case 'color':
      return Vp;
    case 'quaternion':
      return yr;
    case 'bool':
    case 'boolean':
      return ys;
    case 'string':
      return xs;
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + r);
}
function Zb(r) {
  if (r.type === void 0)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  const e = $b(r.type);
  if (r.times === void 0) {
    const t = [],
      n = [];
    Gp(r.keys, t, n, 'value'), (r.times = t), (r.values = n);
  }
  return e.parse !== void 0
    ? e.parse(r)
    : new e(r.name, r.times, r.values, r.interpolation);
}
const ms = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  }
};
class Jb {
  constructor(e, t, n) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      c;
    const l = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (h) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(h, o, a), (s = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          i.onProgress !== void 0 && i.onProgress(h, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return c ? c(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (c = h), this;
      }),
      (this.addHandler = function (h, f) {
        return l.push(h, f), this;
      }),
      (this.removeHandler = function (h) {
        const f = l.indexOf(h);
        return f !== -1 && l.splice(f, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let f = 0, u = l.length; f < u; f += 2) {
          const p = l[f],
            _ = l[f + 1];
          if ((p.global && (p.lastIndex = 0), p.test(h))) return _;
        }
        return null;
      });
  }
}
const Qb = new Jb();
class Mr {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Qb),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Mr.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const ei = {};
class eE extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class fa extends Mr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = ms.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (ei[e] !== void 0) {
      ei[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (ei[e] = []), ei[e].push({ onLoad: t, onProgress: n, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin'
      }),
      a = this.mimeType,
      c = this.responseType;
    fetch(o)
      .then((l) => {
        if (l.status === 200 || l.status === 0) {
          if (
            (l.status === 0 &&
              console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' ||
              l.body === void 0 ||
              l.body.getReader === void 0)
          )
            return l;
          const h = ei[e],
            f = l.body.getReader(),
            u = l.headers.get('Content-Length') || l.headers.get('X-File-Size'),
            p = u ? parseInt(u) : 0,
            _ = p !== 0;
          let g = 0;
          const d = new ReadableStream({
            start(m) {
              y();
              function y() {
                f.read().then(({ done: v, value: x }) => {
                  if (v) m.close();
                  else {
                    g += x.byteLength;
                    const S = new ProgressEvent('progress', {
                      lengthComputable: _,
                      loaded: g,
                      total: p
                    });
                    for (let b = 0, T = h.length; b < T; b++) {
                      const C = h[b];
                      C.onProgress && C.onProgress(S);
                    }
                    m.enqueue(x), y();
                  }
                });
              }
            }
          });
          return new Response(d);
        } else
          throw new eE(
            `fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`,
            l
          );
      })
      .then((l) => {
        switch (c) {
          case 'arraybuffer':
            return l.arrayBuffer();
          case 'blob':
            return l.blob();
          case 'document':
            return l.text().then((h) => new DOMParser().parseFromString(h, a));
          case 'json':
            return l.json();
          default:
            if (a === void 0) return l.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a),
                u = f && f[1] ? f[1].toLowerCase() : void 0,
                p = new TextDecoder(u);
              return l.arrayBuffer().then((_) => p.decode(_));
            }
        }
      })
      .then((l) => {
        ms.add(e, l);
        const h = ei[e];
        delete ei[e];
        for (let f = 0, u = h.length; f < u; f++) {
          const p = h[f];
          p.onLoad && p.onLoad(l);
        }
      })
      .catch((l) => {
        const h = ei[e];
        if (h === void 0) throw (this.manager.itemError(e), l);
        delete ei[e];
        for (let f = 0, u = h.length; f < u; f++) {
          const p = h[f];
          p.onError && p.onError(l);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class tE extends Mr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = ms.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = to('img');
    function c() {
      h(), ms.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function l(f) {
      h(), i && i(f), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener('load', c, !1),
        a.removeEventListener('error', l, !1);
    }
    return (
      a.addEventListener('load', c, !1),
      a.addEventListener('error', l, !1),
      e.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class nE extends Mr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new Ct(),
      o = new tE(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        n,
        i
      ),
      s
    );
  }
}
class ba extends st {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new Re(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const xc = new Ue(),
  Ef = new P(),
  Tf = new P();
class Jl {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ve(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Ue()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Wl()),
      (this._frameExtents = new Ve(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Je(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    Ef.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Ef),
      Tf.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Tf),
      t.updateMatrixWorld(),
      xc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(xc),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(xc);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class iE extends Jl {
  constructor() {
    super(new Wt(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = us * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class rE extends ba {
  constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(st.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new st()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new iE());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Af = new Ue(),
  Ps = new P(),
  Mc = new P();
class sE extends Jl {
  constructor() {
    super(new Wt(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ve(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Je(2, 1, 1, 1),
        new Je(0, 1, 1, 1),
        new Je(3, 1, 1, 1),
        new Je(1, 1, 1, 1),
        new Je(3, 0, 1, 1),
        new Je(1, 0, 1, 1)
      ]),
      (this._cubeDirections = [
        new P(1, 0, 0),
        new P(-1, 0, 0),
        new P(0, 0, 1),
        new P(0, 0, -1),
        new P(0, 1, 0),
        new P(0, -1, 0)
      ]),
      (this._cubeUps = [
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 0, 1),
        new P(0, 0, -1)
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      Ps.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(Ps),
      Mc.copy(n.position),
      Mc.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(Mc),
      n.updateMatrixWorld(),
      i.makeTranslation(-Ps.x, -Ps.y, -Ps.z),
      Af.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Af);
  }
}
class oE extends ba {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new sE());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class aE extends Jl {
  constructor() {
    super(new Xl(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Wp extends ba {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(st.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new st()),
      (this.shadow = new aE());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class cE extends ba {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
  }
}
class cl {
  static decodeText(e) {
    if (typeof TextDecoder < 'u') return new TextDecoder().decode(e);
    let t = '';
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf('/');
    return t === -1 ? './' : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != 'string' || e === ''
      ? ''
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class lE extends Mr {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        console.warn(
          'THREE.ImageBitmapLoader: createImageBitmap() not supported.'
        ),
      typeof fetch > 'u' &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = ms.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (c) {
          return c.blob();
        })
        .then(function (c) {
          return createImageBitmap(
            c,
            Object.assign(s.options, { colorSpaceConversion: 'none' })
          );
        })
        .then(function (c) {
          ms.add(e, c), t && t(c), s.manager.itemEnd(e);
        })
        .catch(function (c) {
          i && i(c), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
const Ql = '\\[\\]\\.:\\/',
  hE = new RegExp('[' + Ql + ']', 'g'),
  eh = '[^' + Ql + ']',
  uE = '[^' + Ql.replace('\\.', '') + ']',
  fE = /((?:WC+[\/:])*)/.source.replace('WC', eh),
  dE = /(WCOD+)?/.source.replace('WCOD', uE),
  pE = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', eh),
  mE = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', eh),
  gE = new RegExp('^' + fE + dE + pE + mE + '$'),
  _E = ['material', 'materials', 'bones', 'map'];
class vE {
  constructor(e, t, n) {
    const i = n || je.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class je {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || je.parseTrackName(t)),
      (this.node = je.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new je.Composite(e, t, n)
      : new je(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, '_').replace(hE, '');
  }
  static parseTrackName(e) {
    const t = gE.exec(e);
    if (t === null)
      throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6]
      },
      i = n.nodeName && n.nodeName.lastIndexOf('.');
    if (i !== void 0 && i !== -1) {
      const s = n.nodeName.substring(i + 1);
      _E.indexOf(s) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = s));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === '' ||
      t === '.' ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const c = n(a.children);
            if (c) return c;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = je.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        'THREE.PropertyBinding: No target node found for track: ' +
          this.path +
          '.'
      );
      return;
    }
    if (n) {
      let l = t.objectIndex;
      switch (n) {
        case 'materials':
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case 'bones':
          if (!e.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === l) {
              l = h;
              break;
            }
          break;
        case 'map':
          if ('map' in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this
            );
            return;
          }
          e = e[n];
      }
      if (l !== void 0) {
        if (e[l] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            e
          );
          return;
        }
        e = e[l];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const l = t.nodeName;
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          l +
          '.' +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === 'morphTargetInfluences') {
        if (!e.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (c = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[c]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[c][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
je.Composite = vE;
je.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
je.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
je.prototype.GetterByBindingType = [
  je.prototype._getValue_direct,
  je.prototype._getValue_array,
  je.prototype._getValue_arrayElement,
  je.prototype._getValue_toArray
];
je.prototype.SetterByBindingTypeAndVersioning = [
  [
    je.prototype._setValue_direct,
    je.prototype._setValue_direct_setNeedsUpdate,
    je.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    je.prototype._setValue_array,
    je.prototype._setValue_array_setNeedsUpdate,
    je.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    je.prototype._setValue_arrayElement,
    je.prototype._setValue_arrayElement_setNeedsUpdate,
    je.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    je.prototype._setValue_fromArray,
    je.prototype._setValue_fromArray_setNeedsUpdate,
    je.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', { detail: { revision: Hl } })
  );
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = Hl));
const Sc = new WeakMap();
class yE extends Mr {
  constructor(e) {
    super(e),
      (this.decoderPath = ''),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ''),
      (this.defaultAttributeIDs = {
        position: 'POSITION',
        normal: 'NORMAL',
        color: 'COLOR',
        uv: 'TEX_COORD'
      }),
      (this.defaultAttributeTypes = {
        position: 'Float32Array',
        normal: 'Float32Array',
        color: 'Float32Array',
        uv: 'Float32Array'
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, n, i) {
    const s = new fa(this.manager);
    s.setPath(this.path),
      s.setResponseType('arraybuffer'),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          this.parse(o, t, i);
        },
        n,
        i
      );
  }
  parse(e, t, n) {
    this.decodeDracoFile(e, t, null, null, qe).catch(n);
  }
  decodeDracoFile(e, t, n, i, s = _t) {
    const o = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: s
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const n = JSON.stringify(t);
    if (Sc.has(e)) {
      const c = Sc.get(e);
      if (c.key === n) return c.promise;
      if (e.byteLength === 0)
        throw new Error(
          'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.'
        );
    }
    let i;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (c) => (
            (i = c),
            new Promise((l, h) => {
              (i._callbacks[s] = { resolve: l, reject: h }),
                i.postMessage(
                  { type: 'decode', id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((c) => this._createGeometry(c.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          i && s && this._releaseTask(i, s);
        }),
      Sc.set(e, { key: n, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new Dn();
    e.index && t.setIndex(new Lt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        s = i.name,
        o = i.array,
        a = i.itemSize,
        c = new Lt(o, a);
      s === 'color' &&
        (this._assignVertexColorSpace(c, i.vertexColorSpace),
        (c.normalized = !(o instanceof Float32Array))),
        t.setAttribute(s, c);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== qe) return;
    const n = new Re();
    for (let i = 0, s = e.count; i < s; i++)
      n.fromBufferAttribute(e, i).convertSRGBToLinear(),
        e.setXYZ(i, n.r, n.g, n.b);
  }
  _loadLibrary(e, t) {
    const n = new fa(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, s) => {
        n.load(e, i, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != 'object' || this.decoderConfig.type === 'js',
      t = [];
    return (
      e
        ? t.push(this._loadLibrary('draco_decoder.js', 'text'))
        : (t.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
          t.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
      (this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const s = xE.toString(),
          o = [
            '/* draco decoder */',
            i,
            '',
            '/* worker */',
            s.substring(s.indexOf('{') + 1, s.lastIndexOf('}'))
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: 'init', decoderConfig: this.decoderConfig }),
          (i.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case 'decode':
                i._callbacks[o.id].resolve(o);
                break;
              case 'error':
                i._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, s) {
          return i._taskLoad > s._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      'Task load: ',
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (
      (this.workerPool.length = 0),
      this.workerSourceURL !== '' && URL.revokeObjectURL(this.workerSourceURL),
      this
    );
  }
}
function xE() {
  let r, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case 'init':
        (r = a.decoderConfig),
          (e = new Promise(function (h) {
            (r.onModuleLoaded = function (f) {
              h({ draco: f });
            }),
              DracoDecoderModule(r);
          }));
        break;
      case 'decode':
        const c = a.buffer,
          l = a.taskConfig;
        e.then((h) => {
          const f = h.draco,
            u = new f.Decoder();
          try {
            const p = t(f, u, new Int8Array(c), l),
              _ = p.attributes.map((g) => g.array.buffer);
            p.index && _.push(p.index.array.buffer),
              self.postMessage({ type: 'decode', id: a.id, geometry: p }, _);
          } catch (p) {
            console.error(p),
              self.postMessage({ type: 'error', id: a.id, error: p.message });
          } finally {
            f.destroy(u);
          }
        });
        break;
    }
  };
  function t(o, a, c, l) {
    const h = l.attributeIDs,
      f = l.attributeTypes;
    let u, p;
    const _ = a.GetEncodedGeometryType(c);
    if (_ === o.TRIANGULAR_MESH)
      (u = new o.Mesh()), (p = a.DecodeArrayToMesh(c, c.byteLength, u));
    else if (_ === o.POINT_CLOUD)
      (u = new o.PointCloud()),
        (p = a.DecodeArrayToPointCloud(c, c.byteLength, u));
    else throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
    if (!p.ok() || u.ptr === 0)
      throw new Error('THREE.DRACOLoader: Decoding failed: ' + p.error_msg());
    const g = { index: null, attributes: [] };
    for (const d in h) {
      const m = self[f[d]];
      let y, v;
      if (l.useUniqueIDs) (v = h[d]), (y = a.GetAttributeByUniqueId(u, v));
      else {
        if (((v = a.GetAttributeId(u, o[h[d]])), v === -1)) continue;
        y = a.GetAttribute(u, v);
      }
      const x = i(o, a, u, d, m, y);
      d === 'color' && (x.vertexColorSpace = l.vertexColorSpace),
        g.attributes.push(x);
    }
    return _ === o.TRIANGULAR_MESH && (g.index = n(o, a, u)), o.destroy(u), g;
  }
  function n(o, a, c) {
    const h = c.num_faces() * 3,
      f = h * 4,
      u = o._malloc(f);
    a.GetTrianglesUInt32Array(c, f, u);
    const p = new Uint32Array(o.HEAPF32.buffer, u, h).slice();
    return o._free(u), { array: p, itemSize: 1 };
  }
  function i(o, a, c, l, h, f) {
    const u = f.num_components(),
      _ = c.num_points() * u,
      g = _ * h.BYTES_PER_ELEMENT,
      d = s(o, h),
      m = o._malloc(g);
    a.GetAttributeDataArrayForAllPoints(c, f, d, g, m);
    const y = new h(o.HEAPF32.buffer, m, _).slice();
    return o._free(m), { name: l, array: y, itemSize: u };
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
function wf(r, e) {
  if (e === Z0)
    return (
      console.warn(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.'
      ),
      r
    );
  if (e === nl || e === _p) {
    let t = r.getIndex();
    if (t === null) {
      const o = [],
        a = r.getAttribute('position');
      if (a !== void 0) {
        for (let c = 0; c < a.count; c++) o.push(c);
        r.setIndex(o), (t = r.getIndex());
      } else
        return (
          console.error(
            'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
          ),
          r
        );
    }
    const n = t.count - 2,
      i = [];
    if (e === nl)
      for (let o = 1; o <= n; o++)
        i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
    else
      for (let o = 0; o < n; o++)
        o % 2 === 0
          ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2)))
          : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    i.length / 3 !== n &&
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.'
      );
    const s = r.clone();
    return s.setIndex(i), s.clearGroups(), s;
  } else
    return (
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:',
        e
      ),
      r
    );
}
class ME extends Mr {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new AE(t);
      }),
      this.register(function (t) {
        return new OE(t);
      }),
      this.register(function (t) {
        return new UE(t);
      }),
      this.register(function (t) {
        return new NE(t);
      }),
      this.register(function (t) {
        return new RE(t);
      }),
      this.register(function (t) {
        return new CE(t);
      }),
      this.register(function (t) {
        return new LE(t);
      }),
      this.register(function (t) {
        return new PE(t);
      }),
      this.register(function (t) {
        return new TE(t);
      }),
      this.register(function (t) {
        return new DE(t);
      }),
      this.register(function (t) {
        return new wE(t);
      }),
      this.register(function (t) {
        return new IE(t);
      }),
      this.register(function (t) {
        return new bE(t);
      }),
      this.register(function (t) {
        return new FE(t);
      }),
      this.register(function (t) {
        return new kE(t);
      });
  }
  load(e, t, n, i) {
    const s = this;
    let o;
    this.resourcePath !== ''
      ? (o = this.resourcePath)
      : this.path !== ''
      ? (o = this.path)
      : (o = cl.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (l) {
        i ? i(l) : console.error(l),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      c = new fa(this.manager);
    c.setPath(this.path),
      c.setResponseType('arraybuffer'),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(this.withCredentials),
      c.load(
        e,
        function (l) {
          try {
            s.parse(
              l,
              o,
              function (h) {
                t(h), s.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        n,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let s;
    const o = {},
      a = {},
      c = new TextDecoder();
    if (typeof e == 'string') s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === qp) {
        try {
          o[He.KHR_BINARY_GLTF] = new BE(e);
        } catch (f) {
          i && i(f);
          return;
        }
        s = JSON.parse(o[He.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(c.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'
          )
        );
      return;
    }
    const l = new JE(s, {
      path: t || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const f = this.pluginCallbacks[h](l);
      (a[f.name] = f), (o[f.name] = !0);
    }
    if (s.extensionsUsed)
      for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const f = s.extensionsUsed[h],
          u = s.extensionsRequired || [];
        switch (f) {
          case He.KHR_MATERIALS_UNLIT:
            o[f] = new EE();
            break;
          case He.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new zE(s, this.dracoLoader);
            break;
          case He.KHR_TEXTURE_TRANSFORM:
            o[f] = new HE();
            break;
          case He.KHR_MESH_QUANTIZATION:
            o[f] = new GE();
            break;
          default:
            u.indexOf(f) >= 0 &&
              a[f] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.parse(e, t, i, s);
    });
  }
}
function SE() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    }
  };
}
const He = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};
class bE {
  constructor(e) {
    (this.parser = e),
      (this.name = He.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = 'light:' + e;
    let i = t.cache.get(n);
    if (i) return i;
    const s = t.json,
      c = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let l;
    const h = new Re(16777215);
    c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], _t);
    const f = c.range !== void 0 ? c.range : 0;
    switch (c.type) {
      case 'directional':
        (l = new Wp(h)), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case 'point':
        (l = new oE(h)), (l.distance = f);
        break;
      case 'spot':
        (l = new rE(h)),
          (l.distance = f),
          (c.spot = c.spot || {}),
          (c.spot.innerConeAngle =
            c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0),
          (c.spot.outerConeAngle =
            c.spot.outerConeAngle !== void 0
              ? c.spot.outerConeAngle
              : Math.PI / 4),
          (l.angle = c.spot.outerConeAngle),
          (l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle),
          l.target.position.set(0, 0, -1),
          l.add(l.target);
        break;
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + c.type);
    }
    return (
      l.position.set(0, 0, 0),
      (l.decay = 2),
      Ei(l, c),
      c.intensity !== void 0 && (l.intensity = c.intensity),
      (l.name = t.createUniqueName(c.name || 'light_' + e)),
      (i = Promise.resolve(l)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === 'light') return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      s = n.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (c) {
          return n._getNodeRef(t.cache, a, c);
        });
  }
}
class EE {
  constructor() {
    this.name = He.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return rr;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new Re(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], _t), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, 'map', s.baseColorTexture, qe));
    }
    return Promise.all(i);
  }
}
class TE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class AE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(n.assignTexture(t, 'clearcoatMap', o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            'clearcoatRoughnessMap',
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          n.assignTexture(t, 'clearcoatNormalMap', o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ve(a, a);
    }
    return Promise.all(s);
  }
}
class wE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(n.assignTexture(t, 'iridescenceMap', o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            'iridescenceThicknessMap',
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class RE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Re(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = i.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], _t);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(n.assignTexture(t, 'sheenColorMap', o.sheenColorTexture, qe)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(t, 'sheenRoughnessMap', o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class CE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(n.assignTexture(t, 'transmissionMap', o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class LE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(n.assignTexture(t, 'thicknessMap', o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new Re().setRGB(a[0], a[1], a[2], _t)),
      Promise.all(s)
    );
  }
}
class PE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class DE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(n.assignTexture(t, 'specularIntensityMap', o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Re().setRGB(a[0], a[1], a[2], _t)),
      o.specularColorTexture !== void 0 &&
        s.push(
          n.assignTexture(t, 'specularColorMap', o.specularColorTexture, qe)
        ),
      Promise.all(s)
    );
  }
}
class IE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Bi;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(n.assignTexture(t, 'anisotropyMap', o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class OE {
  constructor(e) {
    (this.parser = e), (this.name = He.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const s = i.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures'
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class UE {
  constructor(e) {
    (this.parser = e),
      (this.name = He.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = i.images[o.source];
    let c = n.textureLoader;
    if (a.uri) {
      const l = n.options.manager.getHandler(a.uri);
      l !== null && (c = l);
    }
    return this.detectSupport().then(function (l) {
      if (l) return n.loadTextureImage(e, o.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          'THREE.GLTFLoader: WebP required by asset but unsupported.'
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class NE {
  constructor(e) {
    (this.parser = e),
      (this.name = He.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = i.images[o.source];
    let c = n.textureLoader;
    if (a.uri) {
      const l = n.options.manager.getHandler(a.uri);
      l !== null && (c = l);
    }
    return this.detectSupport().then(function (l) {
      if (l) return n.loadTextureImage(e, o.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          'THREE.GLTFLoader: AVIF required by asset but unsupported.'
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class FE {
  constructor(e) {
    (this.name = He.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        s = this.parser.getDependency('buffer', i.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
          );
        return null;
      }
      return s.then(function (a) {
        const c = i.byteOffset || 0,
          l = i.byteLength || 0,
          h = i.count,
          f = i.byteStride,
          u = new Uint8Array(a, c, l);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, f, u, i.mode, i.filter)
              .then(function (p) {
                return p.buffer;
              })
          : o.ready.then(function () {
              const p = new ArrayBuffer(h * f);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(p),
                  h,
                  f,
                  u,
                  i.mode,
                  i.filter
                ),
                p
              );
            });
      });
    } else return null;
  }
}
class kE {
  constructor(e) {
    (this.name = He.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const l of i.primitives)
      if (
        l.mode !== gn.TRIANGLES &&
        l.mode !== gn.TRIANGLE_STRIP &&
        l.mode !== gn.TRIANGLE_FAN &&
        l.mode !== void 0
      )
        return null;
    const o = n.extensions[this.name].attributes,
      a = [],
      c = {};
    for (const l in o)
      a.push(
        this.parser
          .getDependency('accessor', o[l])
          .then((h) => ((c[l] = h), c[l]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((l) => {
          const h = l.pop(),
            f = h.isGroup ? h.children : [h],
            u = l[0].count,
            p = [];
          for (const _ of f) {
            const g = new Ue(),
              d = new P(),
              m = new ki(),
              y = new P(1, 1, 1),
              v = new zb(_.geometry, _.material, u);
            for (let x = 0; x < u; x++)
              c.TRANSLATION && d.fromBufferAttribute(c.TRANSLATION, x),
                c.ROTATION && m.fromBufferAttribute(c.ROTATION, x),
                c.SCALE && y.fromBufferAttribute(c.SCALE, x),
                v.setMatrixAt(x, g.compose(d, m, y));
            for (const x in c)
              x !== 'TRANSLATION' &&
                x !== 'ROTATION' &&
                x !== 'SCALE' &&
                _.geometry.setAttribute(x, c[x]);
            st.prototype.copy.call(v, _),
              this.parser.assignFinalMaterial(v),
              p.push(v);
          }
          return h.isGroup ? (h.clear(), h.add(...p), h) : p[0];
        }));
  }
}
const qp = 'glTF',
  Ds = 12,
  Rf = { JSON: 1313821514, BIN: 5130562 };
class BE {
  constructor(e) {
    (this.name = He.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Ds),
      n = new TextDecoder();
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0)
      }),
      this.header.magic !== qp)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    if (this.header.version < 2)
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
    const i = this.header.length - Ds,
      s = new DataView(e, Ds);
    let o = 0;
    for (; o < i; ) {
      const a = s.getUint32(o, !0);
      o += 4;
      const c = s.getUint32(o, !0);
      if (((o += 4), c === Rf.JSON)) {
        const l = new Uint8Array(e, Ds + o, a);
        this.content = n.decode(l);
      } else if (c === Rf.BIN) {
        const l = Ds + o;
        this.body = e.slice(l, l + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error('THREE.GLTFLoader: JSON content not found.');
  }
}
class zE {
  constructor(e, t) {
    if (!t)
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    (this.name = He.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      c = {},
      l = {};
    for (const h in o) {
      const f = ll[h] || h.toLowerCase();
      a[f] = o[h];
    }
    for (const h in e.attributes) {
      const f = ll[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const u = n.accessors[e.attributes[h]],
          p = es[u.componentType];
        (l[f] = p.name), (c[f] = u.normalized === !0);
      }
    }
    return t.getDependency('bufferView', s).then(function (h) {
      return new Promise(function (f) {
        i.decodeDracoFile(
          h,
          function (u) {
            for (const p in u.attributes) {
              const _ = u.attributes[p],
                g = c[p];
              g !== void 0 && (_.normalized = g);
            }
            f(u);
          },
          a,
          l
        );
      });
    });
  }
}
class HE {
  constructor() {
    this.name = He.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class GE {
  constructor() {
    this.name = He.KHR_MESH_QUANTIZATION;
  }
}
class Xp extends ro {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i * 3 + i;
    for (let o = 0; o !== i; o++) t[o] = n[s + o];
    return t;
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = a * 2,
      l = a * 3,
      h = i - t,
      f = (n - t) / h,
      u = f * f,
      p = u * f,
      _ = e * l,
      g = _ - l,
      d = -2 * p + 3 * u,
      m = p - u,
      y = 1 - d,
      v = m - u + f;
    for (let x = 0; x !== a; x++) {
      const S = o[g + x + a],
        b = o[g + x + c] * h,
        T = o[_ + x + a],
        C = o[_ + x] * h;
      s[x] = y * S + v * b + d * T + m * C;
    }
    return s;
  }
}
const VE = new ki();
class WE extends Xp {
  interpolate_(e, t, n, i) {
    const s = super.interpolate_(e, t, n, i);
    return VE.fromArray(s).normalize().toArray(s), s;
  }
}
const gn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  },
  es = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
  Cf = { 9728: Et, 9729: jt, 9984: tl, 9985: hp, 9986: Zo, 9987: gr },
  Lf = { 33071: vn, 33648: la, 10497: cs },
  bc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  ll = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv1',
    TEXCOORD_2: 'uv2',
    TEXCOORD_3: 'uv3',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  },
  Mi = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  },
  qE = { CUBICSPLINE: void 0, LINEAR: hs, STEP: eo },
  Ec = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' };
function XE(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new Zl({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: ui
      })),
    r.DefaultMaterial
  );
}
function Yi(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function Ei(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == 'object'
      ? Object.assign(r.userData, e.extras)
      : console.warn(
          'THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras
        ));
}
function jE(r, e, t) {
  let n = !1,
    i = !1,
    s = !1;
  for (let l = 0, h = e.length; l < h; l++) {
    const f = e[l];
    if (
      (f.POSITION !== void 0 && (n = !0),
      f.NORMAL !== void 0 && (i = !0),
      f.COLOR_0 !== void 0 && (s = !0),
      n && i && s)
    )
      break;
  }
  if (!n && !i && !s) return Promise.resolve(r);
  const o = [],
    a = [],
    c = [];
  for (let l = 0, h = e.length; l < h; l++) {
    const f = e[l];
    if (n) {
      const u =
        f.POSITION !== void 0
          ? t.getDependency('accessor', f.POSITION)
          : r.attributes.position;
      o.push(u);
    }
    if (i) {
      const u =
        f.NORMAL !== void 0
          ? t.getDependency('accessor', f.NORMAL)
          : r.attributes.normal;
      a.push(u);
    }
    if (s) {
      const u =
        f.COLOR_0 !== void 0
          ? t.getDependency('accessor', f.COLOR_0)
          : r.attributes.color;
      c.push(u);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c)]).then(
    function (l) {
      const h = l[0],
        f = l[1],
        u = l[2];
      return (
        n && (r.morphAttributes.position = h),
        i && (r.morphAttributes.normal = f),
        s && (r.morphAttributes.color = u),
        (r.morphTargetsRelative = !0),
        r
      );
    }
  );
}
function YE(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        r.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.'
      );
  }
}
function KE(r) {
  let e;
  const t = r.extensions && r.extensions[He.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = 'draco:' + t.bufferView + ':' + t.indices + ':' + Tc(t.attributes))
      : (e = r.indices + ':' + Tc(r.attributes) + ':' + r.mode),
    r.targets !== void 0)
  )
    for (let n = 0, i = r.targets.length; n < i; n++)
      e += ':' + Tc(r.targets[n]);
  return e;
}
function Tc(r) {
  let e = '';
  const t = Object.keys(r).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ':' + r[t[n]] + ';';
  return e;
}
function hl(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        'THREE.GLTFLoader: Unsupported normalized accessor component type.'
      );
  }
}
function $E(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? 'image/jpeg'
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? 'image/webp'
    : 'image/png';
}
const ZE = new Ue();
class JE {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new SE()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      s = -1;
    typeof navigator < 'u' &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf('Firefox') > -1),
      (s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > 'u' || n || (i && s < 98)
        ? (this.textureLoader = new nE(this.options.manager))
        : (this.textureLoader = new lE(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new fa(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      this.options.crossOrigin === 'use-credentials' &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies('scene'),
            n.getDependencies('animation'),
            n.getDependencies('camera')
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][i.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: i.asset,
            parser: n,
            userData: {}
          };
          Yi(s, a, i),
            Ei(a, i),
            Promise.all(
              n._invokeAll(function (c) {
                return c.afterRoot && c.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i].joints;
      for (let a = 0, c = o.length; a < c; a++) e[o[a]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      s = (o, a) => {
        const c = this.associations.get(o);
        c != null && this.associations.set(a, c);
        for (const [l, h] of o.children.entries()) s(h, a.children[l]);
      };
    return s(n, i), (i.name += '_instance_' + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const s = e(t[i]);
      s && n.push(s);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ':' + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case 'scene':
          i = this.loadScene(t);
          break;
        case 'node':
          i = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case 'mesh':
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case 'accessor':
          i = this.loadAccessor(t);
          break;
        case 'bufferView':
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case 'buffer':
          i = this.loadBuffer(t);
          break;
        case 'material':
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case 'texture':
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case 'skin':
          i = this.loadSkin(t);
          break;
        case 'animation':
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case 'camera':
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !i)
          )
            throw new Error('Unknown type: ' + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === 'mesh' ? 'es' : 's')] || [];
      (t = Promise.all(
        i.map(function (s, o) {
          return n.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== 'arraybuffer')
      throw new Error(
        'THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.'
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[He.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (s, o) {
      n.load(cl.resolveURL(t.uri, i.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency('buffer', t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        s = t.byteOffset || 0;
      return n.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = bc[i.type],
        a = es[i.componentType],
        c = i.normalized === !0,
        l = new a(i.count * o);
      return Promise.resolve(new Lt(l, o, c));
    }
    const s = [];
    return (
      i.bufferView !== void 0
        ? s.push(this.getDependency('bufferView', i.bufferView))
        : s.push(null),
      i.sparse !== void 0 &&
        (s.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
        s.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          c = bc[i.type],
          l = es[i.componentType],
          h = l.BYTES_PER_ELEMENT,
          f = h * c,
          u = i.byteOffset || 0,
          p =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          _ = i.normalized === !0;
        let g, d;
        if (p && p !== f) {
          const m = Math.floor(u / p),
            y =
              'InterleavedBuffer:' +
              i.bufferView +
              ':' +
              i.componentType +
              ':' +
              m +
              ':' +
              i.count;
          let v = t.cache.get(y);
          v ||
            ((g = new l(a, m * p, (i.count * p) / h)),
            (v = new Ob(g, p / h)),
            t.cache.add(y, v)),
            (d = new Yl(v, c, (u % p) / h, _));
        } else
          a === null
            ? (g = new l(i.count * c))
            : (g = new l(a, u, i.count * c)),
            (d = new Lt(g, c, _));
        if (i.sparse !== void 0) {
          const m = bc.SCALAR,
            y = es[i.sparse.indices.componentType],
            v = i.sparse.indices.byteOffset || 0,
            x = i.sparse.values.byteOffset || 0,
            S = new y(o[1], v, i.sparse.count * m),
            b = new l(o[2], x, i.sparse.count * c);
          a !== null && (d = new Lt(d.array.slice(), d.itemSize, d.normalized));
          for (let T = 0, C = S.length; T < C; T++) {
            const M = S[T];
            if (
              (d.setX(M, b[T * c]),
              c >= 2 && d.setY(M, b[T * c + 1]),
              c >= 3 && d.setZ(M, b[T * c + 2]),
              c >= 4 && d.setW(M, b[T * c + 3]),
              c >= 5)
            )
              throw new Error(
                'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.'
              );
          }
        }
        return d;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const c = n.manager.getHandler(o.uri);
      c !== null && (a = c);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      c = (a.uri || a.bufferView) + ':' + o.sampler;
    if (this.textureCache[c]) return this.textureCache[c];
    const l = this.loadImageSource(t, n)
      .then(function (h) {
        (h.flipY = !1),
          (h.name = o.name || a.name || ''),
          h.name === '' &&
            typeof a.uri == 'string' &&
            a.uri.startsWith('data:image/') === !1 &&
            (h.name = a.uri);
        const u = (s.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = Cf[u.magFilter] || jt),
          (h.minFilter = Cf[u.minFilter] || gr),
          (h.wrapS = Lf[u.wrapS] || cs),
          (h.wrapT = Lf[u.wrapT] || cs),
          i.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[c] = l), l;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((f) => f.clone());
    const o = i.images[e],
      a = self.URL || self.webkitURL;
    let c = o.uri || '',
      l = !1;
    if (o.bufferView !== void 0)
      c = n.getDependency('bufferView', o.bufferView).then(function (f) {
        l = !0;
        const u = new Blob([f], { type: o.mimeType });
        return (c = a.createObjectURL(u)), c;
      });
    else if (o.uri === void 0)
      throw new Error(
        'THREE.GLTFLoader: Image ' + e + ' is missing URI and bufferView'
      );
    const h = Promise.resolve(c)
      .then(function (f) {
        return new Promise(function (u, p) {
          let _ = u;
          t.isImageBitmapLoader === !0 &&
            (_ = function (g) {
              const d = new Ct(g);
              (d.needsUpdate = !0), u(d);
            }),
            t.load(cl.resolveURL(f, s.path), _, void 0, p);
        });
      })
      .then(function (f) {
        return (
          l === !0 && a.revokeObjectURL(c),
          (f.userData.mimeType = o.mimeType || $E(o.uri)),
          f
        );
      })
      .catch(function (f) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", c), f);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, n, i) {
    const s = this;
    return this.getDependency('texture', n.index).then(function (o) {
      if (!o) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((o = o.clone()), (o.channel = n.texCoord)),
        s.extensions[He.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          n.extensions !== void 0
            ? n.extensions[He.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const c = s.associations.get(o);
          (o = s.extensions[He.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, c);
        }
      }
      return i !== void 0 && (o.colorSpace = i), (e[t] = o), o;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = 'PointsMaterial:' + n.uuid;
      let c = this.cache.get(a);
      c ||
        ((c = new zp()),
        Hn.prototype.copy.call(c, n),
        c.color.copy(n.color),
        (c.map = n.map),
        (c.sizeAttenuation = !1),
        this.cache.add(a, c)),
        (n = c);
    } else if (e.isLine) {
      const a = 'LineBasicMaterial:' + n.uuid;
      let c = this.cache.get(a);
      c ||
        ((c = new Bp()),
        Hn.prototype.copy.call(c, n),
        c.color.copy(n.color),
        (c.map = n.map),
        this.cache.add(a, c)),
        (n = c);
    }
    if (i || s || o) {
      let a = 'ClonedMaterial:' + n.uuid + ':';
      i && (a += 'derivative-tangents:'),
        s && (a += 'vertex-colors:'),
        o && (a += 'flat-shading:');
      let c = this.cache.get(a);
      c ||
        ((c = n.clone()),
        s && (c.vertexColors = !0),
        o && (c.flatShading = !0),
        i &&
          (c.normalScale && (c.normalScale.y *= -1),
          c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, c),
        this.associations.set(c, this.associations.get(n))),
        (n = c);
    }
    e.material = n;
  }
  getMaterialType() {
    return Zl;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[e];
    let o;
    const a = {},
      c = s.extensions || {},
      l = [];
    if (c[He.KHR_MATERIALS_UNLIT]) {
      const f = i[He.KHR_MATERIALS_UNLIT];
      (o = f.getMaterialType()), l.push(f.extendParams(a, s, t));
    } else {
      const f = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Re(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(f.baseColorFactor))
      ) {
        const u = f.baseColorFactor;
        a.color.setRGB(u[0], u[1], u[2], _t), (a.opacity = u[3]);
      }
      f.baseColorTexture !== void 0 &&
        l.push(t.assignTexture(a, 'map', f.baseColorTexture, qe)),
        (a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1),
        (a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1),
        f.metallicRoughnessTexture !== void 0 &&
          (l.push(
            t.assignTexture(a, 'metalnessMap', f.metallicRoughnessTexture)
          ),
          l.push(
            t.assignTexture(a, 'roughnessMap', f.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (u) {
          return u.getMaterialType && u.getMaterialType(e);
        })),
        l.push(
          Promise.all(
            this._invokeAll(function (u) {
              return u.extendMaterialParams && u.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = Nn);
    const h = s.alphaMode || Ec.OPAQUE;
    if (
      (h === Ec.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Ec.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== rr &&
        (l.push(t.assignTexture(a, 'normalMap', s.normalTexture)),
        (a.normalScale = new Ve(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const f = s.normalTexture.scale;
      a.normalScale.set(f, f);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== rr &&
        (l.push(t.assignTexture(a, 'aoMap', s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== rr)
    ) {
      const f = s.emissiveFactor;
      a.emissive = new Re().setRGB(f[0], f[1], f[2], _t);
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== rr &&
        l.push(t.assignTexture(a, 'emissiveMap', s.emissiveTexture, qe)),
      Promise.all(l).then(function () {
        const f = new o(a);
        return (
          s.name && (f.name = s.name),
          Ei(f, s),
          t.associations.set(f, { materials: e }),
          s.extensions && Yi(i, f, s),
          f
        );
      })
    );
  }
  createUniqueName(e) {
    const t = je.sanitizeNodeName(e || '');
    return t in this.nodeNamesUsed
      ? t + '_' + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function s(a) {
      return n[He.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (c) {
          return Pf(c, a, t);
        });
    }
    const o = [];
    for (let a = 0, c = e.length; a < c; a++) {
      const l = e[a],
        h = KE(l),
        f = i[h];
      if (f) o.push(f.promise);
      else {
        let u;
        l.extensions && l.extensions[He.KHR_DRACO_MESH_COMPRESSION]
          ? (u = s(l))
          : (u = Pf(new Dn(), l, t)),
          (i[h] = { primitive: l, promise: u }),
          o.push(u);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[e],
      o = s.primitives,
      a = [];
    for (let c = 0, l = o.length; c < l; c++) {
      const h =
        o[c].material === void 0
          ? XE(this.cache)
          : this.getDependency('material', o[c].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (c) {
        const l = c.slice(0, c.length - 1),
          h = c[c.length - 1],
          f = [];
        for (let p = 0, _ = h.length; p < _; p++) {
          const g = h[p],
            d = o[p];
          let m;
          const y = l[p];
          if (
            d.mode === gn.TRIANGLES ||
            d.mode === gn.TRIANGLE_STRIP ||
            d.mode === gn.TRIANGLE_FAN ||
            d.mode === void 0
          )
            (m = s.isSkinnedMesh === !0 ? new Nb(g, y) : new bn(g, y)),
              m.isSkinnedMesh === !0 && m.normalizeSkinWeights(),
              d.mode === gn.TRIANGLE_STRIP
                ? (m.geometry = wf(m.geometry, _p))
                : d.mode === gn.TRIANGLE_FAN &&
                  (m.geometry = wf(m.geometry, nl));
          else if (d.mode === gn.LINES) m = new Hb(g, y);
          else if (d.mode === gn.LINE_STRIP) m = new $l(g, y);
          else if (d.mode === gn.LINE_LOOP) m = new Gb(g, y);
          else if (d.mode === gn.POINTS) m = new Vb(g, y);
          else
            throw new Error(
              'THREE.GLTFLoader: Primitive mode unsupported: ' + d.mode
            );
          Object.keys(m.geometry.morphAttributes).length > 0 && YE(m, s),
            (m.name = t.createUniqueName(s.name || 'mesh_' + e)),
            Ei(m, s),
            d.extensions && Yi(i, m, d),
            t.assignFinalMaterial(m),
            f.push(m);
        }
        for (let p = 0, _ = f.length; p < _; p++)
          t.associations.set(f[p], { meshes: e, primitives: p });
        if (f.length === 1) return s.extensions && Yi(i, f[0], s), f[0];
        const u = new sr();
        s.extensions && Yi(i, u, s), t.associations.set(u, { meshes: e });
        for (let p = 0, _ = f.length; p < _; p++) u.add(f[p]);
        return u;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.');
      return;
    }
    return (
      n.type === 'perspective'
        ? (t = new Wt(
            bv.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === 'orthographic' &&
          (t = new Xl(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      Ei(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, s = t.joints.length; i < s; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency('accessor', t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const s = i.pop(),
          o = i,
          a = [],
          c = [];
        for (let l = 0, h = o.length; l < h; l++) {
          const f = o[l];
          if (f) {
            a.push(f);
            const u = new Ue();
            s !== null && u.fromArray(s.array, l * 16), c.push(u);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[l]
            );
        }
        return new Kl(a, c);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      n = this,
      i = t.animations[e],
      s = i.name ? i.name : 'animation_' + e,
      o = [],
      a = [],
      c = [],
      l = [],
      h = [];
    for (let f = 0, u = i.channels.length; f < u; f++) {
      const p = i.channels[f],
        _ = i.samplers[p.sampler],
        g = p.target,
        d = g.node,
        m = i.parameters !== void 0 ? i.parameters[_.input] : _.input,
        y = i.parameters !== void 0 ? i.parameters[_.output] : _.output;
      g.node !== void 0 &&
        (o.push(this.getDependency('node', d)),
        a.push(this.getDependency('accessor', m)),
        c.push(this.getDependency('accessor', y)),
        l.push(_),
        h.push(g));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(c),
      Promise.all(l),
      Promise.all(h)
    ]).then(function (f) {
      const u = f[0],
        p = f[1],
        _ = f[2],
        g = f[3],
        d = f[4],
        m = [];
      for (let y = 0, v = u.length; y < v; y++) {
        const x = u[y],
          S = p[y],
          b = _[y],
          T = g[y],
          C = d[y];
        if (x === void 0) continue;
        x.updateMatrix && x.updateMatrix();
        const M = n._createAnimationTracks(x, S, b, T, C);
        if (M) for (let A = 0; A < M.length; A++) m.push(M[A]);
      }
      return new Kb(s, void 0, m);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency('mesh', i.mesh).then(function (s) {
          const o = n._getNodeRef(n.meshCache, i.mesh, s);
          return (
            i.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let c = 0, l = i.weights.length; c < l; c++)
                    a.morphTargetInfluences[c] = i.weights[c];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      s = n._loadNodeShallow(e),
      o = [],
      a = i.children || [];
    for (let l = 0, h = a.length; l < h; l++)
      o.push(n.getDependency('node', a[l]));
    const c =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency('skin', i.skin);
    return Promise.all([s, Promise.all(o), c]).then(function (l) {
      const h = l[0],
        f = l[1],
        u = l[2];
      u !== null &&
        h.traverse(function (p) {
          p.isSkinnedMesh && p.bind(u, ZE);
        });
      for (let p = 0, _ = f.length; p < _; p++) h.add(f[p]);
      return h;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? i.createUniqueName(s.name) : '',
      a = [],
      c = i._invokeOne(function (l) {
        return l.createNodeMesh && l.createNodeMesh(e);
      });
    return (
      c && a.push(c),
      s.camera !== void 0 &&
        a.push(
          i.getDependency('camera', s.camera).then(function (l) {
            return i._getNodeRef(i.cameraCache, s.camera, l);
          })
        ),
      i
        ._invokeAll(function (l) {
          return l.createNodeAttachment && l.createNodeAttachment(e);
        })
        .forEach(function (l) {
          a.push(l);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (l) {
        let h;
        if (
          (s.isBone === !0
            ? (h = new kp())
            : l.length > 1
            ? (h = new sr())
            : l.length === 1
            ? (h = l[0])
            : (h = new st()),
          h !== l[0])
        )
          for (let f = 0, u = l.length; f < u; f++) h.add(l[f]);
        if (
          (s.name && ((h.userData.name = s.name), (h.name = o)),
          Ei(h, s),
          s.extensions && Yi(n, h, s),
          s.matrix !== void 0)
        ) {
          const f = new Ue();
          f.fromArray(s.matrix), h.applyMatrix4(f);
        } else
          s.translation !== void 0 && h.position.fromArray(s.translation),
            s.rotation !== void 0 && h.quaternion.fromArray(s.rotation),
            s.scale !== void 0 && h.scale.fromArray(s.scale);
        return (
          i.associations.has(h) || i.associations.set(h, {}),
          (i.associations.get(h).nodes = e),
          h
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      s = new sr();
    n.name && (s.name = i.createUniqueName(n.name)),
      Ei(s, n),
      n.extensions && Yi(t, s, n);
    const o = n.nodes || [],
      a = [];
    for (let c = 0, l = o.length; c < l; c++)
      a.push(i.getDependency('node', o[c]));
    return Promise.all(a).then(function (c) {
      for (let h = 0, f = c.length; h < f; h++) s.add(c[h]);
      const l = (h) => {
        const f = new Map();
        for (const [u, p] of i.associations)
          (u instanceof Hn || u instanceof Ct) && f.set(u, p);
        return (
          h.traverse((u) => {
            const p = i.associations.get(u);
            p != null && f.set(u, p);
          }),
          f
        );
      };
      return (i.associations = l(s)), s;
    });
  }
  _createAnimationTracks(e, t, n, i, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      c = [];
    Mi[s.path] === Mi.weights
      ? e.traverse(function (u) {
          u.morphTargetInfluences && c.push(u.name ? u.name : u.uuid);
        })
      : c.push(a);
    let l;
    switch (Mi[s.path]) {
      case Mi.weights:
        l = ds;
        break;
      case Mi.rotation:
        l = yr;
        break;
      case Mi.position:
      case Mi.scale:
        l = ps;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            l = ds;
            break;
          case 2:
          case 3:
          default:
            l = ps;
            break;
        }
        break;
    }
    const h = i.interpolation !== void 0 ? qE[i.interpolation] : hs,
      f = this._getArrayFromAccessor(n);
    for (let u = 0, p = c.length; u < p; u++) {
      const _ = new l(c[u] + '.' + Mi[s.path], t.array, f, h);
      i.interpolation === 'CUBICSPLINE' &&
        this._createCubicSplineTrackInterpolant(_),
        o.push(_);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = hl(t.constructor),
        i = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++) i[s] = t[s] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (n) {
      const i = this instanceof yr ? WE : Xp;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function QE(r, e, t) {
  const n = e.attributes,
    i = new fi();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION],
      c = a.min,
      l = a.max;
    if (c !== void 0 && l !== void 0) {
      if (
        (i.set(new P(c[0], c[1], c[2]), new P(l[0], l[1], l[2])), a.normalized)
      ) {
        const h = hl(es[a.componentType]);
        i.min.multiplyScalar(h), i.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new P(),
      c = new P();
    for (let l = 0, h = s.length; l < h; l++) {
      const f = s[l];
      if (f.POSITION !== void 0) {
        const u = t.json.accessors[f.POSITION],
          p = u.min,
          _ = u.max;
        if (p !== void 0 && _ !== void 0) {
          if (
            (c.setX(Math.max(Math.abs(p[0]), Math.abs(_[0]))),
            c.setY(Math.max(Math.abs(p[1]), Math.abs(_[1]))),
            c.setZ(Math.max(Math.abs(p[2]), Math.abs(_[2]))),
            u.normalized)
          ) {
            const g = hl(es[u.componentType]);
            c.multiplyScalar(g);
          }
          a.max(c);
        } else
          console.warn(
            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
          );
      }
    }
    i.expandByVector(a);
  }
  r.boundingBox = i;
  const o = new qn();
  i.getCenter(o.center),
    (o.radius = i.min.distanceTo(i.max) / 2),
    (r.boundingSphere = o);
}
function Pf(r, e, t) {
  const n = e.attributes,
    i = [];
  function s(o, a) {
    return t.getDependency('accessor', o).then(function (c) {
      r.setAttribute(a, c);
    });
  }
  for (const o in n) {
    const a = ll[o] || o.toLowerCase();
    a in r.attributes || i.push(s(n[o], a));
  }
  if (e.indices !== void 0 && !r.index) {
    const o = t.getDependency('accessor', e.indices).then(function (a) {
      r.setIndex(a);
    });
    i.push(o);
  }
  return (
    Xt.workingColorSpace !== _t &&
      'COLOR_0' in n &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Xt.workingColorSpace}" not supported.`
      ),
    Ei(r, e),
    QE(r, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? jE(r, e.targets, t) : r;
    })
  );
}
const eT = class extends Wn.Component {
  constructor(r) {
    super(r),
      (this.scene = null),
      (this.camera = null),
      (this.easing = 0.08),
      (this.cursor = { x: 0, y: 0 }),
      (this.events = {});
  }
  init() {
    console.log('Webgl component init'),
      (this.events.mouseMove = this.on({
        e: 'mousemove',
        target: window.document,
        cb: this.setCursor.bind(this)
      }));
    const r = { width: window.innerWidth, height: window.innerHeight };
    (this.DOM.canvas = this.DOM.el.querySelector('#webgl-bg')),
      (this.scene = new Ib()),
      (Xt.enabled = !1),
      (this.camera = new Wt(50, r.width / r.height, 0.1, 100)),
      (this.camera.position.z = 4.2),
      (this.camera.position.y = 10.1),
      this.scene.add(this.camera),
      (this.renderer = new Fp({ canvas: this.DOM.canvas, alpha: !0 })),
      (this.renderer.outputColorSpace = _t),
      this.renderer.setSize(r.width, r.height),
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const e = new yE();
    e.setDecoderPath('/models/dracos/');
    const t = new ME();
    t.setDRACOLoader(e),
      t.load('/models/gnochess-7.gltf', (o) => {
        (this.model = o.scene),
          this.model.scale.set(0.4, 0.4, 0.4),
          this.model.position.set(1.15, -0.4, 0),
          (this.model.rotation.y = Math.PI * 1.63),
          (this.king = this.model.children.find(
            (a) => a.name === 'King_light'
          )),
          (this.queen = this.model.children.find(
            (a) => a.name === 'Queen_light'
          )),
          (this.rook = this.model.children.find(
            (a) => a.name === 'Rook_light_1'
          )),
          (this.knight = this.model.children.find(
            (a) => a.name === 'Knight_light_2'
          )),
          (this.bishop = this.model.children.find(
            (a) => a.name === 'Bishop_light_2'
          )),
          this.king.position.set(
            this.king.position.x + 3.5,
            this.king.position.y + 2.5,
            this.king.position.z + 2.9
          ),
          (this.king.rotation.x = Math.PI * 0.35),
          (this.king.rotation.z = Math.PI * -0.1),
          this.queen.position.set(
            this.queen.position.x + 6.2,
            this.queen.position.y + 2.6,
            this.queen.position.z + 2.4
          ),
          (this.queen.rotation.x = Math.PI * 0.1),
          (this.queen.rotation.z = Math.PI * -0.2),
          this.rook.position.set(
            this.rook.position.x + 2,
            this.rook.position.y + 3,
            this.rook.position.z
          ),
          (this.rook.rotation.x = Math.PI * 0),
          (this.rook.rotation.z = Math.PI * 0.2),
          this.knight.position.set(
            this.knight.position.x + 4,
            this.knight.position.y + 5,
            this.knight.position.z + 1.55
          ),
          (this.knight.rotation.x = Math.PI * -0.1),
          (this.knight.rotation.z = Math.PI * 0.3),
          this.bishop.position.set(
            this.bishop.position.x + 4,
            this.bishop.position.y + 4,
            this.bishop.position.z + 2
          ),
          (this.bishop.rotation.x = Math.PI * -0.05),
          (this.bishop.rotation.z = Math.PI * -0.1),
          this.scene.add(this.model),
          (this.move1TL = Z.timeline({ paused: !0 })
            .to(this.model.rotation, { y: this.model.rotation.y + 1 })
            .to(this.model.position, { x: -1.5 }, 0)),
          (this.move2TL = Z.timeline({ paused: !0 })
            .to(this.queen.position, {
              x: this.queen.position.x - 6.2,
              y: this.queen.position.y - 2.6,
              z: this.queen.position.z - 2.4,
              duration: 1.2
            })
            .to(this.queen.rotation, { x: 0, y: 0, z: 0, duration: 1.2 }, '<')
            .to(
              this.king.position,
              {
                x: this.king.position.x - 3.5,
                y: this.king.position.y - 2.5,
                z: this.king.position.z - 2.9,
                duration: 1.4
              },
              '<'
            )
            .to(this.king.rotation, { x: 0, y: 0, z: 0, duration: 1.4 }, '<')
            .to(
              this.knight.position,
              {
                x: this.knight.position.x - 4,
                y: this.knight.position.y - 5,
                z: this.knight.position.z - 1.55,
                duration: 1.1
              },
              '<'
            )
            .to(this.knight.rotation, { x: 0, y: 0, z: 0, duration: 1.1 }, '<')
            .to(
              this.bishop.position,
              {
                x: this.bishop.position.x - 4,
                y: this.bishop.position.y - 4,
                z: this.bishop.position.z - 2,
                duration: 1.5
              },
              '<'
            )
            .to(this.bishop.rotation, { x: 0, y: 0, z: 0, duration: 1.5 }, '<')
            .to(
              this.rook.position,
              {
                x: this.rook.position.x - 2,
                y: this.rook.position.y - 3,
                duration: 1
              },
              '<'
            )
            .to(this.rook.rotation, { x: 0, y: 0, z: 0, duration: 1 }, '<')),
          (this.move3TL = Z.timeline({ paused: !0 }).to(this.model.rotation, {
            y: this.model.rotation.y + 1.4
          })),
          this.status !== 'none' && (this.appear(), this.moveScene());
      });
    const n = new cE(16777215, 3);
    this.scene.add(n);
    const i = new Wp(16777215, 1.8);
    (i.castShadow = !0),
      i.shadow.mapSize.set(1024, 1024),
      (i.shadow.camera.far = 15),
      (i.shadow.camera.left = -7),
      (i.shadow.camera.top = 7),
      (i.shadow.camera.right = 7),
      (i.shadow.camera.bottom = -7),
      i.position.set(-3, 6, 0),
      this.scene.add(i);
    const s = () => {
      (this.camera.position.x +=
        (this.cursor.x - this.camera.position.x + 0.3) * this.easing),
        (this.camera.position.y +=
          (this.cursor.y - this.camera.position.y + 1) * this.easing),
        this.camera.lookAt(0, 1.2, 0),
        this.renderer.render(this.scene, this.camera),
        window.requestAnimationFrame(s);
    };
    s();
  }
  setCursor(r) {
    (this.cursor.x = (r.clientX / document.body.clientWidth - 0.5) / 4),
      (this.cursor.y = (r.clientY / document.body.clientHeight - 0.5) / 4);
  }
  changeStatus(r) {
    this.status = r;
  }
  moveScene() {
    if (this.model) {
      if (this.status === 'init')
        this.move1TL.reverse(),
          this.move2TL.timeScale(2),
          this.move2TL.reverse();
      else if (this.status === 'pending') this.move1TL.play();
      else if (this.status === 'action')
        this.move2TL.timeScale(1), this.move2TL.play();
      else if (this.status === 'none') return;
    }
  }
  appear() {
    Z.to(this.DOM.canvas, { autoAlpha: 1 }), this.move1TL.reverse();
  }
  disappear(r = !1) {
    return (
      this.model && !r && this.move3TL.play(),
      Z.to(this.DOM.canvas, { autoAlpha: 0 })
    );
  }
  resize() {
    const r = { width: window.innerWidth, height: window.innerHeight };
    (this.camera.aspect = r.width / r.height),
      this.camera.updateProjectionMatrix(),
      this.renderer.setSize(r.width, r.height),
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  }
  destroy() {
    this.scene.traverse(function (r) {
      r.geometry && r.geometry.dispose(),
        r.material &&
          (Array.isArray(r.material)
            ? r.material.forEach(function (e) {
                e.dispose();
              })
            : r.material.dispose());
    }),
      this.scene.dispose(),
      this.move1TL.kill(),
      this.move2TL.kill();
  }
};
function Ac(r) {
  function e(t) {
    var n,
      i = t.length,
      s = 0;
    for (n = 0; n < i; n++) s += parseInt(t[n], 36) - 9;
    let o = 0;
    for (; s >= 10; ) {
      for (o = 0; s > 0; ) {
        let c;
        (c = s % 10), (o = o + c), (s = s / 10);
      }
      s = o;
    }
    return (s - 0) / (10 - 0);
  }
  return e(r);
}
const tT = class extends Wn.Component {
    constructor(e) {
      super(e);
      tn(this, 'userToken');
    }
    init() {
      console.log('Dashboard component init'),
        (this.userToken = Rt.getToken() ?? null),
        this._feedUser(this.userToken),
        this._feedRatings(),
        this._feedLeaderbord();
    }
    _feedUserSocial() {}
    _feedUser(e) {
      const t = document.createElement('DIV');
      (t.style.filter = `brightness(${Ac(e)}`),
        (t.className = 'avatar_bg'),
        this.DOM.el.querySelector('.js-playeravatar').appendChild(t);
      const n = document.getElementById('js-dashtoken');
      n && e && (n.innerHTML = $c(e, 4, 4));
    }
    _createDomFunc(e, t) {
      const n = ['wins', 'draws', 'loses', 'game'],
        i = document.getElementById(`js-dashboard${e}Games`);
      return (
        n.forEach((s) => {
          const o = document.getElementById(
            `js-dashboard${e}${s.charAt(0).toUpperCase() + s.slice(1)}`
          );
          o && (o.innerHTML = t[s].toString());
        }),
        i && (i.innerHTML = (t.loses + t.draws + t.wins).toString()),
        t
      );
    }
    async _feedUserBlitzRating() {
      const e = await Rt.getBlitzRating();
      return this._createDomFunc('Blitz', e);
    }
    async _feedUserRapidRating() {
      const e = await Rt.getRapidRating();
      return this._createDomFunc('Rapid', e);
    }
    _feedUserGlobalRating(e) {
      return this._createDomFunc('Global', e);
    }
    async _feedRatings() {
      const t = (
        await Promise.all([
          this._feedUserBlitzRating(),
          this._feedUserRapidRating()
        ])
      ).reduce(
        (n, i) => (
          (i.wins += n.wins), (i.loses += n.loses), (i.draws += n.draws), i
        )
      );
      this._createPie(t), this._feedUserGlobalRating(t);
    }
    _createPie(e) {
      const t = e.wins + e.loses + e.draws,
        n = (o) => Math.round((o / t) * 100),
        i = [n(e.wins), n(e.loses), n(e.draws)],
        s = this.DOM.el.querySelector('#dashboard-rank');
      (s.style.background = `conic-gradient(#777777 0% ${i[0]}%, #b4b4b4 ${i[0]}% ${i[1]}%, #d9d9d9 ${i[1]}% ${i[2]}%)`),
        (s.innerHTML = `<span class="dashbord-global-rank-value">${i[0]}<span class="text-200">%</span> <br><span class="text-300">Wins</span></span>`);
    }
    _feedLeaderbord() {
      const t = [Rt.getBlitzLeaders(), Rt.getRapidLeaders()].map((s) =>
          s
            .map(
              (o) => (
                Ac(o.token),
                `<li class="dashboard-avatar">
                <div class="dashboard-avatar_img"><div class="dashboard-avatar_bg" style="filter: brightness(${Ac(
                  o.token
                )})"></div><img src="/img/mini-gopher.png" alt="avatar"/></div>
                <div class="dashboard-avatar_info">${$c(o.token, 4, 4)}</div>
          </li>`
              )
            )
            .reduce((o, a) => o + a)
        ),
        n = document.getElementById('js-dashrapidleaderboard'),
        i = document.getElementById('js-dashblitzleaderboard');
      i && (i.innerHTML = t[0]), n && (n.innerHTML = t[1]);
    }
    destroy() {}
  },
  nT = class extends Wn.Component {
    constructor(r) {
      super(r);
    }
    init() {
      (this.DOM.category = this.DOM.el.querySelector('#game-category')),
        console.log('PlayCategory component init');
    }
    setCategory(r) {
      (this.DOM.category.innerHTML = r.toUpperCase()),
        si(this.DOM.category, {
          tagName: 'span',
          type: 'letter',
          nesting: 2,
          classPrefix: 'char char'
        });
    }
    appear() {
      Z.to(this.DOM.el, { autoAlpha: 1, display: 'flex' });
      const r = [...this.DOM.el.querySelectorAll('.char > span')];
      Z.to(r, { y: 0, stagger: 0.06 });
    }
    disappear() {
      Z.to(this.DOM.el, { autoAlpha: 0, display: 'none' });
      const r = [...this.DOM.el.querySelectorAll('.char > span')];
      Z.to(r, { y: '100%' });
    }
    destroy() {}
  },
  iT = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Dashboard: tT,
        Gameboard: u0,
        Gamecategory: nT,
        Gamecontrols: $_,
        Gamefen: K_,
        Gameoptions: j_,
        Gameplayers: Y_,
        Router: Qg,
        Webgl: eT
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  );
window.addEventListener('load', function () {
  Z.config({ nullTargetWarn: !1 });
  const r = new Wn.App({ components: iT });
  r.init(r);
});
